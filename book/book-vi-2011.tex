% LaTeX source for ``Think Python: An Introduction to Software Design''
% Copyright (c)  2008  Allen B. Downey.

% Permission is granted to copy, distribute and/or modify this
% document under the terms of the GNU Free Documentation License,
% Version 1.1  or any later version published by the Free Software
% Foundation; with no Invariant Sections, no Front-Cover Texts,
% and no Back-Cover Texts.

% This distribution includes a file named fdl.tex that contains the text
% of the GNU Free Documentation License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
%

%\documentclass[10pt,b5paper]{book}
\documentclass[11pt]{book}
\usepackage[width=5.5in,height=8.5in,
  hmarginratio=3:2,vmarginratio=1:1]{geometry}

\usepackage{pslatex}
\usepackage{url}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{exercisevn}
\usepackage{makeidx}
\usepackage{setspace}
% \usepackage{hevea}
% \usepackage{upquote}

\usepackage[utf8]{vietnam}

\newcommand{\thetitle}{Tư duy trong Python: Nhập môn thiết kế phần mềm}
\newcommand{\theversion}{1.1.14--28}

\makeindex

\begin{document}

\frontmatter

% LATEXONLY
% Chien disables this portion

\input{latexonly}

\newtheorem{ex}{Exercise}[chapter]

%% \begin{latexonly}

\renewcommand{\blankpage}{\thispagestyle{empty} \quad \newpage}

%\blankpage
%\blankpage

% TITLE PAGES FOR LATEX VERSION

%-half title--------------------------------------------------
% Chien disabled this page
% \thispagestyle{empty}

% \begin{flushright}
% \vspace*{2.0in}

% \begin{spacing}{3}
% {\huge Think Python}\\
% {\Large An Introduction to Software Design}
% \end{spacing}

% \vspace{0.25in}

% Version \theversion

% \vfill

% \end{flushright}

%--verso------------------------------------------------------

% \blankpage
% \blankpage
%\clearemptydoublepage
%\pagebreak
%\thispagestyle{empty}
%\vspace*{6in}

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge Tư duy trong Python}\\
{\Large Để nghĩ như nhà khoa học máy tính}
\end{spacing}

\vspace{0.25in}

Version \theversion

\vspace{1in}


{\Large
Allen Downey\\
}


\vspace{0.5in}

{\Large Green Tea Press}

{\small Needham, Massachusetts}

%\includegraphics[width=1in]{figs/logo1.eps}
\vfill

\end{flushright}


%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

{\small
Copyright \copyright ~2008 Allen Downey.


Printing history:

\begin{description}

\item[April 2002:] First edition of {\em How to Think Like
a Computer Scientist}.

\item[August 2007:] Major revision, changed title to
{\em How to Think Like a (Python) Programmer}.

\item[June 2008:] Major revision, changed title to
{\em Think Python: An Introduction to Software Design}.

\item[September 2008:] Vietnamese translation {\em Tư duy
trong Python: Để nghĩ như nhà khoa học máy tính} by Nguyễn Quang Chiến.

\end{description}

\vspace{0.2in}

\begin{flushleft}
Green Tea Press       \\
9 Washburn Ave \\
Needham MA 02492
\end{flushleft}

Permission is granted to copy, distribute, and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and with no Back-Cover Texts.

The GNU Free Documentation License is available from {\tt www.gnu.org}
or by writing to the Free Software Foundation, Inc., 59 Temple Place,
Suite 330, Boston, MA 02111-1307, USA.

The original form of this book is \LaTeX\ source code.  Compiling this
\LaTeX\ source has the effect of generating a device-independent
representation of a textbook, which can be converted to other formats
and printed.

The \LaTeX\ source for this book is available from
\url{http://www.thinkpython.com}

\vspace{0.2in}

} % end small

%% \end{latexonly}


% HTMLONLY
% Chien disabled this portion
% \begin{htmlonly}

% TITLE PAGE FOR HTML VERSION

% {\Large \thetitle}

% {\large Allen B. Downey}

% Version \theversion

% \setcounter{chapter}{-1}

% \end{htmlonly}

\chapter{Lời nói đầu}

\section*{Sự ra đời kì lạ của cuốn sách này}

Tháng Giêng năm 1999 tôi chuẩn bị dạy một lớp học nhập môn lập trình
ngôn ngữ Java.  Tôi đã từng dạy khoá học này ba lần và cảm thấy không 
hài lòng.  Sinh viên có tỉ lệ thi trượt rất cao, và ngay cả những người qua
được, thì điểm cũng không khả quan.

Một trong những vấn đề tôi thấy được là ở những cuốn sách giáo trình.
Chúng thường quá dày, với nhiều chi tiết nhỏ nhặt về Java, và 
không có đủ những hướng dẫn lập trình theo tầm nhìn bao quát.
Và chúng đều bị mắc phải hiệu ứng ``cửa sập'': khởi đầu rất dễ dàng,
phát triển từ từ, và đến Chương 5 thì lôi ra đủ mọi kiến thức.
Sinh viên sẽ tiếp thu quá nhiều tài liệu, quá gấp, và hậu quả cuối cùng
là đến cuối kì thì ``chữ thầy trả thầy''.

Hai tuần lễ trước khi khoá học bắt đầu, tôi quyết định viết quyển
sách của riêng mình.
Mục tiêu của tôi là:

\begin{itemize}

\item Viết ngắn gọn. Để sinh viên đọc 10 trang thì hay hơn là 50 trang.

\item Chú ý đến từ ngữ. Tôi cố gắng hạn chế dùng các thuật ngữ, và 
mỗi khi dùng lần đầu thì định nghĩa chúng luôn.

\item Xây dựng dần dần. Để tránh các tình trạng ``cửa sập'', tôi đem chia
nhỏ những chủ đề khó thành một chuỗi các bước kế tiếp nhau.

\item Chú ý đến lập trình thay vì ngôn ngữ lập trình. Tôi chỉ trình bày
phần rất nhỏ nhưng thiết yếu của Java và lược qua tất cả phần còn lại.

\end{itemize}

Nhan đề cuốn sách tôi chọn theo ý thích của riêng mình, là {\em Để suy nghĩ 
như một nhà khoa học máy tính}.

Phiên bản ban đầu rất sơ lược, nhưng đã có hiệu quả. Sinh viên nghiêm túc
đọc tài liệu, và hiểu rằng khi lên lớp tôi chỉ giảng về những phần khó, còn
những chủ đề hay (và quan trọng nhất) là để cho sinh viên luyện tập.

Tôi đã phát hành quyển sách theo giấy phép Văn bản tự do của GNU,
theo đó người dùng có thể tự sao chép, sửa đổi và phân phối sách.

\index{Giấy phép Văn bản tự do của GNU}
\index{Free Documentation License, GNU}

Câu chuyện tiếp diễn rất thú vị. Jeff Elkner, một giáo viên trung học
dạy tại Virginia, đã chọn lấy cuốn sách của tôi và biên tập với ngôn ngữ
Python. Ông đã gửi tôi một bản dịch, và tôi đã có một kinh nghiệm
thú vị khi học được Python từ chính sách của mình.

Jeff và tôi đã hiệu đính lại quyển sách, thêm vào một phần ví dụ thực tế
của Chris Meyers, và năm 2001 chúng tôi phát hành {\em Để tư duy như
một nhà khoa học máy tính: với ngôn ngữ Python}, cũng theo 
Giấy phép Văn bản tự do của GNU.

Với nhà xuất bản Green Tea, tôi phát hành quyển sách và bắt đầu bán
những cuốn sách in, qua Amazon.com và các hiệu sách đại học.
Những cuốn sách khác cùng nhà xuất bản Green Tea đều có tại
\url{greenteapress.com}.

Năm 2003 tôi bắt đầu dạy tại Đại học Olin College, cũng là lần đầu tiên tôi dạy
Python. Nét tương phản với Java thật là ấn tượng. Sinh viên đã đỡ vất vả,
học được nhiều hơn, tham gia nhiều dự án thú vị hơn, và nói chung đều 
rất vui vẻ.

Trong khoảng năm năm qua tôi vẫn tiếp tục chỉnh biên cuốn sách, 
sủa lỗi, cải thiện các ví dụ và thêm vào tư liệu, đặc biệt là các bài tập.
Trong năm 2008 tôi đã bắt đầu làm việc với một phiên bản chính --- 
cùng lúc đó tôi có được hợp đồng với một biên tập viên tại
Nhà xuất bản Đại học Cambridge. Họ muốn tiếp tục phát hành
một ấn bản kế tiếp. Thật kịp thời!

Kết quả là cuốn sách này, bây giờ đã với tên gọi ngắn gọn hơn:
{\em Tư duy trong Python}.  Một số sửa đổi bao gồm:

\begin{itemize}

\item Tôi đã thêm vào một mục ở cuối mỗi chương, chuyên về gỡ lỗi.
  Mục này trình bày những kĩ thuật chung để phát hiện và tránh
  lỗi khi lập trình, và cảnh báo những bẫy nhỏ trong Python.

\item Tôi lược bỏ một số phần trong những chương cuối, về tạo lập
  các danh sách và cấu trúc cây. Mặc dù vẫn thích những chủ đề này,
  nhưng tôi nghĩ rằng chúng không phù hợp với phần còn lại
  của cuốn sách.

\item Tôi đã thêm vào các bài tập, từ những bài kiểm tra ngắn về
  độ hiểu bài cho đến một vài chương trình phần mềm thực sự.
  
\item Tôi bổ sung thêm một loạt các chương trình cụ thể---những ví dụ dài hơn 
  với bài tập, lời giải, và biện luận. Một số trong đó dựa trên Swampy,
  một bộ chương trình Python mà tôi đã soạn thảo cho quá trình
  dạy trên lớp. Swampy, mã lệnh, và lời giải được tải lên trang 
  \url{thinkpython.com}.
  
\item Tôi đã mở rộng các kế hoạch xây dựng chương trình và những 
  kiểu mẫu thiết kế cơ bản.

\item Ứng dụng của Python đã gãy gọn hơn. Cuốn sách chủ yếu là về lập trình,
  chứ không phải Python, nhưng theo tôi bây giờ nó đã cải thiện nhiều
  nhờ vào ngôn ngữ.

\end{itemize}

Tôi hi vọng bạn thích đọc cuốn sách này, với mục đích giúp cho
bạn học cách lập trình và tư duy phần nào được 
giống như một nhà khoa học máy tính.

Allen B. Downey \\
Needham Massachusett, Hoa Kì.\\

Allen Downey là Phó Giáo sư ngành Khoa học máy tính tại  
trường Đại học kỹ thuật Franklin W. Olin.



% \section*{For the teacher}

% Swampy and UML


% \section*{For the student}

% Try out examples.

% Do the in-chapter examples.

% Where to get the code.

\section*{Lời cảm ơn}

Trong bản dịch này tôi xin phép được lược bỏ đoạn ``Lời cảm ơn''
mà tác giả đã Allen B. Downey đã đề cập rất chi tiết trong bản gốc.

% First and most importantly, I thank Jeff Elkner, who
% translated my Java book into Python, which got this project
% started and introduced me to what has turned out to be my
% favorite language.

% I also thank Chris Meyers, who contributed several sections
% to {\em How to Think Like a Computer Scientist}.

% And I thank the Free Software Foundation for developing
% the GNU Free Documentation License, which helped make
% my collaboration with Jeff and Chris possible.

% \index{GNU Free Documentation License}
% \index{Free Documentation License, GNU}

% I also thank the editors at Lulu who worked on
% {\em How to Think Like a Computer Scientist}.

% I thank all the students who worked with earlier
% versions of this book and all the contributors (listed
% below) who sent in corrections and suggestions.

% And I thank my wife, Lisa, for her work on this book, and Green
% Tea Press, and everything else, too.


% \section*{Contributor List}

% \index{contributors}

% More than 100 sharp-eyed and thoughtful readers have sent in
% suggestions and corrections over the past few years.  Their
% contributions, and enthusiasm for this project, have been a
% huge help.

% If you have a suggestion or correction, please send email to 
% {\tt feedback@thinkpython.com}.  If I make a change based on your
% feedback, I will add you to the contributor list
% (unless you ask to be omitted).

% If you include at least part of the sentence the
% error appears in, that makes it easy for me to search.  Page and
% section numbers are fine, too, but not quite as easy to work with.
% Thanks!

% \small

% \begin{itemize}

% \item Lloyd Hugh Allen sent in a correction to Section 8.4.
% He can be reached at: {\tt lha2@columbia.edu}

% \item Yvon Boulianne sent in a correction of a semantic error in
% Chapter 5.
%She can be reached at: {\tt mystic@monuniverse.net}

% \item Fred Bremmer submitted a correction in Section 2.1.
%He can be reached at:  {\tt Fred.Bremmer@ubc.cu}

% \item Jonah Cohen wrote the Perl scripts to convert the
% LaTeX source for this book into beautiful HTML.

%His Web page is {\tt jonah.ticalc.org}
%and his email is {\tt JonahCohen@aol.com}

% \item Michael Conlon sent in a grammar correction in Chapter 2
% and an improvement in style in Chapter 1, and he initiated discussion
% on the technical aspects of interpreters.

%Michael can be reached at: {\tt michael.conlon@sru.edu}

% \item Benoit Girard sent in a
% correction to a humorous mistake in Section 5.6.

%Benoit can be reached at:
%{\tt benoit.girard@gouv.qc.ca}

% \item Courtney Gleason and Katherine Smith wrote {\tt horsebet.py},
% which was used as a case study in an earlier version of the book.  Their
% program can now be found on the website.

%Courtney can be reached at: {\tt
%orion1558@aol.com}

% \item Lee Harr submitted more corrections than we have room to list
% here, and indeed he should be listed as one of the principal editors
% of the text.

%He can be reached at: {\tt missive@linuxfreemail.com}

% \item James Kaylin is a student using the text. He has submitted
% numerous corrections.

%James can be reached by email at: {\tt Jamarf@aol.com}

% \item David Kershaw fixed the broken {\tt catTwice} function in Section
% 3.10.

%He can be reached at: \verb"david_kershaw@merck.com"

% \item Eddie Lam has sent in numerous corrections to Chapters 
% 1, 2, and 3.
% He also fixed the Makefile so that it creates an index the first time it is
% run and helped us set up a versioning scheme.  

%Eddie can be reached at:
%{\tt nautilus@yoyo.cc.monash.edu.au}

% \item Man-Yong Lee sent in a correction to the example code in
% Section 2.4.  

%He can be reached at: {\tt yong@linuxkorea.co.kr}

% \item David Mayo pointed out that the word ``unconsciously"
% in Chapter 1 needed
% to be changed to ``subconsciously".

%David can be reached at:{\tt bdbear44@netscape.net}

% \item Chris McAloon sent in several corrections to Sections 3.9 and
% 3.10.

%He can be reached at: {\tt cmcaloon@ou.edu}

% \item Matthew J. Moelter has been a long-time contributor who sent
% in numerous corrections and suggestions to the book.  

%He can be reached at:
%{\tt mmoelter@calpoly.edu}

% \item Simon Dicon Montford reported a missing function definition and
% several typos in Chapter 3.  He also found errors in the {\tt increment}
% function in Chapter 13.

%He can be reached at: {\tt dicon@bigfoot.com}

% \item John Ouzts corrected the definition of ``return value"
% in Chapter 3.

%He can be reached at: {\tt jouzts@bigfoot.com}

% \item Kevin Parks sent in valuable comments and suggestions as to how
% to improve the distribution of the book.

%He can be reached at: {\tt cpsoct@lycos.com}

% \item David Pool sent in a typo in the glossary of Chapter 1, as well
% as kind words of encouragement.

%He can be reached at: {\tt pooldavid@hotmail.com}

% \item Michael Schmitt sent in a correction to the chapter on files
% and exceptions.

%He can be reached at: \verb"ipv6_128@yahoo.com"

% \item Robin Shaw pointed out an error in Section 13.1, where the
% printTime function was used in an example without being defined.

%Robin can be reached at: {\tt randj@iowatelecom.net}

% \item Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen's
% Perl script that generates HTML from LaTeX.

%He can be reached at: {\tt bat@atdot.dotat.org}

%\item Christopher Smith is a computer science teacher at the Blake
%School in Minnesota who teaches Python to his beginning students.

%He can be reached at: {\tt csmith@blakeschool.org or smiles@saysomething.com}

% \item Craig T. Snydal is testing the text in a course at Drew
% University.  He has contributed several valuable suggestions and corrections.

%and can be reached at: {\tt csnydal@drew.edu}

% \item Ian Thomas and his students are using the text in a programming
% course.  They are the first ones to test the chapters in the latter half
% of the book, and they have made numerous corrections and suggestions.

%Ian can be reached at: {\tt ithomas@sd70.bc.ca}

% \item Keith Verheyden sent in a correction in Chapter 3.

%He can be reached at: {\tt kverheyd@glam.ac.uk}

% \item Peter Winstanley let us know about a longstanding error in
% our Latin in Chapter 3.

%He can be reached at:{\tt Peter.Winstanley@scotland.gsi.gov.uk} 

% \item Chris Wrobel made corrections to the code in the chapter on
% file I/O and exceptions. 

%He can be reached at: {\tt ferz980@yahoo.com}

% \item Moshe Zadka has made invaluable contributions to this project.
% In addition to writing the first draft of the chapter on Dictionaries, he
% provided continual guidance in the early stages of the book.

%He can be reached at: {\tt moshez@math.huji.ac.il}

% \item Christoph Zwerschke sent several corrections and
% pedagogic suggestions, and explained the difference between {\em gleich}
% and {\em selbe}.

% \item James Mayer sent us a whole slew of spelling and
% typographical errors, including two in the contributor list.

% james.mayer@acm.org

% \item Hayden McAfee caught a potentially confusing inconsistency
% between two examples.
%hayden.mcafee@mindspring.com

% \item Angel Arnal is part of an international team of translators
% working on the Spanish version of the text.  He has also found several
% errors in the English version.

% \item Tauhidul Hoque and Lex Berezhny created the illustrations
% in Chapter 1 and improved many of the other illustrations.

% \item Dr. Michele Alzetta caught an error in Chapter 8 and sent
% some interesting pedagogic comments and suggestions about Fibonacci
% and Old Maid.
%mikalzet@libero.it

% \item Andy Mitchell caught a typo in Chapter 1 and a broken example
% in Chapter 2.
%phantom917@hotmail.com

% \item Kalin Harvey suggested a clarification in Chapter 7 and
% caught some typos.
%kalin@metamuscle.net

% \item Christopher P. Smith caught several typos and is helping us
% prepare to update the book for Python 2.2.
%csmith@blakeschool.org

% \item David Hutchins caught a typo in the Foreword.
%jsdah2@uas.alaska.edu

% \item Gregor Lingl is teaching Python at a high school in Vienna,
% Austria.  He is working on a German translation of the book,
% and he caught a couple of bad errors in Chapter 5.
%glingl@aon.at

%Sean McShane sent us a very nice note
%sean.mcshane@sheridanc.on.ca

% \item Julie Peters caught a typo in the Preface.
%jkpeters@dmacc.cc.ia.us

% \item Florin Oprina sent in an improvement in {\tt makeTime},
% a correction in {\tt printTime}, and a nice typo.
%oprina@student.uit.no 

% \item D.~J.~Webre suggested a clarification in Chapter 3.
%d_webre@yahoo.com

% \item 
% jkane@broadlink.com

% \item Ken found a fistful of errors in Chapters 8, 9 and 11.
%ken@codeweavers.com

% \item Ivo Wever caught a typo in Chapter 5 and suggested a clarification
% in Chapter 3.
% I.J.W.Wever@student.tnw.tudelft.nl

% rbeumer@knijnenberg.nl

% \item Curtis Yanko suggested a clarification in Chapter 2.
% YankoC@gspinc.com

% \item Ben Logan sent in a number of typos and problems with translating
% the book into HTML.
%ben@wblogan.net

%\item XXX suggested a clarification in Chapter 7, but prefers not
% to be included here.
%ejykfy@comcast.net

%\item Florian Thiel caught an inconsistency in Chapter 2.
%noroute@web.de

% \item Jason Armstrong saw the missing word in Chapter 2.
%jarmstrong@technicacorp.com

% \item Louis Cordier noticed a spot in Chapter 16 where the code
% didn't match the text.
% lcordier@dsp.sun.ac.za

% \item Brian Cain suggested several clarifications in Chapters 2 and 3.
% Brian.Cain@motorola.com

% \item Rob Black sent in a passel of corrections, including some
% changes for Python 2.2.
% Rob.Black@static2358.com

% \item Jean-Philippe Rey at Ecole Centrale
% Paris sent a number of patches, including some updates for Python 2.2
% and other thoughtful improvements.
%<jean-philippe.rey@ecp.fr>

% \item Jason Mader at George Washington University made a number
% of useful suggestions and corrections.
%Jason Mader <jason@ncac.gwu.edu>

% \item Jan Gundtofte-Bruun reminded us that ``a error'' is an error.
% Jan Gundtofte-Bruun <jan@g-b.dk>

% \item Abel David and Alexis Dinno reminded us that the plural of
% ``matrix'' is ``matrices'', not ``matrixes''.  This error was in the
% book for years, but two readers with the same initials reported it on
% the same day.  Weird.
% Abel David <abel.david@gmail.com>, lexy-lou@doyenne.com

% \item Charles Thayer encouraged us to get rid of the semi-colons
% we had put at the ends of some statements and to clean up our
% use of ``argument'' and ``parameter''.
% Charles Thayer <catintp@yahoo.com>

% \item Roger Sperberg pointed out a twisted piece of logic in Chapter 3.
%<rsperberg@gmail.com>

% \item Sam Bull pointed out a confusing paragraph in Chapter 2.
%Sam Bull <dreamsorcerer@gmail.com>

% \item Andrew Cheung pointed out two instances of ``use before def.''
%cheunga@u.washington.edu

%Steven Johnson <swj_ms@yahoo.com>

% \item C. Corey Capel spotted the missing word in the Third Theorem
% of Debugging and a typo in Chapter 4.
%"C. Corey Capel" <corey_capel@yahoo.com>

% \item Alessandra helped clear up some Turtle confusion.

% Sandra Amedick <almut@risclog.de>

% \item Wim Champagne found a brain-o in a dictionary example.

% <Wim.Champagne@telindus.com>

% \item Douglas Wright pointed out a problem with floor division in
% {\tt arc}.

%<douglas277@gmail.com>

% \item Jared Spindor found some jetsam at the end of a sentence.

%<jspindor@ruckerperformance.com>

% \item Lin Peiheng sent a number of very helpful suggestions.

%linpeiheng@163.com

% \item Ray Hagtvedt sent in two errors and a not-quite-error.

%<hagtvedt@yahoo.com>

% \item Torsten H\"{u}bsch pointed out an inconsistency in Swampy.

%<huebsch@gmail.com>

% \item Inga Petuhhov corrected an example in Chapter 14.

%<inga@tlu.ee>

% \item Arne Babenhauserheide sent several helpful corrections.

%<arne_bab@web.de>

% \item Mark E. Casida is is good at spotting repeated words.

% <mcasida@ujf-grenoble.fr> 

% \item Scott Tyler filled in a that was missing.  And then sent in
% a heap of corrections.

%<Scott.Tyler@ngc.com>

% \item Gordon Shephard sent in several corrections, all in separate
% emails.

%<gordon@shephard.org>

% \item Andrew Turner {\tt spot}ted an error in Chapter 8.

% <andrew.turner@goodrich.com>

% \item Adam Hobart fixed a problem with floor division in {\tt arc}.

% <ahobart@gmail.com>

% \item Daryl Hammond and Sarah Zimmerman pointed out that I served
% up {\tt math.pi} too early.  And Zim spotted a typo.

% DHammond@aol.com

% \item George Sass found a bug in a Debugging section.

% George Sass <George.Sass@students.olin.edu>

% \item Brian Bingham suggested Exercise~\ref{exrotatepairs}.

% \item Leah Engelbert-Fenton pointed out that I used {\tt tuple}
% as a variable name, contrary to my own advice.  And then found
% a bunch of typos and a ``use before def.''

% <Leah.Engelbert-Fenton@students.olin.edu>

% \item Joe Funke spotted a typo.

% Joe Funke <joseph.funke@students.olin.edu>

% \item Chao-chao Chen found an inconsistency in the Fibonacci example.

%<ed_chao@hotmail.com>

% \item Jeff Paine knows the difference between space and spam.

%<jeffreyalanpaine@gmail.com>

% \item Lubos Pintes sent in a typo.

%<lubos.pintes@orangemail.sk>

% \item Gregg Lind and Abigail Heithoff suggested Exercise~\ref{checksum}.

%<gregg@renesys.com>

% \item Max Hailperin pointed out a change coming in Python 3.0.  Max
% is one of the authors of the extraordinary {\em Concrete Abstractions},
% which you might want to read when you are done with this book.

% <max@gustavus.edu>

% \item Chotipat Pornavalai found an error in an error message.

% <chotipat@it.kmitl.ac.th>

% \item Stanislaw Antol sent a list of very helpful suggestions.

%<Stanislaw.Antol@students.olin.edu>

% \item Eric Pashman sent a number of corrections for Chapters 4--11.

%<eric.pashman@gmail.com>

% \item Miguel Azevedo found some typos.

%<miguel1626@gmail.com>

% \item Jianhua Liu sent in a long list of corrections.

%<liu620@erau.edu>

% \item Nick King found a missing word.

% <nicnik92@gmail.com>

% \item Martin Zuther sent a long list of suggestions.

% <mzuther@mzuther.de>

% \item Adam Zimmerman found an inconsistency in my instance
% of an ``instance'' and several other errors.

%<adam_zimmerman@sfu.ca>

% \item Ratnakar Tiwari suggested a footnote explaining degenerate
% triangles.

% Ratnakar.Tiwari@barclayscapital.com

% ENDCONTRIB

% \end{itemize}

\normalsize

\clearemptydoublepage

% TABLE OF CONTENTS
% \begin{latexonly}

% \tableofcontents

% \clearemptydoublepage

% \end{latexonly}

% START THE BOOK
\mainmatter


\chapter{Cơ chế của chương trình máy tính}

Mục đích của cuốn sách này là hướng dẫn bạn suy nghĩ như là một nhà 
khoa học máy tính. Cách tư duy này kết hợp những ưu điểm của khoa học
tự nhiên, trong đó có toán học, với kĩ thuật. Cũng như những nhà toán học,
những nhà khoa học máy tính dùng những ngôn ngữ có cấu trúc để diễn
đạt ý tưởng (đặc biệt là tính toán). Giống như những kĩ sư, họ cũng làm
công việc thiết kế, gắn kết các thành phần tạo nên một hệ thống và đánh giá
những ưu khuyết giữa các phương án khác nhau. Giống như những nhà
khoa học, họ khảo sát các động thái của hệ thống phức tạp, đề ra các
giả thiết, và kiểm định những tính toán.


\index{giải quyết vấn đề}

Kĩ năng quan trọng nhất của nhà khoa học máy tính là {\bf
giải quyết vấn đề}.  Giải quyết vấn đề chính là cách tạo lập vấn đề,
suy nghĩ giải pháp một cách sáng tạo, và trình bày giải pháp một cách
rõ ràng và chính xác. Như bạn sẽ thấy, việc học lập trình chính là một
cơ hội tuyệt vời để bạn luyện tập những kĩ năng giải quyết vấn đề. Đó là
lí do tại sao chương này lại có tên là ``Cơ chế của chương trình máy tính''.

Một mặt, bạn sẽ được học cách lập trình, vốn bản thân nó là một kĩ năng
hữu dụng. Mặt khác, bạn sẽ dùng lập trình như một phương tiện để giải
quyết vấn đề. Điều này bạn sẽ dần dần làm được trong quá trình học.

\section{Ngôn ngữ lập trình Python}
\index{ngôn ngữ lập trình}
\index{ngôn ngữ!lập trình}

Ngôn ngữ lập trình mà bạn sẽ học là Python. Python là một ví dụ trong số
các {\bf ngôn ngữ lập trình bậc cao}; một số ngôn ngữ lập trình bậc cao
khác mà bạn có thể biết đến gồm có C, C++, Perl, và Java.

Cũng có những {\bf ngôn ngữ lập trình bậc thấp}, đôi khi mà ta gọi là
``ngôn ngữ máy'' hoặc ``hợp ngữ.''  Nói nôm na, máy tính chỉ có thể thực
hiện các chương trình được viết bằng ngôn ngữ bậc thấp.  Vì vậy những
chương trình được viết bằng một ngôn ngữ bậc cao cần được xử lí trước khi 
chúng có thể chạy được. Bước phụ trợ này sẽ tốn thêm thời gian, đây là một
nhược điểm của các ngôn ngữ bậc cao.

\index{tính khả chuyển}
\index{ngôn ngữ bậc cao}
\index{ngôn ngữ bậc thấp}
\index{ngôn ngữ!bậc cao}
\index{ngôn ngữ!bậc thấp}

Tuy vậy, các ưu điểm là rất lớn. Thứ nhất, việc lập trình bằng ngôn ngữ
bậc cao dễ hơn rất nhiều. Chương trình được viết bằng ngôn ngữ bậc cao 
được viết nhanh hơn, nội dung chương trình ngắn hơn, dễ đọc hơn, và nhiều
khả năng là chúng chính xác.  Thứ hai, các ngôn ngữ bậc cao có tính {\bf
khả chuyển} theo nghĩa chạy được trên nhiều hệ máy tính khác nhau mà 
cần ít hoặc không cần sửa đổi. Các chương trình bậc thấp chỉ có thể chạy
trên một loại máy tính và phải được viết lại nếu muốn chạy trên các hệ máy khác.

Bởi các ưu điểm nêu trên, hầu hết các chương trình đều được lập trình bằng
ngôn ngữ bậc cao. Các ngôn ngữ bậc thấp chỉ được dùng cho một số ít những
ứng dụng đặc biệt.

\index{biên dịch}
\index{thông dịch}

Hai loại chương trình có nhiệm vụ chuyển đổi các ngôn ngữ bậc cao về dạng
ngôn ngữ bậc thấp: \textbf{trình thông dịch} và \textbf{trình biên dịch}.
Trình thông dịch đọc một chương trình bậc cao và thực hiện nó theo
đúng những gì mà chương trình chỉ định. Nó xử lí chương trình một cách dần dần,
nghĩa là đọc câu lệnh đến đâu thì thực hiện tính toán tới đó.

\beforefig
\centerline{\includegraphics[height=0.77in]{figs/interpret.eps}}
\afterfig

\index{mã nguồn}
\index{mã đối tượng}
\index{chương trình chạy}

Còn trình biên dịch thì đọc chương trình và dịch nó hoàn toàn trước khi
chương trình bắt đầu chạy. Theo nghĩa đó, chương trình bậc cao được
gọi là \textbf{mã nguồn}, và chương trình được dịch gọi là \textbf{mã
đối tượng}, hoặc \textbf{chương trình chạy}. Một khi chương trình được
biên dịch rồi, bạn có thể thực hiện nó nhiều lần sau này mà không phải
dịch nữa.

\beforefig
\centerline{\includegraphics[height=0.77in]{figs/compile.eps}}
\afterfig

Python được coi là ngôn ngữ thông dịch vì chương trình Python được thực
hiện bởi trình thông dịch. Có hai cách sử dụng trình thông dịch: theo \textbf
{chế độ tương tác} và \textbf{chế độ văn lệnh}. Trong chế độ tương tác, bạn
gõ vào các lệnh Python và trình thông dịch sẽ hiện kết quả lên màn hình:

\index{chế độ tương tác}
\index{chế độ văn lệnh}

\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%
Dấu \verb >>> \ ở đây là {\bf dấu nhắc} mà trình thông dịch dùng để thông báo 
rằng hiện giờ nó đang sẵn sàng đợi lệnh. Nếu bây giờ bạn gõ vào {\tt 1 + 1}, 
thì trình thông dịch sẽ trả lời là {\tt 2}.

\index{dấu nhắc}

Mặt khác, bạn cũng có thể lưu mã lệnh trong một file và sử dụng trình
thông dịch để thực hiện nội dung của file, mà ta gọi là một {\bf văn lệnh}.
Theo quy ước, các văn lệnh Python đều có đuôi là {\tt .py}.

\index{văn lệnh}

Để thực hiện văn lệnh, bạn phải báo cho trình biên dịch biết tên file.
Chẳng hạn, trong cửa sổ lệnh UNIX, bạn cần gõ vào {\tt python
dinsdale.py}.  Trong các môi trường khác, cách thực hiện văn lệnh
có thể khác đi. Bạn có thể tham khảo một số hướng dẫn trên trang
Web của Python: \url{python.org}.

\index{chạy thử!chế độ tương tác}

Làm việc trong chế độ tương tác rất thuận tiện nếu bạn cần kiểm tra
các đoạn mã ngắn vì bạn có thể gõ trực tiếp và chúng được thực hiện
ngay. Nhưng nếu mã lệnh gồm nhiều dòng thì bạn nên lưu chúng trong
một file văn lệnh để  sau này có thể chỉnh sửa và thực hiện chúng.

\section{Chương trình là gì?}

{\bf Chương trình} là một danh sách các chỉ dẫn cách thực hiện tính toán.
Việc tính toán có thể là thuần tuý toán học, chẳng hạn giải hệ phương
trình hoặc tìm nghiệm đa thức, nhưng cũng có thể là những phép tính trên 
các kí hiệu, chẳng hạn tìm kiếm và thay thế chữ trong một văn bản, hoặc
(kì lạ hơn) là biên dịch một chương trình.

\index{program}

Dù chi tiết có thể khác nhau tuỳ theo từng ngôn ngữ lập trình, nhưng
một số chỉ dẫn luôn có trong mọi ngôn ngữ:

\begin{description}

\item[nhập số liệu:] Là việc lấy số liệu từ bàn phím, file, hoặc một thiết bị khác.

\item[xuất kết quả:] Hiển thị kết quả trên màn hình hoặc gửi kết quả ra file
hoặc một thiết bị khác.

\item[tính toán:] Thực hiện các phép toán cơ bản như cộng và nhân.

\item[thực hiện có điều kiện:] Kiểm tra một điều kiện
cụ thể và thực hiện danh sách câu lệnh tương ứng với điều kiện đó.

\item[tính lặp:] Thực hiện lặp lại công việc nhiều lần, thường là với
một số thay đổi giữa các lần lặp.

\end{description}

Bạn có thể tin hay không, nhưng bất cứ một chương trình nào, dù
phức tạp đến đâu, đều được cấu thánh từ những chỉ dẫn đơn giản như
trên. Vì vậy, bạn có thể coi lập trình như việc chia một bài toán lớn, phức
tạp thành nhiều bài toán nhỏ hơn cho đến khi từng bài toán nhỏ này
đơn giản đến mức có thể được thực hiện theo một trong các chỉ dẫn
trên đây.

\index{thuật toán}

Điều đó có thể còn mơ hồ, nhưng ta sẽ quay lại chủ đề này khi 
bàn về \textbf{thuật toán}.

\section{Gỡ lỗi là gì?}
\index{gỡ lỗi}
\index{bug}

Việc lập trình rất hay mắc phải lỗi. Việc theo dõi, phân tích nguyên nhân
gây ra lỗi được gọi là {\bf gỡ lỗi}.

\index{debugging}
\index{bug}

Có ba loại lỗi có thể xuất hiện trong chương trình: lỗi cú pháp, lỗi chạy
và lỗi ngữ nghĩa. Để nhanh chóng tìm ra lỗi ta cần phân biệt được chúng.

\subsection{Lỗi cú pháp}
\index{lỗi cú pháp}
\index{lỗi!cú pháp}
\index{thông báo lỗi}

Python chỉ có thể thực hiện được một chương trình với những câu lệnh
đúng theo cú pháp; nếu không, trình thông dịch sẽ đưa ra thông báo
lỗi. {\bf Cú pháp} nghĩa là cấu trúc của chương trình và các quy tắc về
cấu trúc đó. \index{cú pháp} 
Chẳng hạn, ngoặc đơn phải đi theo từng cặp, như vậy
{\tt (1 + 2)} là hợp lệ, nhưng {\tt 8)} là một {\bf lỗi cú pháp}.

\index{cặp ngoặc đơn!khớp nhau}
\index{cú pháp}
\index{cummings, e. e.}

Trong ngôn ngữ hàng ngày người ta có thể bỏ qua nhiều lỗi cú pháp,
nhất là trong cách viết văn thơ. Python thì không như vậy. Nếu trong
chương trình có bất cứ lỗi cú pháp nào, Python sẽ hiển thị thông
báo lỗi và dừng chạy chương trình. Nếu bạn mới nhập môn lập trình
được vài tuần, rất có thể bạn phải dành nhiều thời gian dò tìm lỗi. Khi
kinh nghiệm tăng dần lên, bạn sẽ tránh được lỗi tốt hơn và nếu mắc
thì cũng phát hiện ra lỗi nhanh hơn.


\subsection{Lỗi thực thi}
\index{thực thi, lỗi}
\index{lỗi!thực thi}
\index{ngôn ngữ kiểu an toàn}
\index{ngôn ngữ!kiểu an toàn}

Loại lỗi thứ hai là lỗi thực thi; chúng có tên như vậy bởi vì
chỉ xuất hiện khi chương trình đã bắt đầu chạy. Những lỗi kiểu này
được gọi là \textbf{bất thường} bởi vì chúng thường chỉ những điều 
kiện (xấu) bất thường phát sinh.

Với những chương trình đơn giản trong một vài chương đầu tiên, ta 
ít gặp những lỗi chạy chương trình kiểu như vậy.

\subsection{Lỗi ngữ nghĩa}
\index{ngữ nghĩa}
\index{lỗi!ngữ nghĩa}
\index{thông báo lỗi}

Loại lỗi thứ ba là \textbf{lỗi ngữ nghĩa}. Trong trường hợp có lỗi
kiểu này, chương trình vẫn chạy thông theo nghĩa máy sẽ không
phát thông báo lỗi, nhưng sẽ không thực hiện đúng yêu cầu
mong muốn, mà sẽ cho kết quả khác. Cụ thể là thực hiện theo
đúng những hướng dẫn câu lệnh trong chương trình.

Vấn đề ở đây là chương trình bạn viết sẽ không đúng theo ý muốn
của bạn. Ý nghĩa của chương trình bị sai lệch. Việc phát hiện các lỗi
ngữ nghĩa đôi lúc rất khó vì bạn cần phải quay ngược lại và nhìn vào
kết quả của chương trình để phán đoán xem bản thân chương trình
đã thực hiện những gì.

\subsection{Gỡ lỗi thử nghiệm}

Một trong những kĩ năng quan trọng nhất mà bạn sẽ học được, đó là
gỡ lỗi. Mặc dù đôi khi rất khó chịu, nhưng việc gỡ lỗi rất cần trí
tuệ, chứa đầy thử thách và là một phần thú vị trong lập trình.

\index{gỡ lỗi thử nghiệm}
\index{gỡ lỗi!thử nghiệm}

Theo một nghĩa nào đó, gỡ lỗi giống như việc điều tra tội phạm. Bạn
có trong tay các manh mối, phải suy luận ra các quá trình và sự kiện
dẫn đến những hậu quả đang chứng kiến.

Việc gỡ lỗi cũng giống như khoa học thực nghiệm. Mỗi khi có ý
kiến về nguyên nhân dẫn đến lỗi sai, bạn sửa chữa chương trình và 
thực hiện lại. Nếu giả thiết của bạn là đúng thì bạn thu được kết
quả của công việc sửa chữa, đồng thời tiến một bước gần hơn tới chương
trình đúng. Còn nếu giả thiết là sai thì bạn cần đề ra một giả thiết mới.
Sherlock Holmes đã chỉ ra, ``Khi bạn đã loại trừ tất cả những điều
không thể thì những gì còn lại, dù có mập mờ đến đâu, phải là sự thật.''
(A. Conan Doyle, {\em Dấu của bộ tứ})

\index{Holmes, Sherlock}
\index{Doyle, Arthur Conan}

Đối với một số người, việc lập trình và gỡ lỗi là giống nhau. Đó là vì lập
trình chính là quá trình gỡ lỗi dần dần đến khi bạn có được chương trình
mong muốn. Ý tưởng ở đây  là bạn nên bắt đầu với một chương trình
có một tính năng \emph{nhỏ} nào đó và thực hiện các chỉnh sửa, gỡ
lỗi trong suốt quá trình, đến khi bạn có được một chương trình hoàn thiện.

Chẳng hạn, Linux là một hệ điều hành bao gồm hàng nghìn dòng lệnh,
nhưng nó chỉ bắt đầu từ một chương trình đơn giản do Linus Torvalds
dùng để khám phá chip Intel 80386. Theo Larry Greenfield thì ``Một
trong những dự án trước đó của Linus là một chương trình có nhiệm
vụ chuyển từ việc in AAAA thành BBBB. Sau đó nó dần trở thành Linux.''
({\em The Linux Users' Guide} Beta Version 1 / \emph{Hướng dẫn sử dụng
Linux}, phiên bản Beta 1).

\index{Linux}

Các chương tiếp sau đây sẽ nói thêm về việc gỡ lỗi và các vấn đề
thực tế trong lập trình.

\section{Ngôn ngữ hình thức và ngôn ngữ tự nhiên}
\index{hình thức, ngôn ngữ}
\index{tự nhiên, ngôn ngữ}
\index{ngôn ngữ!hình thức}
\index{ngôn ngữ!tự nhiên}

{\bf Ngôn ngữ tự nhiên} được mọi người dùng để giao tiếp,
ví dụ Tiếng Anh, Tiếng Tây Ban Nha, Tiếng Pháp. Chúng
tự do phát triển mà 
không định theo khuôn mẫu với bất kì mục đích nào (mặc dù 
có một số trật tự chẳng hạn như ngữ pháp); 

{\bf Ngôn ngữ hình thức} được con người thiết kế để ứng dụng trong những
lĩnh vực riêng. Chẳng hạn, kí hiệu toán học chính là một ngôn ngữ 
hình thức rất hữu dụng để biểu diễn mối quan hệ giữa những biến lượng
và con số. Trong hoá học, một loại ngôn ngữ hình thức khác được dùng
để biểu diễn cấu trúc hoá học của các phân tử. Và quan trọng nhất:

\begin{quote}
\textbf{Ngôn ngữ lập trình là những ngôn ngữ hình thức được thiết kế phục vụ
mục đích diễn tả quá trình tính toán.}
\end{quote}

Các ngôn ngữ hình thức thường có quy định rất chặt chẽ về cú pháp.
Chẳng hạn, $3 + 3 = 6$ là một biểu thức toán học đúng, nhưng
$3 + = 3 \mbox{\#} 6$ thì không.  $H_2O$ là một công thức hoá học
đúng về cú pháp, còn $_2Zz$ thì không.
% Nguyên bản là dấu $ chứ không phải dấu thăng. Tuy nhiên, để tiện dùng
% bộ sắp chữ TeXmaker tôi để là dấu thăng để syntax highlighting được đúng.

Các quy tắc cú pháp có hai biểu hiện, về các {\bf nguyên tố} và 
cấu trúc. Nguyên tố là các thành phần cơ sở của ngôn ngữ, chẳng hạn,
các từ, các con số, và các nguyên tố hoá học. Trong ví dụ nêu trên, $3 +
= 3 \mbox{\$} 6$ có lỗi sai vì \verb"$" không phải là một nguyên tố
hợp lệ trong toán học. Tương tự như vậy, $_2Zz$ không hợp lệ vì 
không có nguyên tố hoá học nào có kí hiệu là $Zz$.

\index{nguyên tố}
\index{cấu trúc}

Loại lỗi cú pháp thứ hai thuộc về dạng cấu trúc của một mệnh đề;
nghĩa là cách sắp xếp các nguyên tố. Mệnh đề  $3
+ = 3 \mbox{\#} 6$ không hợp lệ là vì mặc dù  $+$ và $=$ đều
là các nguyên tố đúng, nhưng chúng không thể đứng liền kề nhau.
Tương tự như vậy, trong một công thức hoá học thì chỉ số phải
được đặt sau tên nguyên tố chứ không phải đặt trước.

\begin{ex}
Hãy viết một câu có cấu trúc đúng nhưng có chứa những từ (nguyên tố)
không đúng. Viết một câu khác trong đó tất cả các từ (nguyên tố) đều đúng
nhưng cấu trúc lại không đúng.
\end{ex}

Mỗi khi đọc một câu trong ngôn ngữ tự nhiên, hoặc trong ngôn ngữ
hình thức, bạn cần hình dung được cấu trúc của câu đó là gì (mặc dù
với ngôn ngữ tự nhiên thì việc làm này được thực hiện một cách vô thức).
Quá trình này được gọi là \textbf{phân tích}.

\index{phân tích}

Chẳng hạn, khi nghe câu ``Đồng xu rơi'', bạn cần hiểu được ``đồng xu''
là chủ ngữ còn ``rơi'' là vị ngữ. Một khi đã phân tích được, bạn hiểu
được câu đó nói gì, tức là nắm được ý nghĩa của câu. Giải thiết rằng
bạn biết được nghĩa của từng từ riêng biệt (đồng xu, và rơi), bạn sẽ
hiểu được hàm ý chung của câu này.

Mặc dù ngôn ngữ hình thức và ngôn ngữ tự nhiên có nhiều đặc điểm chung
---nguyên tố, cấu trúc, cú pháp, và ngữ nghĩa---nhưng chúng có một
số khác biệt:

\index{tính rõ ràng}
\index{tính gọn gàng}
\index{tính phi văn phong}

\begin{description}

\item[tính chính xác:] Ngôn ngữ tự nhiên chứa đựng sự mập mờ
theo nghĩa con người muốn hiểu đúng phải có suy luận tuỳ từng ngữ cảnh.
và có thêm các thông tin khác để bổ sung. Các ngôn ngữ hình thức
được thiết kế gần như rõ ràng tuyệt đối, tức là mỗi mệnh để chỉ có
đúng một nghĩa, bất kể ngữ cảnh như thế nào.

\item[tính gọn gàng:] Để loại trừ sự mập mờ và tránh gây hiểu nhầm,
ngôn ngữ tự nhiên cần dùng đến nhiều nội dung bổ trợ làm dài thêm
nội dung. Trái lại, các ngôn ngữ hình thức có nội dung gọn gàng đến mức
tối thiểu.

\item[tính phi văn phong:] Các ngôn ngữ tự nhiên có chứa nhiều thành ngữ
và ẩn dụ. Khi ai đó nói ``Đồng xu rơi'',  có thể tại đó không có đồng xu nào và 
cũng chẳng có gì vừa rơi.\footnote{Thành ngữ tiếng Anh này nghĩa là ai đó
đã nhận ra điều gì đó sau một thoáng bối rối.}  Còn các ngôn ngữ hình thức luôn luôn
có nghĩa đúng theo những gì được viết ra.

\end{description}

Chúng ta dùng ngôn ngữ tự nhiên ngay từ thủa nhỏ, nên thường có một
thời gian khó khăn ban đầu khi làm quen với ngôn ngữ hình thức. Về phương
diện nào đó, sự khác biệt giữa ngôn ngữ hình thức và ngôn ngữ tự nhiên
cung như khác biệt giữa thơ ca và văn xuôi, dù hơn thế nữa.


\index{thơ ca}
\index{văn xuôi}

\begin{description}

\item[Thơ ca:] Các từ được dùng với cả chức năng âm điệu bên cạnh
chức năng ý nghĩa, và toàn bộ bài thơ/ca tạo ra hiệu quả cảm xúc.
Luôn mang tính không rõ ràng, thậm chí còn là chủ định của
tác giả.

\item[Văn xuôi:] Coi trọng ý nghĩa của câu chữ hơn, trong đó phải kể đến
vai trò của cấu trúc đối với việc diễn đạt ý nghĩa. Văn xuôi dễ phân tích ngữ
nghĩa hơn so với thơ ca nhưng vẫn còn yếu tố không rõ ràng.

\item[Chương trình:] Ý nghĩa của một chương trình máy tính là rõ ràng
và được diễn đạt hoàn toàn thông qua câu chữ, theo đó ta có thể hiểu được
trọn ven bằng cách phân tích các từ ngữ (nguyên tố) và cấu trúc.
\end{description}

Khi đọc chương trình (hoặc một ngôn ngữ hình thức nào khác) bạn nên làm
như sau. Trước hết, hãy nhớ rằng ngôn ngữ hình thức cô đọng hơn ngôn ngữ
tự nhiên, nên phải mất nhiều thời gian để đọc hơn. Mặt khác, cấu trúc cũng
rất quan trọng, do đó không nên chỉ đọc qua một lượt từ trên xuống dưới.
Bạn cần phải học cách phân tách ngôn ngữ trong trí óc, nhận diện các
nguyên tố và diễn giải cấu trúc. Cuối cùng, những chi tiết đóng vai trò quan
trọng. Các lỗi dù là nhỏ nhất trong cách viết các từ hoặc dấu câu trong 
ngôn ngữ hình thức sẽ có thể gây ra khác biệt lớn về ý nghĩa.

\section{Chương trình đầu tiên}
\label{hello}

\index{Chào thế giới}

Theo thông lệ, chương trình đầu tiên mà bạn viết theo một ngôn ngữ
lập trình mới có tên gọi là ``Hello, World!'' vì tất cả những gì nó
thực hiện chỉ là làm hiện ra dòng chữ ``Hello, World!'' Một chương trình
như vậy trong Python được viết như sau:

\beforeverb
\begin{verbatim}
print 'Hello, World!'
\end{verbatim}
\afterverb
%
Đây là ví dụ về một {\bf lệnh print}\footnote{Trong Python 3.0,
  {\tt print} là một hàm, không phải câu lệnh, và do đó cú pháp sẽ là {\tt
    print('Hello, World!')}. Không lâu nữa chúng ta sẽ làm quen với
các hàm!}, vốn chẳng in gì ra giấy. Nó chỉ hiển thị một giá trị trên màn
hình. Trong trường hợp này, kết quả là dòng chữ

\index{Python 3.0}

\beforeverb
\begin{verbatim}
Hello, World!
\end{verbatim}
\afterverb
%
Cặp dấu nháy đơn trong đoạn chương trình có nhiệm vụ đánh dấu các điểm
đầu và cuối của đoạn chữ cần hiển thị; chúng sẽ không xuất hiện trong
kết quả.

\index{dấu nháy đơn}
\index{print (lệnh)}
\index{lệnh!print}

Người ta có thể đánh giá chất lượng của một ngôn ngữ lập trình bằng
độ đơn giản của chương trình ``Hello, World!''. Theo tiêu chuẩn này,
Python xứng đáng đạt điểm cao nhất.

\section{Gỡ lỗi}
\index{gỡ lỗi}

Nếu có thể đọc cuốn sách này trước máy tính thì rất tốt vì bạn sẽ 
thử được tất cả các ví dụ trong quá trình đọc. Bạn có thể chạy phần lớn
các ví dụ ở chế độ tương tác, nhưng nếu viết mã lệnh trong một file 
văn lệnh thì sẽ dễ thực hiện các điều chỉnh về sau này.

Mỗi khi thử nghiệm một đặc tính mới cho chương trình, bạn nên phạm lỗi.
Chẳng hạn, trong chương trình ``Hello, world!'', điều gì sẽ xảy ra
nếu bạn bỏ bớt một trong hai dấu nháy? Và nếu bỏ cả hai dấu nháy? Nếu bạn
viết sai chữ {\tt print}?

\index{thông báo lỗi}

Kiểu thử nghiệm này sẽ giúp bạn nhớ những gì bạn đã đọc; nó cũng giúp cho
công việc gỡ lỗi, vì lúc đó bạn sẽ biết rằng thông báo lỗi ngụ ý gì. Do
đó tốt hơn là cố ý phạm lỗi ngay từ lúc này còn hơn là để sau này vô tình
mắc lỗi.

Đôi khi việc lập trình, và đặc biệt là gỡ lỗi, đem đến những cảm xúc mạnh.
Nếu bạn đang đánh vật với một lỗi rất khó, bạn có thể nổi xung, đầu hàng 
hoặc bối rối.

Đã có những chứng cứ cho thấy con người phản ứng tự nhiên lại với máy tính
như thể chúng là những người thực.\footnote{Xem Reeves and Nass, {\it The Media
    Equation: How People Treat Computers, Television, and New Media
    Like Real People and Places}.}.  Khi chúng hoạt động trôi chảy, ta 
coi chúng như người bạn; và khi chúng rất cứng đầu hoặc thô lỗ, chúng ta
phản ứng với chúng như thể với hạng người mang những tính đó.

\index{gỡ lỗi!phản ứng cảm xúc}
\index{cảm xúc, gỡ lỗi}

Chuẩn bị tiếp nhận những phản ứng này có thể giúp bạn biết cách
vượt qua chúng. Một cách làm là nghĩ về máy tính như một nhân
viên với các ưu điểm năng lực nhất định, như tốc độ và độ chính
xác, nhưng kèm theo những nhược điểm riêng, như thiếu sự đồng cảm
và thiếu khả năng nắm bắt bức tranh tổng thể.

Còn bạn có vai trò là một người quản lý tốt: hãy tìm cách tận
dụng ưu điểm và khắc phục những nhược điểm. Và tìm ra những cách
điều khiển cảm xúc khi giải quyết vấn đề, không để cho những phản
ứng của bản thân làm ảnh hưởng đến khả năng làm việc hiệu quả.

Học cách gỡ lỗi có thể dễ gây bực bội, nhưng đó lại là kỹ năng rất
quý báu và cần thiết cho nhiều hoạt động khác ngoài lập trình. Ở
cuối mỗi chương sách đều có một mục gỡ lỗi, như mục này, trong đó
tôi muốn chia sẻ những ý kiến bản thân về việc gỡ lỗi. Hi vọng nó
sẽ giúp bạn!


\section{Thuật ngữ}

\begin{description}

\item[giải quyết vấn đề:]  Quá trình thiết lập bài toán, tìm lời
giải, và biểu diễn lời giải.
\index{giải quyết vấn đề}

\item[ngôn ngữ bậc cao:]  Ngôn ngữ lập trình như Python được
thiết kế nhằm mục đích để con người dễ đọc và viết.
\index{ngôn ngữ bậc cao}

\item[ngôn ngữ bậc thấp:]  Ngôn ngữ lập trình được thiết kế
nhằm mục đích để máy tính dễ thực hiện; còn gọi là ``ngôn ngữ máy'' 
hoặc ``hợp ngữ.''
\index{ngôn ngữ bậc thấp}

\item[tính khả chuyển:]  Đặc tính của chương trình
mà có thể chạy trên nhiều loại máy tính khác nhau.
\index{tính khả chuyển}

\item[thông dịch:]  Thực hiện chương trình được viết bằng ngôn ngữ
bậc cao bằng cách dịch nó theo từng dòng một.
\index{thông dịch}

\item[biên dịch:]  Dịch một lượt toàn bộ chương trình viết bằng
ngôn ngữ bậc cao sang ngôn ngữ bậc thấp, để chuẩn bị thực hiện sau này.
\index{biên dịch}

\item[mã nguồn:]  Chương trình ở dạng ngôn ngữ bậc cao trước
khi được biên dịch.
\index{mã nguồn}

\item[mã đối tượng:]  Sản phẩm đầu ra của trình biên dịch sau khi
nó đã dịch chương trình.
\index{mã đối tượng}

\item[chương trình chạy:]  Tên khác đặt cho mã đối tượng đã
sẵn sàng được thực hiện.
\index{chương trình chạy}

\item[dấu nhắc:] Các kí tự được hiển thị bởi trình thông dịch nhằm
thể hiện rằng nó đã sẵn sàng nhận đầu vào từ phía người dùng.
\index{dấu nhắc}

\item[văn lệnh:] Chương trình được lưu trong file (thường chính
là chương trình sẽ được thông dịch).
\index{văn lệnh}

\item[chế độ tương tác:] Cách dùng trình thông dịch Python thông
qua việc gõ các câu lệnh và biểu thức vào chỗ dấu nhắc.
\index{chế độ tương tác}

\item[chế độ văn lệnh:] Cách dùng trình thông dịch Python để đọc
và thực hiện các câu lệnh có trong một văn lệnh.
\index{chế độ văn lệnh}

\item[chương trình:] Danh sách những chỉ dẫn thực hiện tính toán.
\index{chương trình}

\item[thuật toán:]  Quá trình tổng quát để giải một lớp các
bài toán.
\index{thuật toán}

\item[lỗi:]  Lỗi trong chương trình.
\index{lỗi}

\item[gỡ lỗi:]  Quá trình dò tìm và gỡ bỏ cả ba kiểu lỗi trong lập trình.
\index{gỡ lỗi}

\item[cú pháp:]  Cấu trúc của một chương trình.
\index{cú pháp}

\item[lỗi cú pháp:]  Lỗi trong chương trình mà làm cho quá trình
phân tách không thể thực hiện được (và hệ quả là không thể biên dịch được).
\index{lỗi cú pháp}

\item[biệt lệ:]  Lỗi được phát hiện khi chương trình đang chạy.
\index{biệt lệ}

\item[ngữ nghĩa:]  Ý nghĩa của chương trình.
\index{ngữ nghĩa}

\item[lỗi ngữ nghĩa:]   Lỗi có trong chương trình mà khiến cho
chương trình thực hiện công việc ngoài ý định của người viết.
\index{lỗi ngữ nghĩa}

\item[ngôn ngữ tự nhiên:]  Ngôn ngữ bất kì được con người dùng,
được trải qua sự tiến hóa tự nhiên.
\index{ngôn ngữ tự nhiên}

\item[ngôn ngữ hình thức:]  Ngôn ngữ bất kì được con người
thiết kế nhằm mục đích cụ thể, như việc biểu diễn các ý tưởng toán học
hoặc các chương trình máy tính; tất cả các ngôn ngữ lập trình đều là
ngôn ngữ hình thức.
\index{ngôn ngữ hình thức}

\item[nguyên tố:]  Một trong những thành phần cơ bản trong cấu trúc
cú pháp của một chương trình, tương đương với một từ trong ngôn ngữ
tự nhiên.
\index{nguyên tố}

\item[tách:]  Việc kiểm tra một chương trình và phân tích cấu
trúc cú pháp.
\index{phân tách}

\item[lệnh print:]  Chỉ thị để khiến trình thông dịch Python
hiển thị một giá trị lên màn hình.
\index{print (lệnh)}
\index{lệnh!print}


\end{description}


\section{Bài tập}

\begin{ex}
Dùng một trình duyệt web để truy cập trang web của Python
\url{python.org}. Trang này bao gồm thông tin về Python và
các kết nối đến những trang khác có liên quan đến Python; nó cũng
giúp bạn tìm kiếm trong tài liệu về  Python.

Chẳng hạn, nếu bạn nhập vào {\tt print} ở cửa sổ tìm kiếm thì
đường kết nối thứ nhất sẽ xuất hiện như là tài liệu hướng dẫn
câu lệnh {\tt print}. Đến đây, có thể bạn không hiểu những gì
trong đó viết, nhưng biết cách tìm ra nó là điều tốt nhất.

\index{tài liệu}
\index{python.org}
\end{ex}

\begin{ex}
Khởi động trình thông dịch Python và gõ vào {\tt help()} để
khởi động ứng dụng hỗ trợ phần mềm. Hoặc bạn có thể gõ
\verb"help('print')" để biết thông tin về câu lệnh {\tt print}.

Nếu như ví dụ này không thực hiện được, có thể bạn sẽ cần phải
cài đặt riêng bộ tài liệu về Python hoặc thiết lập một biến
môi trường; cụ thể điều này còn phụ thuộc vào hệ điều hành và
phiên bản Python mà bạn đang dùng.
\index{ứng dụng trợ giúp}
\end{ex}

\begin{ex}
Hãy khởi động trình thông dịch Python và dùng nó như một máy tính
tay. Cú pháp của Python về các phép tính cũng giống như 
các kí hiệu toán học thông dụng. Chẳng hạn các dấu 
{\tt +}, {\tt -}, và {\tt /} để chỉ các phép tính cộng, trừ,
và chia, như bạn trông đợi. Kí hiệu cho phép nhân là {\tt *}.

Nếu bạn chạy thi 10 km trong vòng 43 phút 30 giây thì thời gian trung
bình mà để bạn chạy được một dặm là bao nhiêu? Tốc độ trung bình của
bạn là bao nhiêu dặm mỗi giờ? (Gợi ý: một dặm bằng 1.61 km).

\index{máy tính tay}
\index{thi chạy}

\end{ex}




\chapter{Biến, biểu thức và câu lệnh}

\section{Giá trị và kiểu}
\index{giá trị}
\index{kiểu}
\index{chuỗi}

{\bf Giá trị} là một trong những cái cơ bản mà chương trình cần
dùng đến, chẳng hạn như một chữ cái hoặc một con số. Các giá trị
mà ta đã thấy đến giờ bao gồm {\tt 1}, {\tt 2}, và
\verb"'Hello, World!'".

Các giá trị này thuộc về hai {\bf kiểu} khác nhau:
{\tt 2} là một số nguyên, còn \verb"'Hello, World!'" là một 
{\bf chuỗi}, được gọi như vậy vì nó là một chuỗi các kí tự
ghép lại với nhau. Bạn (và trình thông dịch) có thể nhận ra
các chuỗi vì chúng được đặt trong cặp dấu nháy.

\index{dấu nháy}

Câu lệnh print cũng có tác dụng với các số nguyên.

\beforeverb
\begin{verbatim}
>>> print 4
4
\end{verbatim}
\afterverb
%
Nếu bạn không chắc rằng kiểu của một giá trị là gì, 
trình thông dịch có thể cho bạn biết.

\beforeverb
\begin{verbatim}
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
\afterverb
%
Thật không ngạc nhiên rằng chuỗi kí tự ({\em string}) thuộc về kiểu
{\tt str} và các số nguyên ({\em integer}) thuộc về kiểu {\tt int}.
Điều ít hiển nhiên là các số có phần thập phân thuộc về một kiểu có
tên là {\tt float}, vì những số này được biểu diễn dưới một dạng 
được gọi là {\bf dấu phẩy động} ({\em floating-point}).

\index{kiểu}
\index{kiểu!chuỗi}
\index{kiểu!số nguyên}
\index{kiểu!dấu phẩy động}

\beforeverb
\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
\afterverb
%
Thế còn các giá trị như \verb"'17'" và \verb"'3.2'"?
Trông chúng giống như số, nhưng chúng được đặt trong cặp dấu
nháy như các chuỗi.

\index{dấu nháy}

\beforeverb
\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
\afterverb
%
Vậy chúng là các chuỗi.

Khi bạn gõ vào những số nguyên lớn, có thể bạn muốn dùng những dấu
phẩy để nhóm từng lớp ba chữ số lại với nhau, như {\tt 1,000,000}. 
Đây không phải là một số nguyên hợp lệ trong Python, nhưng vẫn đúng
về mặt cú pháp:

\beforeverb
\begin{verbatim}
>>> print 1,000,000
1 0 0
\end{verbatim}
\afterverb
%
À, đó không phải là điều chúng ta mong muốn! Python dịch {\tt
  1,000,000} như một danh sách các số nguyên được phân cách bởi các
dấu phẩy, và khi in ra thì đặt dấu cách giữa các số này.

\index{lỗi!ngữ nghĩa}
\index{thông báo lỗi}

Đây là ví dụ đầu tiên mà chúng ta thấy một lỗi ngữ nghĩa: đoạn mã
chạy mà không có lỗi được thông báo, nhưng nó không thực hiện điều
``đúng''.


\section{Biến}
\index{biến}
\index{lệnh gán}

Một trong những tính năng mạnh nhất của một ngôn ngữ lập trình là
khả năng thao tác với các {\bf biến}. Biến là một tên gọi tham chiếu
đến một giá trị.

Một {\bf lệnh gán} tạo ra biến mới và đặt giá trị cho nó:

\beforeverb
\begin{verbatim}
>>> message = 'And now for something completely different'
>>> n = 17
>>> pi = 3.1415926535897931
\end{verbatim}
\afterverb
%
Ví dụ này có ba lệnh gán. Lệnh thứ nhất gán một chuỗi cho một
biến có tên là {\tt message}; lệnh thứ hai gán số nguyên {\tt 17}
cho {\tt n}; lệnh thứ ba gán giá trị (gần đúng) của $\pi$ cho {\tt pi}.

\index{sơ đồ trạng thái}
\index{sơ đồ!trạng thái}

Một cách chung để biểu diễn các biến trên giấy là viết ra tên kèm theo
một mũi tên chỉ đến giá trị của biến. Dạng hình vẽ này được gọi là 
{\bf sơ đồ trạng thái} vì nó cho thấy trạng thái của mỗi biến hiện tại
là như thế nào (hãy hình dung nó như trạng thái trí não của biến đó).
Sơ đồ dưới đây cho thấy kết quả của ví dụ trước:

\beforefig
\centerline{\includegraphics{figs/state2.eps}}
\afterfig

Để hiển thị giá trị của một biến, bạn có thể dùng lệnh print:

\beforeverb
\begin{verbatim}
>>> print n
17
>>> print pi
3.14159265359
\end{verbatim}
\afterverb
%
Kiểu của một biến là kiểu của giá trị mà biến đó tham chiếu đến.

\beforeverb
\begin{verbatim}
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}
\afterverb
%
\begin{ex}
\label{baitap21}
Nếu bạn gõ vào một số nguyên mà bắt đầu với chữ số 0, có thể
bạn sẽ nhận được một thông báo lỗi khó hiểu:

\beforeverb
\begin{verbatim}
>>> zipcode = 02492
                  ^
SyntaxError: invalid token
\end{verbatim}
\afterverb

Với các số khác có vẻ như mọi việc bình thường, nhưng kết quả
rất quái lạ:

\beforeverb
\begin{verbatim}
>>> zipcode = 02132
>>> print zipcode
1114
\end{verbatim}
\afterverb

Bạn có thể hình dung điều gì đang xảy ra không? Gợi ý:
hãy in các giá trị {\tt 01}, {\tt 010}, {\tt 0100} 
và {\tt 01000}.

\index{hệ bát phân}

\end{ex}



\section{Tên biến và từ khoá}
\index{từ khoá}

Thông thường các lập trình viên chọn tên biến có nghĩa---
tự nó nói lên rằng biến được dùng vào việc gì.

Tên biến có độ dài tuỳ ý. Chúng có thể gồm cả chữ cái và số,
nhưng bắt buộc phải bắt đầu bằng một chữ cái. Dùng các chữ
in cũng được, nhưng tốt nhất là bạn nên bắt đầu tên biến với
chữ thường (sau này bạn sẽ biết tại sao).

Dấu gạch dưới (\verb"_") có thể xuất hiện trong một tên.
Nó thường được dùng trong các tên gồm có nhiều từ, như
\verb"my_name" hoặc \verb"airspeed_of_unladen_swallow".

\index{dấu gạch dưới}

Nếu bạn đặt một tên biến không hợp lệ, sẽ có lỗi cú pháp:

\beforeverb
\begin{verbatim}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
{\tt 76trombones} không hợp lệ vì nó không bắt đầu bằng một chữ cái.
{\tt more@} không hợp lệ vì nó có chứa một kí tự không hợp lệ, {\tt
@}. Nhưng còn {\tt class} tại sao lại sai?

Hoá ra vì {\tt class} là một trong những {\bf từ khoá} của Python. 
Trình thông dịch sử dụng từ khoá để nhận ra cấu trúc của chương trình,
và chúng không thể được dùng để đặt tên biến.

\index{từ khoá}

Python có 31 từ khoá\footnote{Trong Python 3.0, {\tt exec} không còn
là một từ khoá, nhưng lại có thêm từ khoá {\tt nonlocal}.}:

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%
Bạn có thể ghi lại danh sách trên đây. Nếu trình thông dịch phàn nàn
về một tên biến mà bạn không biết tại sao, hãy tra xem nó có nằm trong
danh sách này không.


\section{Câu lệnh}

Câu lệnh là một đơn vị của mã lệnh mà trình thông dịch Python
có thể thực hiện được. Chúng ta đã gặp hai loại câu lệnh: print
và lệnh gán.

\index{câu lệnh}
\index{chế độ tương tác}
\index{chế độ văn lệnh}

Khi bạn gõ một câu lệnh ở trong chế độ tương tác, trình thông dịch
sẽ thực hiện nó và hiển thị kết quả, nếu có.

Một văn lệnh thường gồm một loạt các câu lệnh hợp thành. Nếu có
hơn một câu lệnh thì kết quả  của từng câu lệnh sẽ lần lượt được
xuất hiện khi câu lệnh đó được thực thi.

Chẳng hạn, đoạn văn lệnh

\beforeverb
\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
\afterverb
%
cho ta kết quả

\beforeverb
\begin{verbatim}
1
2
\end{verbatim}
\afterverb
%
Câu lệnh gán không tạo ra kết quả.


\section{Toán tử và toán hạng}
\index{toán tử số học}
\index{toán hạng}
\index{biểu thức}

{\bf Toán tử} là các kí hiệu đặc biệt để biểu diễn các
phép tính như cộng và nhân. Toán tử được áp dụng cho các
giá trị được gọi là {\bf toán hạng}.

Các toán tử {\tt +}, {\tt -}, {\tt *}, {\tt /} và {\tt **}
biểu thị phép cộng, trừ, nhân, chia, và luỹ thừa như trong
ví dụ sau:

\beforeverb
\begin{verbatim}
20+32   hour-1   hour*60+minute   minute/60   5**2   (5+9)*(15-7)
\end{verbatim}
\afterverb
%
Trong một số ngôn ngữ lập trình khác, \verb"^" được dùng để tính
luỹ thừa, nhưng với Python đó là một toán tử tính cho bit có tên là
XOR. Tôi sẽ không trình bày các toán tử để tính cho bit trong sách này,
nhưng bạn có thể đọc thêm về chúng ở trang \url{wiki.python.org/moin/BitwiseOperators}.

\index{toán tử tính cho bit}

%When a variable name appears in the place of an operand, it
%is replaced with its value before the operation is
%performed.

Toán tử chia có thể không thực hiện điều mà bạn mong đợi:

\beforeverb
\begin{verbatim}
>>> minute = 59
>>> minute/60
0
\end{verbatim}
\afterverb
%
Giá trị của {\tt minute} là 59, và trong đại số thông thường thì 59
chia cho 60 bằng 0.98333, chứ không phải 0. Lí do của sự khác biệt 
ở đây là Python đã thực hiện phép {\bf chia làm tròn xuống}\footnote{Trong Python 3.0, kết quả của phép chia này là một số có phần thập phân 
({\tt float}). Một toán tử mới {\tt //} thực hiện phép chia làm tròn.}.

\index{Python 3.0}
\index{chia làm tròn xuống}
\index{chia số thập phân}

Khi cả hai toán hạng đều là số nguyên, kết quả cũng sẽ là một 
số nguyên; phép chia làm tròn xuống cắt bỏ phần thập phân, vì vậy
trong ví dụ này kết quả được làm tròn xuống 0.

Nếu một trong hai toán hạng là một số có phần thập phân, Python sẽ
thực hiện phép chia thập phân, và kết quả là một số thập phân ({\tt float}):

\beforeverb
\begin{verbatim}
>>> minute/60.0
0.98333333333333328
\end{verbatim}
\afterverb


\section{Biểu thức}

{\bf Biểu thức} là một tổ hợp các giá trị, biến, và toán tử.
Một giá trị bản thân nó cũng được coi như là một biểu thức,
và một biến cũng vậy; vì thế tất cả những cái dưới đây đều là
các biểu thức hợp lệ 
(giả sử rằng biến {\tt x} đã được gán một giá trị):

\index{biểu thức}
\index{định lượng}

\beforeverb
\begin{verbatim}
17
x
x + 17
\end{verbatim}
\afterverb
%
Nếu bạn gõ một biểu thức ở trong chế độ tương tác, trình thông dịch
sẽ {\bf định lượng} nó và hiển thị kết quả:

\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%
Nhưng trong một văn lệnh, một biểu thức bản thân nó không có
tác dụng gì cả! Đây là một điểm dễ gây nhầm lẫn cho người mới
học.

\begin{ex}
Hãy gõ những câu lệnh dưới đây vào trình thông dịch Python để
xem chúng có tác dụng gì:

\beforeverb
\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
\afterverb
%
Bây giờ đưa chính các câu lệnh đó vào trong một văn lệnh và
chạy nó. Kết quả là gì? Sửa lại văn lệnh bằng cách thay mỗi
biểu thức bằng một câu lệnh print tương ứng và chạy lại.
\end{ex}


\section{Thứ tự thực hiện}
\index{thứ tự thực hiện}
\index{quy tắc ưu tiên}
\index{PEMDAS}

Khi trong biểu thức có nhiều hơn một toán tử, thứ tự định lượng
sẽ tuân theo {\bf quy tắc ưu tiên}. Với các toán tử toán học,
Python dựa vào quy ước chung trong môn toán. Chữ viết tắt
{\bf PEMDAS} là một cách nhớ quy tắc này:

\index{ngoặc đơn!ưu tiên cao nhất}

\begin{itemize}

\item Cặp ngoặc đơn ({\bf P}arentheses) có thứ tự ưu tiên cao nhất
và có thể được dùng để buộc việc lượng giá một biểu thức theo đúng
thứ tự mà bạn mong muốn. Vì các biểu thức trong cặp ngoặc đơn được
lượng giá trước tiên, {\tt 2 * (3-1)} bằng 4,
và {\tt (1+1)**(5-2)} bằng 8. Bạn cũng có thể dùng cặp ngoặc đơn
để biểu thức trở nên dễ đọc, như với {\tt (minute * 100) / 60}, ngay
cả khi không có nó thì kết quả cũng không đổi.

\item Phép luỹ thừa ({\bf E}xponentiation) có thứ tự ưu tiên kế tiếp,
vì vậy {\tt 2**1+1} bằng 3 chứ không phải 4, và {\tt 3*1**3} bằng 3
chứ không phải 27.

\item Các phép nhân ({\bf M}ultiplication) và chia ({\bf D}ivision)
có cùng độ ưu tiên, cao hơn các phép cộng ({\bf A}ddition) và trừ ({\bf S}ubtraction), hai phép sau cũng có cùng độ ưu tiên. Vì vậy {\tt 2*3-1} bằng 5
chứ không phải 4, và {\tt 6+4/2} bằng 8 chứ không phải 5.

\item Các toán tử có cùng độ ưu tiên được định lượng từ trái sang phải.
Vì vậy, trong biểu thức {\tt degrees / 2 * pi}, phép chia được thực hiện
trước và kết quả sẽ được nhân với {\tt pi}. Để chia cho $2 \pi$, bạn có thể
dùng cặp ngoặc đơn hoặc viết {\tt degrees / 2 / pi}.

\end{itemize}


\section{Các thao tác với chuỗi}
\index{chuỗi!thao tác}
\index{toán tử!chuỗi}

Nói chung, bạn không thể thực hiện các phép toán đối với chuỗi, ngay cả
khi chuỗi trông giống như những con số. Vì vậy các biểu thức sau đây
đều không hợp lệ:

\beforeverb
\begin{verbatim}
'2'-'1'    'eggs'/'easy'    'third'*'a charm'
\end{verbatim}
\afterverb
%
Toán tử {\tt +} có tác dụng với chuỗi, nhưng nó có thể
sẽ không hoạt động theo cách bạn mong đợi: nó có nhiệm vụ
{\bf nối}, nghĩa là ghép nối tiếp các chuỗi lại với nhau.
Chẳng hạn:

\index{concatenation}

\beforeverb
\begin{verbatim}
first = 'throat'
second = 'warbler'
print first + second
\end{verbatim}
\afterverb
%
Kết quả của chương trình trên là {\tt throatwarbler}.

Toán tử {\tt *} cũng có tác dụng đối với chuỗi; nó có nhiệm
vụ lặp lại. Chẳng hạn, \verb"'Spam'*3" là \verb"'SpamSpamSpam'".
Nếu một trong các toán hạng là chuỗi, toán hạng còn lại
phải là một số nguyên.

Công dụng của {\tt +} và {\tt *} cũng có nghĩa tương tự
như với phép cộng và phép nhân. Giống như việc {\tt 4*3}
tương đương với {\tt 4+4+4}, chúng ta trông đợi
 \verb"'Spam'*3" tương đương \verb"'Spam'+'Spam'+'Spam'",
và thật vậy. Mặt khác, có một sự khác biệt đáng kể giữa
kết nối và lặp chuỗi so với các phép cộng và nhân số nguyên.
Bạn có thể nghĩ ra một thuộc tính của phép cộng mà phép nối
chuỗi không có không?

\index{tính giao hoán}


\section{Chú thích}
\index{chú thích}

Khi chương trình trở nên lớn và phức tạp hơn, chúng cũng đồng thời khó đọc
hơn. Các ngôn ngữ hình thức rất cô đặc, và nhìn vào một đoạn mã lệnh
ta thường khó hình dung ra nó để làm gì, hoặc tại sao.

Vì lí do này, ta nên thêm các ghi chú vào chương trình để giải thích
rằng chương trình làm gì bằng ngôn ngữ tự nhiên. Các ghi chú này được
gọi là {\bf chú thích}, và đều bắt đầu bằng kí hiệu \verb"#":

\beforeverb
\begin{verbatim}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
\end{verbatim}
\afterverb
%
Trong trường hợp này, chú thích xuất hiện riêng trên một dòng. Bạn cũng
có thể đặt chú thích ở cuối một dòng:

\beforeverb
\begin{verbatim}
percentage = (minute * 100) / 60     # percentage of an hour
\end{verbatim}
\afterverb
%
Mọi thứ từ dấu {\tt \#} về cuối dòng đều được bỏ qua---nó không làm
ảnh hưởng đến tác dụng của chương trình.

Các chú thích rất cần thiết khi chúng đưa thông tin về những tính năng
không dễ thấy của đoạn mã lệnh. Thường ta có thể coi rằng người đọc
đều hình dung được mã lệnh làm {\em làm gì}; và tốt hơn là hãy dùng 
chú thích vào việc giải thích {\em tại sao}.

Trong đoạn mã lệnh sau, chú thích là thừa và vô dụng:

\beforeverb
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
\afterverb
%
Chú thích sau chứa thông tin hữu dụng hơn mà mã lệnh không có:

\beforeverb
\begin{verbatim}
v = 5     # velocity in meters/second. 
\end{verbatim}
\afterverb
%
Việc đặt tên biến hợp lý có thể làm giảm nhu cầu dùng chú thích,
nhưng những tên biến dài có thể làm các biểu thức khó đọc, vì vậy
nó luôn có sự được--mất giữa hai mặt.

\section{Gỡ lỗi}
\index{gỡ lỗi}

Cho đến giờ lỗi cú pháp mà bạn thường gặp nhất có lẽ là tên biến
không hợp lệ, như {\tt class} và {\tt yield}, vốn trùng với các
từ khoá, hoặc \verb"odd~job" và \verb"US$", vốn có chứa các kí tự
không hợp lệ.

\index{lỗi cú pháp}

Nếu bạn đặt một dấu cách về phía trước một tên biến, Python sẽ 
nghĩ rằng đó là hai toán hạng mà không kèm theo toán tử nào:

\beforeverb
\begin{verbatim}
>>> bad name = 5
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
Với các lỗi cú pháp, dòng chữ thông báo lỗi không giúp được gì nhiều.
Những thông báo lỗi thường gặp nhất là {\tt SyntaxError: invalid syntax}
(cú pháp không hợp lệ) và {\tt SyntaxError: invalid token} (nguyên tố
không hợp lệ), cả hai đều không mang thông tin đáng kể.

\index{thông báo lỗi}
\index{sử dụng trước khai báo}
\index{biệt lệ}
\index{lỗi khi chạy}

Loại lỗi khi chạy chương trình mà có lẽ bạn thường gặp nhất là
``use before def;'' nghĩa là bạn đã thử dùng một biến trước khi
gán cho nó một giá trị. Điều này có thể xảy ra nếu bạn viết nhầm
tên biến:

\beforeverb
\begin{verbatim}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
\end{verbatim}
\afterverb
%
Các tên biến đều phân biệt chữ in và chữ thường, vì vậy, {\tt LaTeX}
khác với {\tt latex}.

\index{phân biệt chữ in--thường, tên biến}
\index{lỗi ngữ nghĩa}

Cho đến giờ, nguyên do thường gặp nhất gây ra lỗi ngữ nghĩa là
thứ tự thực hiện phép tính. Chẳng hạn, để định lượng $\frac{1}{2 \pi}$,
có thể bạn đã toan viết

\beforeverb
\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
\afterverb
%
Nhưng phép chia lại được thực hiện trước, vì vậy bạn sẽ được $\pi / 2$,
vốn không giống kết quả đúng! Vì Python không có cách nào đoán biết ý
của bạn khi viết chương trình nên trong trường hợp này bạn không thấy
có thông báo lỗi; bạn chỉ thu được đáp số sai.

\index{thứ tự tính toán}


\section{Thuật ngữ}

\begin{description}

\item[giá trị:]  Một trong những đơn vị cơ bản của dữ liệu, cũng
như số hoặc chuỗi, mà chương trình thao tác với.
\index{giá trị}

\item[kiểu:] Loại riêng của các giá trị. Những kiểu mà ta đã
gặp bao gồm kiểu số nguyên ({\tt int}), số có phần thập phân ({\tt
float}), và chuỗi ({\tt str}).
\index{kiểu}

\item[số nguyên:] Kiểu dùng để biểu diễn loại số tương ứng.
\index{số nguyên}

\item[số có phần thập phân:] Kiểu dùng để biểu diễn loại số tương ứng.
\index{floating-point}

\item[chuỗi:] Kiểu dùng để biểu diễn một danh sách các kí tự.
\index{chuỗi}

\item[biến:]  Tên được tham chiếu đến một giá trị.
\index{biến}

\item[câu lệnh:]  Đoạn mã biểu diễn một lệnh hoặc một hành động.
Cho đến giờ, các câu lệnh mà ta đã gặp gồm có lệnh gán và lệnh print.
\index{câu lệnh}

\item[lệnh gán:]  Lệnh để gán một giá trị cho một biến.
\index{lệnh gán}

\item[sơ đồ trạng thái:]  Đồ thị biểu diễn một tập hợp các biến và các
giá trị mà chúng tham chiếu tới.
\index{sơ đồ trạng thái}

\item[từ khoá:]  Từ dành riêng cho trình biên dịch để phân tách
một chương trình; bạn không thể dùng những từ khoá như {\tt if}, {\tt  def}, và {\tt while} để đặt tên biến.
\index{từ khoá}

\item[toán tử:]  Kí hiệu đặc biệt để biểu diễn một phép tính đơn nhất
như cộng, nhân, hoặc nối chuỗi.
\index{toán tử}

\item[toán hạng:]  Một trong những giá trị mà toán tử thực hiện với.
\index{toán hạng}

\item[phép chia làm tròn xuống:]  Phép toán chia hai số và cắt bỏ phần
thập phân.
\index{phép chia làm tròn xuống:}

\item[biểu thức:]  Tập hợp các biến, toán tử, và giá trị nhằm biểu
diễn một giá trị kết quả duy nhất.
\index{biểu thức}

\item[định lượng:]  Giản hoá một biểu thức bằng cách thực hiện các
phép tính nhằm thu được một giá trị duy nhất.
\index{định lượng}

\item[quy tắc ưu tiên:]  Tập hợp các quy tắc chi phối thứ tự mà những
biểu thức bao gồm nhiều toán tử và toán hạng được định lượng.
\index{quy tắc ưu tiên}
\index{thứ tự ưu tiên}

\item[nối:]  Ghép nối tiếp hai toán hạng.
\index{nối}

\item[chú thích:]  Thông tin trong một chương trình; thông tin này
có ích đối với các lập trình viên khác (hoặc người khác đọc mã nguồn)
nhưng không làm ảnh hưởng đến việc thực hiện chương trình.
\index{chú thích}

\end{description}


\section{Bài tập}

\begin{ex}
Giả sử ta thực hiện những câu lệnh gán dưới đây:

\begin{verbatim}
width = 17
height = 12.0
delimiter = '.'
\end{verbatim}

Với mỗi biểu thức sau, hãy cho biết giá trị của biểu thức
cùng với kiểu của giá trị đó.

\begin{enumerate}

\item {\tt width/2}

\item {\tt width/2.0}

\item {\tt height/3}

\item {\tt 1 + 2 * 5}

\item {\tt delimiter * 5}

\end{enumerate}

Dùng trình thông dịch Python để kiểm tra kết quả.
\end{ex}

\begin{ex}
Tập luyện cách dùng trình thông dịch Python thay cho máy tính tay:
\index{máy tính tay}

\begin{enumerate}

\item Thể tích của một hình cầu có bán kính $r$ là $\frac{4}{3} \pi r^3$.
  Thể tích của một hình cầu có bán kính bằng 5 là bao nhiêu? Gợi ý: 392.6
  là đáp số sai!

\item Coi rằng giá bìa của một cuốn sách là \$24.95, nhưng các hiệu sách
  được mua giảm giá 40\%. Tiền vận chuyển là \$3 với cuốn sách đầu và 75 xu
  với mỗi cuốn sách thêm. Tổng số tiền bán sỉ cho 60 bản sách là bao nhiêu?

\item Nếu tô rời nhà lúc 6:52 sáng và chạy chậm 1 dặm (mỗi dặm hết 8:15),
  sau đó chạy mức trung bình 3 dặm (mỗi dặm hết 7:12) và tiếp tục chạy 
  chậm 1 dặm, thì lúc mấy giờ tôi sẽ về đến nhà để ăn sáng?
\index{chạy}

\end{enumerate}
\end{ex}



\chapter{Hàm}
\label{funcchap}

\section{Việc gọi các hàm}
\label{functionchap}
\index{gọi hàm}

Trong lập trình, một {\bf hàm} là một nhóm được đặt tên gồm các câu lệnh 
nhằm thực hiện một nhiệm vụ tính toán cụ thể. Khi định nghĩa hàm,
bạn chỉ định tên của nó và tiếp theo là loạt các câu lệnh. Sau này,
bạn có thể ``gọi'' hàm theo tên của nó.

Ta đã gặp một ví dụ của việc {\bf gọi hàm}:

\beforeverb
\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
\afterverb
%
Tên của hàm này là {\tt type}.  Biểu thức ở trong cặp ngoặc đơn
được gọi là {\bf đối số} của hàm. Kết quả của hàm này là kiểu
của đối số.

\index{cặp ngoặc đơn!chứa đối số}

Người ta thường nói một hàm ``lấy'' một đối số và ``trả về''
một giá trị. Giá trị này được gọi là {\bf giá trị trả về}.

\index{đối số}
\index{giá trị trả về}


\section{Các hàm chuyển đổi kiểu}
\index{chuyển đổi!kiểu}

% from Elkner:
% comment on whether these things are _really_ functions?
% use max as an example of a built-in?

% my reply:
% they are on the list of ``built-in functions'' so I am
% willing to call them functions.

Python cung cấp các hàm dựng sẵn giúp chuyển đổi một giá trị từ 
kiểu này sang kiểu khác. Hàm {\tt int} lấy bất kì một giá trị nào
và chuyển nó thành một số nguyên nếu có thể, còn nếu không được
thì thông báo lỗi:

\index{hàm!int}

\beforeverb
\begin{verbatim}
>>> int('32')
32
>>> int('Hello')
ValueError: invalid literal for int(): Hello
\end{verbatim}
\afterverb
%
{\tt int} có thể chuyển các giá trị số có phần thập phân
sang số nguyên, nhưng nó không làm tròn mà chỉ cắt bỏ
phần thập phân:

\beforeverb
\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
\afterverb
%
{\tt float} chuyển số nguyên và chuỗi sang số có phần
thập phân:

\index{hàm!float}

\beforeverb
\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
\afterverb
%
Cuối cùng, {\tt str} chuyển đối số của nó sang một chuỗi:

\index{hàm!str}

\beforeverb
\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
\afterverb
%



\section{Các hàm toán học}
\index{hàm toán học}

Python có một module (mô-đun) toán cung cấp phần lớn các hàm toán học
thông dụng. Một {\bf module} là một file 
trong đó có tập hợp các hàm liên quan với nhau.

\index{module}
\index{đối tượng module}

Để sử dụng được module, ta cần phải nhập nó bằng lệnh import:

\beforeverb
\begin{verbatim}
>>> import math
\end{verbatim}
\afterverb
%
Câu lệnh này tạo ra một {\bf đối tượng module} có tên là math.
Nếu bạn in đối tượng module này, bạn sẽ nhận được thông tin về nó:

\beforeverb
\begin{verbatim}
>>> print math
<module 'math' from '/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
\afterverb
%
Đối tượng module chứa các hàm và biến được định nghĩa trong module.
Để truy cập một trong các hàm đó, bạn phải chỉ định tên của module và
tên của hàm, cách nhau bởi một dấu chấm. Cách này được gọi là
{\bf kí hiệu dấu chấm}.

\index{kí hiệu dấu chấm}

\beforeverb
\begin{verbatim}
>>> ratio = signal_power / noise_power
>>> decibels = 10 * math.log10(ratio)

>>> radians = 0.7
>>> height = math.sin(radians)
\end{verbatim}
\afterverb
%
Ví dụ thứ nhất thực hiện tính lô-ga cơ số 10 của tỉ lệ giữa
tín hiệu và nhiễu. module math cũng cung cấp một hàm có tên
là {\tt log} có nhiệm vụ tính lô-ga cơ số {\tt e}. 

\index{hàm!log}
\index{hàm!sin}
\index{radian}
\index{hàm!lượng giác}

Ví dụ thứ hai tìm sin của {\tt radians}. Ở đây tên của biến số
gợi ý rằng {\tt sin} và các hàm lượng giác khác ({\tt cos}, 
{\tt tan}, v.v.) nhận đối số có đơn vị radian. Để đổi từ độ
sang radian, hãy chai cho 360 và nhân với $2\pi$:

\beforeverb
\begin{verbatim}
>>> degrees = 45
>>> radians = degrees / 360.0 * 2 * math.pi
>>> math.sin(radians)
0.707106781187
\end{verbatim}
\afterverb
%
Biểu thức {\tt math.pi} lấy biến {\tt pi} từ module math.
Giá trị của biến này xấp xỉ với số $\pi$, với độ chính xác
khoảng 15 chữ số.

\index{pi}

Nếu bạn nắm vững lượng giác, bạn có thể kiểm tra lại kết quả
trước bằng cách so sánh nó với căn bậc hai của hai chia đôi:

\index{hàm!sqrt (căn bậc hai)}

\beforeverb
\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
\afterverb
%

\section{Sự kết hợp}
\index{kết hợp}

Cho đến giờ, chúng ta mới xét đến các thành phần tạo nên chương trình
---biến, biểu thức, và câu lệnh---một cách riêng lẻ, mà chưa nói đến
việc kết hợp chúng như thế nào.

Một trong những đặc điểm hữu ích của các ngôn ngữ lập trình là chúng
cho lấy những thành phần nhỏ và {\bf kết hợp} chúng lại. Chẳng hạn,
đối số của một hàm có thể là bất cứ biểu thức nào, bao gồm cả các 
toán tử đại số:

\beforeverb
\begin{verbatim}
x = math.sin(degrees / 360.0 * 2 * math.pi)
\end{verbatim}
\afterverb
%
Và thậm chí cả các hàm được gọi:

\beforeverb
\begin{verbatim}
x = math.exp(math.log(x+1))
\end{verbatim}
\afterverb
%
Hầu như bất kì chỗ nào bạn đặt được một giá trị, bạn cũng sẽ thay
được vào đó một biểu thức, chỉ với một ngoại lệ: phía bên trái của
một câu lệnh gán phải là một tên biến. Tất cả biểu thức nếu đặt ở
bên phía trái đó sẽ phạm lỗi cú pháp\footnote{Sau này chúng ta
sẽ xét thêm những ngoại lệ của quy tắc này.}.

\beforeverb
\begin{verbatim}
>>> minutes = hours * 60                 # đúng
>>> hours * 60 = minutes                 # sai!
SyntaxError: can't assign to operator
\end{verbatim}
\afterverb
%
\index{SyntaxError (lỗi cú pháp)}
\index{biệt lệ!SyntaxError}


\section{Thêm vào các hàm mới}

Đến bây giờ, chúng ta mới chỉ dùng những hàm có sẵn trong Python,
song thật ra có thể tạo ra những hàm mới.
Một {\bf định nghĩa hàm} bao gồm việc chỉ định tên của hàm mới và
danh sách các câu lệnh cần được thực hiện khi hàm được gọi.

\index{hàm}
\index{định nghĩa hàm}

Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "I'm a lumberjack, and I'm okay."
    print "I sleep all night and I work all day."
\end{verbatim}
\afterverb
%
{\tt def} là một từ khoá để khẳng định rằng đây là một định nghĩa làm.
Tên của hàm là \verb"print_lyrics". Quy tắc đặt tên hàm cũng như đặt
tên biến: chữ cái, số và dấu nối là hợp lệ nhưng kí tự đầu tiên không
thể là số. Bạn không thể đặt tên hàm giống như một từ khoá, và cũng nên
tránh đặt tên hàm và tên biến trùng nhau.

\index{từ khoá!def}
\index{def (từ khoá)}
\index{đối số}

Tiếp theo tên hàm là cặp ngoặc đơn bên trong không có gì, điều đó
có nghĩa là hàm này không lấy đối số nào.

\index{cặp ngoặc đơn!trống}
\index{đoạn đầu}
\index{phần thân}
\index{thụt đầu dòng}
\index{dấu hai chấm}

Dòng đầu tiên của định nghĩa hàm được gọi là {\bf đoạn đầu};
phần còn lại là {\bf phần thân}. Phần đầu phải được kết thúc bởi dấu
hai chấm và phần thân phải được viết thụt đầu dòng. Theo quy ước,
khoảng cách thụt vào luôn là bốn dấu cách (xem Mục~\ref{editor}).
Phần thân có thể chứa bao nhiêu câu lệnh cũng được.

Các chuỗi trong câu lệnh print được viết trong cặp dấu nháy kép.
Cặp dấu nháy đơn và nháy kép có tác dụng như nhau; người ta thường
dùng cặp nháy đơn trừ những trường hợp như sau khi có một dấu
nháy đơn xuất hiện trong chuỗi.

\index{dấu ba chấm}

Nếu bạn gõ định nghĩa hàm vào ở chế độ tương tác, trình thông dịch
sẽ in ra các dấu ba chấm ({\em ...}) nhằm cho bạn biết rằng việc
định nghĩa hàm chưa hoàn thành:

\beforeverb
\begin{verbatim}
>>> def print_lyrics():
...     print "I'm a lumberjack, and I'm okay."
...     print "I sleep all night and I work all day."
...
\end{verbatim}
\afterverb
%
Để kết thúc hàm, bạn phải gõ thêm một dòng trống (điều này không
cần thiết trong một văn lệnh).

Việc định nghĩa hàm sẽ tạo ra một biến có cùng tên.

\beforeverb
\begin{verbatim}
>>> print print_lyrics
<function print_lyrics at 0xb7e99e9c>
>>> print type(print_lyrics)
<type 'function'>
\end{verbatim}
\afterverb
%
Giá trị của \verb"print_lyrics" là một {\bf đối tượng hàm}; nó có
kiểu \verb"'function'".

\index{đối tượng hàm}

Cú pháp của lời gọi hàm mới cũng giống như với các hàm
dựng sẵn:

\beforeverb
\begin{verbatim}
>>> print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb
%
Một khi bạn đã định nghĩa hàm, bạn có thể dùng nó trong một hàm
khác. Chẳng hạn, để lặp lại điệp khúc vừa rồi, ta có thể viết một
hàm có tên là \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
def repeat_lyrics():
    print_lyrics()
    print_lyrics()
\end{verbatim}
\afterverb
%
Và sau đó gọi \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
>>> repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb
%
Song đó không phải là cách viết một bài hát theo đúng nghĩa.


\section{Định nghĩa và sử dụng}
\index{định nghĩa hàm}

Lấy lại những đoạn câu lệnh từ mục trước, ta được toàn bộ chương
trình sau:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "I'm a lumberjack, and I'm okay."
    print "I sleep all night and I work all day."

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
\end{verbatim}
\afterverb
%
Chương trình này bao gồm hai định nghĩa hàm: \verb"print_lyrics" và
\verb"repeat_lyrics".  Các định nghĩa hàm được thực hiện cũng giống
như với các câu lệnh khác, nhưng tác dụng của chúng là tạo ra những
đối tượng hàm. Các câu lệnh bên trong hàm không được thực hiện cho
đến tận khi hàm được gọi, hơn nữa định nghĩa hàm cũng không tạo ra
kết quả.

\index{sử dụng trước khi định nghĩa}

Bạn có thể nghĩ rằng cần phải tạo ra một hàm trước khi có thể thực 
hiện nó, và quả đúng như vậy. Nói cách khác, định nghĩa hàm phải 
được thực hiện trước lần gọi hàm đầu tiên.

\begin{ex}
Chuyển dòng lệnh cuối cùng của chương trình vừa rồi lên trên cùng, để
cho lời gọi hàm xuất hiện trước định nghĩa hàm. Chạy chương trình
để xem bạn nhận được thông báo lỗi gì.
\end{ex}

\begin{ex}
Chuyển lời gọi hàm trở lại cuối cùng và chuyển định nghĩa hàm \verb"print_lyrics" xuống dưới định nghĩa hàm
\verb"repeat_lyrics". Lần này khi chạy chương trình, điều gì sẽ
xảy ra?
\end{ex}


\section{Luồng thực hiện chương trình}
\index{luồng thực hiện}

Để đảm bảo chắc chắn rằng một hàm đã được định nghĩa trước lần sử
dụng đầu tiên, bạn phải biết thứ tự thực hiện các câu lệnh, còn gọi
là {\bf luồng thực hiện} chương trình.

Việc thực hiện luôn được bắt đầu với câu lệnh thứ nhất của chương
trình. Các câu lệnh được thực hiện lần lượt từ trên xuống.

Các định nghĩa hàm không làm thay đổi luồng thực hiện chương trình,
nhưng cần nhớ rằng các câu lệnh bên trong của hàm không được thực
hiện cho đến tận lúc hàm được gọi.

Mỗi lần gọi hàm là một lần rẽ ngoặt luồng thực hiện. Thay vì chuyển
sang câu lệnh kế tiếp, luồng sẽ nhảy tới phần thân của hàm, thực hiện
tất cả những câu lệnh ở trong đó, rồi trở lại tiếp tục thực hiện từ
điểm mà nó vừa rời đi.

Điều này nghe có vẻ đơn giản, nhưng sẽ khác đi nếu bạn nhận thấy rằng
một hàm có thể gọi hàm khác. Khi ở trong phần thân của một hàm, chương
trình có thể phải thực hiện những câu lệnh ở trong phần thân của một
hàm khác. Nhưng khi đang thực hiện hàm mới đó, chương trình còn phải
thực hiện một hàm khác nữa!

May mắn là Python rất giỏi theo dõi vị trí thực hiện của chương trình,
vì vậy mỗi khi một hàm được thực hiện xong, chương trình sẽ trở về
chỗ mà nó đã rời đi từ hàm gọi ban đầu. Khi trở về cuối chương
trình, việc thực hiện kết thúc.

Vậy ý nghĩa của câu chuyện này là gì? Khi đọc một chương trình,
bạn không nhất thiết phải đọc từ trên xuống dưới. Đôi khi việc
dò theo luồng thực hiện của chương trình sẽ có lý hơn.


\section{Tham số và đối số}
\label{tham số}
\index{đối số}
\index{hàm!tham số}
\index{hàm!đối số}

Một số các hàm dựng sẵn mà ta đã gặp có yêu cầu đối số. Chẳng hạn,
khi gọi hàm {\tt math.sin} bạn cần nhập vào một đối số. Một số
hàm còn lấy hơn một đối số: {\tt math.pow} lấy hai đối số là
cơ số và số mũ.

Bên trong hàm, các đối số được gán cho các biến được gọi là
{\bf tham số}. Sau đây là ví dụ về một hàm do người dùng định nghĩa;
hàm này lấy một đối số:

\index{cặp ngoặc đơn!chứa đối số}

\beforeverb
\begin{verbatim}
def print_twice(bruce):
    print bruce
    print bruce
\end{verbatim}
\afterverb
%
Hàm này gán một đối số cho một tham số có tên là
{\tt bruce}. Khi hàm được gọi, nó in ra giá trị
của tham số hai lần (bất kể tham số là gì).

Hàm này hoạt động được với bất kì giá trị nào có thể
in được.

\beforeverb
\begin{verbatim}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> print_twice(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
\afterverb
%
Quy tắc áp dụng cho các hàm dựng sẵn cũng có thể áp dụng được cho các
hàm người dùng tạo ra, vì vậy ta có thể dùng bất kì loại biểu thức nào
làm đối số cho \verb"print_twice":

\index{kết hợp}

\beforeverb
\begin{verbatim}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
\afterverb
%
Đối số được ước lượng trước khi hàm số được gọi, vì vậy trong
các ví dụ, các biểu thức \verb"'Spam '*4" và
{\tt math.cos(math.pi)} đều chỉ được ước lượng một lần.

\index{đối số}

Bạn cũng có thể dùng một biến cho một đối số:

\beforeverb
\begin{verbatim}
>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
\end{verbatim}
\afterverb
%
Tên của biến được đưa vào như đối số ({\tt michael}) không có
liên quan gì đến tân của tham số ({\tt bruce}). Giá trị nào được
gọi về (ở đoạn chương trình gọi) cũng không quan trọng; ở đây
trong \verb"print_twice", chúng ta đều gọi mọi người với tên {\tt bruce}.


\section{Các biến và tham số đều có tính địa phương}
\index{biến!địa phương}

Khi tạo ra một biến ở trong hàm, nó mang tính {\bf địa phương},
theo nghĩa rằng nó chỉ tồn tại bên trong hàm số. Chẳng hạn:

\index{cặp ngoặc đơn!chứa đối số}

\beforeverb
\begin{verbatim}
def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
\end{verbatim}
\afterverb
%
Hàm này nhận hai đối số, nối chúng lại, và sau đó in ra kết quả
hai lần. Sau đây là một ví dụ sử dụng hàm:

\index{nối}

\beforeverb
\begin{verbatim}
>>> line1 = 'Bing tiddle '
>>> line2 = 'tiddle bang.'
>>> cat_twice(line1, line2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
\end{verbatim}
\afterverb
%
Khi \verb"cat_twice" kết thúc, biến {\tt cat} bị huỷ bỏ.
Nếu cố gắng in nó, ta sẽ nhận được một biệt lệ:

\index{NameError}
\index{biệt lệ!NameError}

\beforeverb
\begin{verbatim}
>>> print cat
NameError: name 'cat' is not defined
\end{verbatim}
\afterverb
%
Các tham số cũng có tính địa phương.
Chẳng hạn, bên ngoài \verb"print_twice", không có thứ
gì được gọi là {\tt bruce} cả.

\index{tham số}


\section{Biểu đồ ngăn xếp}
% \label{biểu đồ ngăn xếp} 
\index{khung chứa hàm}
\index{khung}

Để theo dõi xem những biến nào được sử dụng ở đâu, đôi khi sẽ tiện lợi
nếu ta vẽ một {\bf biểu đồ ngăn xếp}. Cũng như biểu đồ trạng thái, 
biểu đồ ngăn xếp cho thấy giá trị của từng biến, đồng thời cho thấy
hàm mà mỗi biến thuộc về.

\index{biểu đồ ngăn xếp}

Mỗi hàm đều được biểu diễn bởi một {\bf khung}. Khung là một hình
chữ nhật, có tên của hàm số ghi bên cạnh, cùng với các tham số và biến
số của hàm được ghi trong đó. Biểu đồ ngăn xếp cho ví dụ trước có dạng
như sau:

\beforefig
\centerline{\includegraphics{figs/stack.eps}}
\afterfig

Các khung được bố trí trong một ngăn xếp cùng với chỉ định hàm 
nào gọi những hàm nào, và cứ như vậy. Ở ví dụ này, \verb"print_twice"
được gọi bởi \verb"cat_twice", và \verb"cat_twice" được gọi bởi
\verb"__main__", vốn là một tên đặc biệt dành cho khung cấp cao nhất.
Khi bạn tạo ra một biến không nằm trong bất cứ hàm nào, thì
nó sẽ nằm trong \verb"__main__".

Mỗi tham số tham chiếu đến giá trị tương ứng với đối số của nó.
Do vậy, {\tt part1} có cùng giá trị với {\tt line1}, 
{\tt part2} có cùng giá trị với {\tt line2}, và
{\tt bruce} có cùng giá trị với {\tt cat}.

Nếu có một lỗi xảy ra trong quá trình gọi hàm, Python sẽ in ra
tên của hàm, cùng với tên của hàm số gọi hàm trước đó, và cứ 
như vậy cho đến khi trở về  \verb"__main__".

Chẳng hạn, nếu bạn cố gắng truy cập {\tt cat} từ bên trong
\verb"print_twice", bạn sẽ nhận được một thông báo lỗi {\tt NameError}:

\beforeverb
\begin{verbatim}
Traceback (innermost last):
  File "test.py", line 13, in __main__
    cat_twice(line1, line2)
  File "test.py", line 5, in cat_twice
    print_twice(cat)
  File "test.py", line 9, in print_twice
    print cat
NameError: name 'cat' is not defined
\end{verbatim}
\afterverb
%
Danh sách các hàm như vậy có tên là {\bf dò ngược}. Nó cho bạn biết
file chương trình nào có chứa lỗi, và dòng lệnh nào cũng như những
hàm nào được thực hiện lúc bấy giờ. Nó cũng cho biết dòng lệnh gây
ra lỗi.

\index{dò ngược}

Thứ tự của các hàm trong dò ngược cũng giống như thứ tự của các
khung trong sơ đồ ngăn xếp. Hàm số đang được chạy có vị trí 
dưới cùng.


\section{Các hàm có và không trả lại kết quả}

\index{hàm trả lại kết quả}
\index{hàm không kết quả}

Một số hàm mà chúng ta dùng, như các hàm toán học, đều cho ra kết quả;
ta gọi nôm na là {\bf hàm trả lại kết quả}. Các hàm khác, như  \verb"print_twice", thực hiện một hành động, nhưng không trả lại
kết quả nào. Chúng được gọi là {\bf hàm không kết quả}.

Khi bạn gọi hàm trả kết quả, thường thì bạn muốn thực hiện thao
tác với kết quả thu được; chẳng hạn, bạn muốn gán nó cho một biến
hoặc dùng nó như một phần của biểu thức:

\beforeverb
\begin{verbatim}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
\end{verbatim}
\afterverb
%
Khi bạn gọi một hàm từ chế độ tương tác, Python hiển thị kết quả:

\beforeverb
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
\afterverb
%
Nhưng trong một văn lệnh, nếu bạn gọi một hàm trả kết quả, thì
giá trị kết quả này sẽ vĩnh viễn mất đi!

\beforeverb
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
\afterverb
%
Văn lệnh này tính giá trị căn bậc hai của 5, nhưng vì nó không
ghi lại và cũng chẳng hiển thị kết quả, nên nó không có tác dụng gì.

\index{chế độ tương tác}
\index{chế độ văn lệnh}

Các hàm không kết quả có thể hiển thị thứ gì đó trên màn hình hoặc
có những hiệu ứng khác, nhưng chúng không có giá trị được trả về.
Nếu bạn cố gắng gán kết quả vào một biến, bạn sẽ được một giá trị
đặc biệt gọi là {\tt None}.

\index{None (giá trị đặc biệt)}
\index{giá trị đặc biệt!None}

\beforeverb
\begin{verbatim}
>>> result = print_twice('Bing')
Bing
Bing
>>> print result
None
\end{verbatim}
\afterverb
%
Giá trị {\tt None} không phải là chuỗi \verb"'None'". 
Nó là một giá trị đặc biệt và có dạng riêng của mình:

\beforeverb
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
\afterverb
%
Các hàm ta đã viết cho đến giờ đều thuộc loại không kết quả.
Ta sẽ bắt đầu viết các hàm trả lại kết quả kể từ những chương tiếp sau.


\section{Tại sao cần có hàm?}
\index{hàm, mục đích sử dụng}

Có thể sẽ không rõ rằng tại sao ta phải cất công chia nhỏ 
chương trình thành các hàm. Có một số lí do cho điều đó:

\begin{itemize}

\item Việc tạo ra một hàm mới sẽ giúp bạn có khả năng đặt tên
cho một nhóm các câu lệnh, từ đó làm cho chương trình dễ đọc
và gỡ lỗi hơn.

\item Các hàm có thể thu gọn một chương trình bằng cách loại bỏ
những đoạn mã lệnh trùng lặp. Sau này, nếu bạn sửa đổi chương trình,
thì chỉ cần thực hiện sửa ở một chỗ.

\item Việc chia một chương trình dài thành những hàm cho phép ta 
gỡ lỗi từng phần một và sau đó kết hợp lại để được một chương trình
tổng thể hoạt động được.

\item Các hàm được thiết kế tốt sẽ hữu dụng với nhiều chương trình.
Một khi bạn viết ra một hàm và gỡ lỗi xong xuôi, bạn có dùng lại nó.

\end{itemize}


\section{Gỡ lỗi}
\label{editor}
\index{gỡ lỗi}

Nếu bạn dùng một trình soạn thảo văn bản để viết các văn lệnh,
bạn có thể gặp rắc rối liên quan đến các dấu trống và dấu tab. 
Cách tốt nhất để tránh những vấn đề kiểu này là chỉ dùng dấu
trống (không có dấu tab). Hầu hết các trình soạn thảo nhận biết
được Python đều thực hiện điều đó một cách mặc định, tuy nhiên
một số trình soạn thảo lại không thể.

\index{dấu trắng}

Các dấu tab và dấu trống thông thường đều vô hình, điều đó làm
cho việc gỡ lỗi khó khăn hơn. Vì vậy, bạn hãy tìm một trình 
soạn thảo có khả năng xử lí tốt vấn đề thụt đầu dòng.

Và cũng đừng quên lưu lại chương trình trước khi chạy nó. Một số
phần mềm môi trường phát triển tự động làm việc này, nhưng số khác
thì không. Ở trường hợp thứ hai, chương trình mà bạn nhìn thấy ở
trên cửa sổ soạn thảo sẽ khác với chương trình được chạy.

Việc gỡ lỗi có thể tốn nhiều thời gian nếu bạn cứ tiếp tục chạy
đi chạy lại chương trình không đúng.

Cần đảm bảo chắc rằng mã lệnh bạn đang nhìn thấy chính là mã lệnh
được chạy. Nếu bạn không chắc chắn, hãy đặt một câu lệnh như 
\verb"print 'hello'" ở đầu chương trình và chạy lại. Nếu không
thể thấy chữ \verb"hello" thì bạn không chạy đúng chương trình
cần được chạy!


\section{Thuật ngữ}

\begin{description}

\item[hàm:] Chuỗi các câu lệnh được đặt tên; nhằm thực hiện một
thao tác có ích nhất định. Các hàm có hoặc không nhận tham số và
có thể có hoặc không cho ra kết quả.
\index{hàm}

\item[định nghĩa hàm:] Câu lệnh nhằm tạo ra một hàm, đặt tên
cho nó, chỉ định các tham số và các lệnh cần được thực hiện.
\index{định nghĩa hàm}

\item[đối tượng hàm:] Giá trị được tạo ra bởi định nghĩa hàm.
Tên của hàm là một biến tham chiếu đến một đối tượng hàm.
\index{đối tượng hàm}

\item[đoạn đầu:] Dòng đầu tiên trong định nghĩa hàm.
\index{đoạn đầu}

\item[phần thân:] Chuỗi các câu lệnh bên trong định nghĩa hàm.
\index{phần thân}

\item[tham số:] Tên được dùng bên trong của hàm để tham chiếu
đến giá trị được chuyển dưới dạng đối số.
\index{tham số}

\item[lời gọi hàm:] Câu lệnh nhằm thực hiện một hàm. Câu lệnh
này bao gồm tên hàm, theo sau là danh sách các đối số.
\index{lời gọi hàm}

\item[đối số:]  Giá trị được cung cấp cho hàm khi hàm được gọi.
Giá trị này được gán cho tham số tương ứng trong hàm.
\index{đối số}

\item[biến địa phương:]  Biến được định nghĩa bên trong hàm.
Một biến địa phương chỉ có thể được dùng bên trong hàm đó.
\index{biến địa phương}

\item[giá trị được trả về:]  Kết quả của hàm. Nếu một lời gọi hàm được
dùng như một biểu thức thì giá trị được trả về chính là giá trị của biểu
thức đó.
\index{giá trị được trả về}

\item[hàm có kết quả:] Hàm có trả lại kết quả.
\index{hàm có kết quả}

\item[hàm không kết quả:] Hàm không trả lại kết quả.
\index{hàm không kết quả}

\item[module:] File có chứa một tập hợp các hàm có liên hệ với nhau
đồng thời có thể gồm các định nghĩa khác.
\index{module}

\item[câu lệnh import:] Câu lệnh dùng để đọc một file module và tạo
ra một đối tượng module.
\index{câu lệnh!import}

\item[đối tượng module:] Giá trị được tạo ra bởi một câu lệnh {\tt import}
để cho phép truy cập đến các giá trị được định nghĩa trong module đó.
\index{module}

\item[kí hiệu dấu chấm:]  Cú pháp để gọi một hàm trong module khác,
bằng cách chỉ định tên của module theo sau là một dấu chấm và tên của hàm.
\index{kí hiệu dấu chấm}

\item[kết hợp:] Việc dùng một biểu thức như là một phần của biểu thức lớn hơn,
hay một câu lệnh như là một phần của câu lệnh lớn hơn.
\index{kết hợp}

\item[luồng thực hiện:]  Thứ tự mà theo đó các câu lệnh được thực hiện khi chạy
chương trình.
\index{luồng thực hiện}

\item[biểu đồ ngăn xếp:]  Cách biểu diễn bằng hình vẽ cho một loạt các hàm 
chồng xếp lên nhau, trong đó có chỉ ra các biến của chúng và các giá trị mà chúng
tham chiếu đến.
% \index{biểu đồ ngăn xếp}

\item[khung:]  Hình chữ nhật trong biểu đồ ngăn xếp dùng để biểu diễn lời
gọi hàm. Nó bao gồm các biến địa phương và các tham số của hàm.
\index{khung (hàm)}

\item[dò ngược:]  Danh sách các hàm đang được thực hiện, được biểu thị khi có
biệt lệ xảy ra.
\index{dò ngược}


\end{description}


\section{Bài tập}

\begin{ex}

\index{hàm!len}
\index{len (hàm)}

Python có một hàm dựng sẵn, có tên là {\tt len} để trả lại độ dài của một
chuỗi kí tự, chẳng hạn giá trị của  \verb"len('allen')" là 5.

Viết một hàm tên là \verb"right_justify" để đọc vào một chuỗi tên là
{\tt s} như một tham số và in ra chuỗi bắt đầu với các kí tự trống; số kí tự
trống vừa đủ để cho kí tự cuối cùng của chuỗi nằm tại cột thứ 70 trên màn
hình.

\beforeverb
\begin{verbatim}
>>> right_justify('allen')
                                                                 allen
\end{verbatim}
\afterverb

\end{ex}


\begin{ex}
\index{đối tượng!hàm}

Một đối tượng hàm là một giá trị mà bạn có thể gán vào một biến hoặc
chuyển dưới dạng một tham số. Chẳng hạn, \verb"do_twice" là một hàm
nhận vào một đối tượng hàm như một tham số và thực hiện hàm tham số
này hai lần:

\beforeverb
\begin{verbatim}
def do_twice(f):
    f()
    f()
\end{verbatim}
\afterverb

Sau đây là một ví dụ có sử dụng \verb"do_twice" để gọi một hàm tên là
\verb"print_spam" hai lần.

\beforeverb
\begin{verbatim}
def print_spam():
    print 'spam'

do_twice(print_spam)
\end{verbatim}
\afterverb

\begin{enumerate}

\item Hãy gõ một văn lệnh thực hiện ví dụ này và chạy kiểm tra.

\item Sửa đổi \verb"do_twice" sao cho nó nhận vào hai đối số---
một đối tượng hàm và một giá trị---và gọi hàm hai lần, trong đó có
chuyển giá trị như một đối số.

\item Viết một dạng tổng quát hơn cho \verb"print_spam", đặt tên là
\verb"print_twice", trong đó nhận một chuỗi như tham số và in nó
hai lần.

\item Dùng dạng đã chỉnh sửa của \verb"do_twice" để gọi
\verb"print_twice" hai lần, trong đó có chuyển \verb"'spam'" như một
tham số.

\item Định nghĩa một hàm mới có tên
\verb"do_four" nhận vào một đối tượng hàm và một giá trị, sau đó 
gọi hàm bốn lần, với giá trị đóng vai trò tham biến. Trong phần
thân của hàm được định nghĩa chỉ dùng hai câu lệnh chứ không phải
là bốn.

\end{enumerate}

Bạn có thể xem cách giải của tôi ở \url{thinkpython.com/code/do_four.py}.

\end{ex}



\begin{ex}
Bài tập này\footnote{Dựa theo một bài tập của Oualline, {\em
    Practical C Programming, Third Edition}, O'Reilly (1997)} có thể
được giải bằng những câu lệnh và các đặc điểm khác của ngôn ngữ mà
chúng ta đã được biết đến giờ.

\index{grid}

\begin{enumerate}

\item Viết một hàm nhằm vẽ một lưới giống như hình sau đây:

\beforeverb
\begin{verbatim}
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
\end{verbatim}
\afterverb
%
Gợi ý: để in ra nhiều giá trị trên cùng một dòng, hãy dùng
dấu phẩy để phân cách các chuỗi:

\beforeverb
\begin{verbatim}
print '+', '-'
\end{verbatim}
\afterverb
%
Nếu lệnh {\tt print} kết thúc bằng dấu phẩy, Python sẽ tạm dừng in
tại dòng hiện tại, và những giá trị tiếp theo được in sẽ 
nằm trên cùng dòng đó.

\beforeverb
\begin{verbatim}
print '+', 
print '-'
\end{verbatim}
\afterverb
%
Kết quả của hai lệnh trên là \verb"'+ -'".

Một câu lệnh {\tt print} tự bản thân nó kết thúc dòng hiện tại
và chuyển đến dòng tiếp theo.

\item Hãy dùng hàm vừa định nghĩa để vẽ một lưới tương tự nhưng gồm bốn hàng
và bốn cột.

\end{enumerate}

Bạn có thể xem cách giải của tôi ở \url{thinkpython.com/code/grid.py}.

\end{ex}





\chapter{Nghiên cứu cụ thể: thiết kế giao diện}
\label{turtlechap}

\section{TurtleWorld}
\index{TurtleWorld}
\index{Swampy}

Kèm theo cuốn sách này, tôi có viết một bộ module có tên là 
Swampy.  Một trong những module này là TurtleWorld; nó cung cấp
một nhóm các hàm phục vụ cho việc vẽ các đường nét bằng cách
điều khiển những ``con rùa'' chạy trên màn hình.

Bạn có thể tải về Swampy từ \url{thinkpython.com/swampy};
và thực hiện theo những chỉ dẫn cần thiết để cài đặt Swampy 
vào máy của mình.

Hãy chuyển đến thư mục có chứa {\tt TurtleWorld.py}, tạo ra một
file có tên {\tt polygon.py} và gõ vào đoạn mã lệnh sau:

\beforeverb
\begin{verbatim}
from TurtleWorld import *

world = TurtleWorld()
bob = Turtle()
print bob

wait_for_user()
\end{verbatim}
\afterverb
%
Dòng đầu tiên là một dạng của lệnh {\tt import} mà ta đã gặp;
thay vì tạo ra một đối tượng module, nó trực tiếp nhập vào các
hàm có trong module đó, từ đó bạn có thể truy cập chúng mà không
cần dùng kí hiệu dấu chấm.

\index{câu lệnh!import}

Dòng kế tiếp tạo ra một đối tượng TurtleWorld để gán vào {\tt world} và
một đối tượng Turtle gán vào {\tt bob}. Việc in ra {\tt bob} bằng lệnh
{\tt print} sẽ cho ta thông tin kiểu như:

\beforeverb
\begin{verbatim}
<TurtleWorld.Turtle instance at 0xb7bfbf4c>
\end{verbatim}
\afterverb
%
Điều này có nghĩa là {\tt bob} tham chiếu đến một
{\bf cá thể} của Turtle được định nghĩa trong module
{\tt TurtleWorld}.  Trong trường hợp này,
``cá thể'' có nghĩa là thành viên của một tập hợp;
cá thể kiểu Turtle này là một trong số các cá thể của
tập hợp các Turtle.

\index{cá thể}

\verb"wait_for_user"  lệnh cho TurtleWorld đợi người dùng
thực hiện một thao tác, dù trong trường hợp này người dùng
không có nhiều lựa chọn khác ngoài việc đóng cửa sổ.

TurtleWorld cung cấp một số hàm phục vụ cho việc ``lái'' 
``con rùa'': {\tt fd} và {\tt bk} để đi tiến và lùi, 
{\tt lt} và {\tt rt} để rẽ trái và rẽ phải.
Ngoài ra, mỗi con rùa (đối tượng Turtle) đều nắm một cây bút,
vốn lại có thể được nhấc hoặc hạ; nếu hạ bút xuống, rùa sẽ để lại
nét vẽ khi nó di chuyển. Các hàm {\tt pu} và {\tt pd}
tương ứng với nhấc bút hoặc hạ bút. 

Để vẽ một góc vuông, hãy thêm các dòng lệnh dưới đây vào chương trình
(sau khi tạo ra {\tt bob} và trước khi gọi \verb"wait_for_user"):

\beforeverb
\begin{verbatim}
fd(bob, 100)
lt(bob)
fd(bob, 100)
\end{verbatim}
\afterverb
%
Dòng đầu tiên nhằm lệnh cho {\tt bob} đi tiến 100 bước.
Dòng lệnh thứ hai bảo nó rẽ trái.

Khi chạy chương trình này, bạn sẽ thấy {\tt bob} di chuyển trước hết
theo hướng đông, và sau đó theo hướng nam, để lại sau nó hai đoạn
thẳng.

Bây giờ hãy chỉnh sửa chương trình để vẽ một hình vuông. Xin đừng
đọc tiếp trước khi bạn hoàn thành chương trình này!

%\newpage

\section{Cách lặp lại đơn giản}
\label{lặp}
\index{lặp}

Đôi khi bạn viết mã lệnh kiểu như sau (ở đây không nói đến đoạn lệnh
dùng để khởi tạo TurtleWorld và đợi người sử dụng):

\begin{verbatim}
fd(bob, 100)
lt(bob)

fd(bob, 100)
lt(bob)

fd(bob, 100)
lt(bob)

fd(bob, 100)
\end{verbatim}
%
Chúng ta có thể làm việc này bằng cách viết gọn hơn với một lệnh {\tt for}.
Hãy thêm ví dụ sau đây vào {\tt polygon.py} và chạy lại chương trình:

\index{vòng lặp!for}
\index{câu lệnh!for}

\beforeverb
\begin{verbatim}
for i in range(4):
    print 'Hello!'
\end{verbatim}
\afterverb
%
Bạn sẽ thấy kết quả gióng như:

\beforeverb
\begin{verbatim}
Hello!
Hello!
Hello!
Hello!
\end{verbatim}
\afterverb
%
Đây là cách dùng lệnh {\tt for} đơn giản nhất; sau này chúng ta sẽ tìm 
hiểu thêm. Nhưng chỉ bằng cách đơn giản này cũng đủ để viết lại
chương trình vẽ hình vuông. Xin đừng đọc tiếp trước khi bạn hoàn thành
chương trình.

%\newpage

Đây là cách dùng một lệnh {\tt for} để vẽ hình vuông:

\beforeverb
\begin{verbatim}
for i in range(4):
    fd(bob, 100)
    lt(bob)
\end{verbatim}
\afterverb
%
Cú pháp của lệnh {\tt for} cũng tương tự như một định nghĩa hàm.
Nó gồm có một phần đầu kết thúc bởi dấu hai chấm và một phần 
thân được viết thụt vào so với lề. Phần thân có thể chứa bao nhiêu
câu lệnh cũng được.

\index{vòng lặp}

Một câu lệnh {\tt for} đôi khi còn đươc gọi là một {\bf vòng lặp} vì
dòng thực hiện sẽ đi xuôi theo phần thân và vòng ngược trở lại đầu.
Trong ví dụ trên, phần thân được chạy qua bốn lần.

Thực ra phiên bản mã lệnh này hơi khác với các bản vẽ hình vuông 
trước đó ở chỗ nó thực hiện một lần rẽ nữa sau khi vẽ cạnh cuối cùng
của hình vuông. Lần rẽ dư thừa này làm thời gian chạy lâu hơn một chút,
nhưng nó đơn giản hoá mã lệnh nếu chúng ta có thể thực hiện các
công việc gióng nhau bằng vòng lặp. Phiên bản này cũng có tác dụng
đưa con rùa về trạng thái khởi đầu, đặt nó về hướng xuất phát.


\section{Bài tập}

Tiếp theo đây là một loạt các bài tập có sử dụng TurtleWorld. Chúng
có mục đích riêng ngoài việc giải trí. Khi làm các bài tập này, bạn
hãy nghĩ xem mục đích riêng đó là gì.

Bên cạnh các bài tập còn có lời giải. Bạn hãy cố hoàn thành (hoặc
ít nhất là nỗ lực làm) các bài tập trước khi xem qua lời giải này.

\begin{enumerate}

\item Viết một hàm có tên {\tt square} nhận một tham biến tên 
{\tt t}, vốn là một con rùa. Hàm này dùng con rùa để vẽ một
hình vuông.

Viết một hàm nhằm mục đích chuyển {\tt bob} như một đối số cho 
{\tt square}, và sau đó chạy lại chương trình.

\item Thêm một tham biến nữa có tên {\tt length} cho {\tt square}.
Sửa đổi phần thân của sao cho độ dài của các cạnh là {\tt length}, 
và sau đó sửa đổi gọi hàm để cung cấp cho một đối số thứ hai. 
Chạy lại chương trình. Thử chương trình với một loạt các giá trị của 
{\tt length}.

\item Các hàm {\tt lt} và {\tt rt} đều mặc định thực hiện rẽ 90 độ,
nhưng bạn có thể cung cấp đối số thứ hai chứa số độ. Chẳng hạn,
{\tt lt(bob, 45)} thực hiện rẽ {\tt bob} 45 độ về bên trái.

Tạo một bản sao của {\tt square} và đổi tên thành {\tt polygon}.  Thêm
một tham số có tên là {\tt n} và sửa đổi phần thân để nó vẽ một hình
đa giác đều có n cạnh. Gợi ý: Các góc ngoài của một hình n-giác đều cùng
bằng $360.0 / n$ độ.

\index{đa giác (hàm)}
\index{hàm!đa giác}

\item Viết một hàm có tên là {\tt circle} để điều khiển rùa {\tt t},
và bán kính, {\tt r}, như là hai tham số. Hàm này thực hiện vẽ gần chính xác
một đường tròn bằng cách gọi hàm {\tt polygon} với các gía trị phù hợp
cho chiều dài cạnh và số cạnh. Thử lại hàm của bạn với một loạt các
giá trị của {\tt r}.

\index{đường tròn (hàm)}
\index{hàm!đường tròn}

Gợi ý: hình dung ra độ dài chu vi đường tròn và đảm bảo rằng 
{\tt length * n = circumference} (chu vi).

Một gợi ý khác: nếu {\tt bob} tỏ ra quá chậm, bạn có thể tăng tốc độ
bằng cách thay đổi {\tt bob.delay}, vốn là thời gian giữa các lần dịch chuyển
tính theo giây. {\tt bob.delay = 0.01} có thể sẽ đủ nhanh.

\item Viết một bản tổng quát hơn so với {\tt circle} gọi là {\tt arc},
trong đó nhận thêm một tham biến {\tt angle}, nhằm chỉ định bao nhiêu
phần đường tròn cần được vẽ.  {\tt angle} có đơn vị là độ, 
vì vậy khi {\tt angle=360}, {\tt arc} sẽ vẽ một đường tròn.

\index{cung (hàm)}
\index{hàm!cung}

\end{enumerate}

\section{Bao bọc}
% \ref{refactoring}
Bài tập thứ nhất yêu cầu bạn đặt đoạn mã vẽ hình vuông vào trong
một định nghĩa hàm và sau đó gọi hàm này, trong đó chuyển con rùa
như một tham biến. Một cách làm là như sau:

\beforeverb
\begin{verbatim}
def square(t):
    for i in range(4):
        fd(t, 100)
        lt(t)

square(bob)
\end{verbatim}
\afterverb
%
Các câu lệnh trong cùng, {\tt fd} và {\tt lt} được thụt lề hai lần,
nhằm cho thấy chúng ở bên trong vòng lặp {\tt for}, vốn bản 
thân ở trong định nghĩa hàm. Dòng tiếp theo,
{\tt square(bob)}, lại bắt đầu từ lề trái, đó chính là chỗ kết thúc
của cả vòng lặp {\tt for} và định nghĩa hàm.

Bên trong hàm, {\tt t} tham chiếu đến cùng con rùa như {\tt bob}
tham chiếu, vì vậy {\tt lt(t)} có cùng ý nghĩa như {\tt lt(bob)}.
Vậy tại sao không đặt tên tham biến là {\tt bob}?  Đó là vì {\tt t}
có thể là bất cứ con rùa nào chứ không riêng gì {\tt bob}, và bạn 
có thể tạo ra một con rùa thứ hai và chuyển nó như một đối số 
của {\tt square}:

\beforeverb
\begin{verbatim}
ray = Turtle()
square(ray)
\end{verbatim}
\afterverb
%
Việc gói một đoạn mã vào trong một hàm được gọi là 
{\bf bao bọc}. Một trong những ưu điểm của việc bao bọc
là nó gắn đoạn mã với một tên cụ thể, chính là một kiểu giúp cho
việc biên khảo sau này. Một ưu điểm khác là nếu bạn sử dụng lại
đoạn mã, việc gọi tên hàm sẽ ngắn gọn hwon nhiều so với việc
sao chép và dán toàn bộ phần thân hàm!

\index{bao bọc}


\section{Khái quát hoá}

Bước tiếp theo là thêm một tham biến {\tt length} vào {\tt square}.
Sau đây là một giải pháp:

\beforeverb
\begin{verbatim}
def square(t, length):
    for i in range(4):
        fd(t, length)
        lt(t)

square(bob, 100)
\end{verbatim}
\afterverb
%
Việc thêm một tham số vào một hàm được gọi là 
{\bf khái quát hoá} vì nó làm cho hàm số trở nên khái quát
hơn: trong phiên bản trước, kích thước của hình vuông là cố định,
ở phiên bản này nó có thể lớn nhỏ bất kì.

\index{khái quát hoá}

Bước tiếp theo cũng là một cách khái quát hoá. Thay vì việc vẽ
hình vuông, {\tt polygon} vẽ một hình đa giác đều với số cạnh 
bất kì. Sau đây là một lời  giải:

\beforeverb
\begin{verbatim}
def polygon(t, n, length):
    angle = 360.0 / n
    for i in range(n):
        fd(t, length)
        lt(t, angle)

polygon(bob, 7, 70)
\end{verbatim}
\afterverb
%
Đoạn mã trên thực hiện vẽ thất giác đều với mỗi cạnh dài bằng 70.
Nếu bạn có nhiêu tham biến hơn, sẽ rất dễ quên ý nghĩa của từng
tham biến cũng như thứ tự của chúng. Việc đưa vào tên của các
tham biến trong danh sách đối số là hợp lệ và thậm đôi khi là cần thiết:

\beforeverb
\begin{verbatim}
polygon(bob, n=7, length=70)
\end{verbatim}
\afterverb
%
Các tên này được gọi là {\bf tham biến từ khoá} vì chúng bao gồm cả
tên các tham biến đóng vai trò ``từ khoá'' (không nên nhầm với các
từ khoá dành riêng trong Python như {\tt while} và {\tt def}).

\index{tham biến!từ khoá}
\index{từ khoá (tham biến)}

Cú pháp này giúp cho chương trình trở nên dễ đọc hơn. Nó cũng giúp
bạn nhớ được rằng các đối số và tham biến hoạt động thế nào: khi bạn
gọi  một hàm, các đối số được gán cho các tham biến.


\section{Thiết kế giao diện}

Bước tiếp theo là viết {\tt circle}, trong đó nhận một tham biến là
bán kính {\tt r}. Sau đây là một lời giải đơn giản có sử dụng 
{\tt polygon} để vẽ đa giác đều 50 cạnh:

\beforeverb
\begin{verbatim}
def circle(t, r):
    circumference = 2 * math.pi * r
    n = 50
    length = circumference / n
    polygon(t, n, length)
\end{verbatim}
\afterverb
%
Dòng đầu tiên nhằm tính toán chu vi của đường tròn có bán kính
{\tt r} theo công thức $2 \pi r$.  Vì ta dùng {\tt math.pi} nên cần phải 
nhập {\tt math}.  Để cho tiện, các câu lệnh {\tt import} thường được
đặt ở đầu đoạn mã lệnh.

{\tt n} là số đọan thẳng để vẽ gần đúng đường tròn, sao cho 
{\tt length} là chiều dài mỗi đoạn.  Vì vậy, {\tt polygon} sẽ vẽ 
một đa giác đều có 50 cạnh gần khớp với một đường tròn có bán kính {\tt r}.

Một hạn chế của lời giải này là {\tt n} là một hằng số; điều đó có nghĩa
là với những đường tròn lớn, các đoạn thẳng sẽ rất dài, và với những
đường tròn nhỏ, chúng ta mất thời gian để vẽ quá nhiều đoạn thẳng
ngắn. Một giải pháp là khái quát hoá hàm này bằng cách nhận {\tt n}
làm tham số. Điều này giúp cho người dùng (khi gọi {\tt circle}) có
quyền lựa chọn tốt hơn, nhưng giao diện của chương trình vì thế cũng
kém phần trong sáng.

\index{giao diện}

{\bf Giao diện} của một hàm là phần tóm tắt cách dùng hàm đó: các
tham biến là gì? Hàm được viết nhằm mục đích gì? Và giá trị được trả lại
là gì? Một giao diện ``trong sáng'' có nghĩa là nó ``đơn giản nhất tới mức
có thể, nhưng không được đơn giản hơn.\footnote{Nguyên văn: ``as simple as
possible, but not simpler. (Einstein)}

\index{Einstein, Albert}

Ở ví dụ này, {\tt r} phải thuộc về giao diện vì nó chi phối đường tròn cần được vẽ.
Còn {\tt n} thì ít có lí hơn vì nó liên quan đến những chi tiết gắn với {\em cách}
vẽ đường tròn đó.

Thay vì việc làm lộn xộn giao diện, tốt hơn là ta chọn 
một giá trị hợp lí cho {\tt n} tuỳ thuộc vào chu vi {\tt circumference}:

\beforeverb
\begin{verbatim}
def circle(t, r):
    circumference = 2 * math.pi * r
    n = int(circumference / 3) + 1
    length = circumference / n
    polygon(t, n, length)
\end{verbatim}
\afterverb
%
Bây giờ số cạnh xấp xỉ bằng {\tt circumference/3}, như vậy mỗi 
cạnh có độ dài xấp xỉ bằng 3, tức là đủ nhỏ để cho đường tròn
được đẹp, nhưng cũng đủ lớn để mã lệnh được hiệu quả, và phù 
hợp với mọi kích cỡ đường tròn.


\section{Chỉnh đốn}
\label{refactoring}
\index{chỉnh đốn}

Khi viết {\tt circle}, tôi có thể dùng {\tt polygon} vì một đa giác
đều nhiều cạnh có thể gần khớp với một đường tròn. Nhưng 
{\tt arc} thì không phù hợp; ta không dùng được {\tt polygon}
hoặc {\tt circle} để vẽ một cung tròn.

Một cách làm khác là bắt đầu bằng một bản sao của 
{\tt polygon} và biến đổi nó về thành {\tt arc}.  Kết quả có thể
là như sau:

\beforeverb
\begin{verbatim}
def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = float(angle) / n
    
    for i in range(n):
        fd(t, step_length)
        lt(t, step_angle)
\end{verbatim}
\afterverb
%
Nửa sau của hàm này trông giống như {\tt polygon}, nhưng ta 
không thể dùng lại {\tt polygon} mà không thay đổi giao diện. 
Ta có thể khái quát hoá {\tt polygon} để nhận vào tham biến
thứ ba là góc, như khi đó {\tt polygon} lại không còn là một tên
gọi phù hợp nữa! Thay vào đó, hãy gọi hàm với tên {\tt polyline}
để khái quát hơn:

\beforeverb
\begin{verbatim}
def polyline(t, n, length, angle):
    for i in range(n):
        fd(t, length)
        lt(t, angle)
\end{verbatim}
\afterverb
%
Bây giờ ta có thể viết lại {\tt polygon} và {\tt arc} có dùng {\tt polyline}:

\beforeverb
\begin{verbatim}
def polygon(t, n, length):
    angle = 360.0 / n
    polyline(t, n, length, angle)

def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = float(angle) / n
    polyline(t, n, step_length, step_angle)
\end{verbatim}
\afterverb
%
Sau cùng, ta có thể viết lại {\tt circle} có dùng {\tt arc}:

\beforeverb
\begin{verbatim}
def circle(t, r):
    arc(t, r, 360)
\end{verbatim}
\afterverb
%
Quá trình này---việc sắp xếp lại chương trình để cải
thiện giao diện của hàm và giúp cho sử dụng lại mã lệnh---
được gọi là  {\bf chỉnh đốn}. Trong trường hợp này, ta đã
nhận thấy rằng có sự tương đồng trong mã lệnh của {\tt arc} và 
{\tt polygon}, vì vậy ta đã chỉnh đốn lại bằng cách đưa
phần chung này vào trong {\tt polyline}.

\index{chỉnh đốn}

Nếu đã có kế hoạch từ trước, có thể ta đã viết {\tt polyline} từ đầu 
và tránh việc chỉnh đố, nhưng thường thì vào thời điểm bắt đầu 
dự án bạn không biết rõ để thiết kế được toàn bộ giao diện. Một khi
đã bắt tay vào viết mã lệnh, bạn hiểu hơn về vấn đề cần giải quyết.
Đôi khi việc chỉnh đốn là một tín hiệu cho thấy bạn đã học được
một điều gì đó.


\section{Một kế hoạch phát triển}
\index{kế hoạch phát triển!bao bọc và khái quát hoá}

Một {\bf kế hoạch phát triển} là một quá trình trong việc lập trình.
Ở đây ta sẽ dùng kĩ thuât ``bao bọc và khái quát hoá.''  
Các bước trong quá trình này gồm có:

\begin{enumerate}

\item Bắt đầu bằng việc viết chương trình nhỏ mà không định nghĩa hàm.

\item Một khi chương trình của bạn đã chạy, hãy đóng gói nó vào trong
một hàm và đặt tên cho hàm này.

\item Khái quát hoá hàm bằng cách thêm vào các tham số một cách thích hợp.

\item Lặp lại các bước 1--3 đến khi bạn có một tập hợp các hàm hoạt động
tốt. Hãy sao chép và dán các đoạn mã lệnh tốt đó để khỏi đánh máy lại (và
gỡ lỗi lại).

\item Tìm mọi cơ hội để cải thiện chương trình bằng cách chỉnh đốn. Chẳng
hạn, nếu bạn có đoạn mã lệnh tương tự ở một vài chỗ trong chương trình,
hãy xét xem có thể chỉnh đốn bằng việc đưa nó vào một hàm chung hay không.

\end{enumerate}

Quá trình này có một số hạn chế---ta sẽ thấy các giải pháp khác trong
phần sau quyển sách---nhưng có thể nó sẽ có ích nếu bạn không biết trước
được việc chia chương trình thành các hàm như thế nào cho hợp lí. Phương
pháp này giúp bạn thiết kế trong lúc bạn viết chương trình.


\section{docstring}
\label{docstring}
\index{docstring}

Một {\bf docstring} (viết tắt của ``documentation string'') là một chuỗi
được đặt ở đầu một hàm có nhiệm vụ giải thích giao diện. Sau đây
là một ví dụ:

\beforeverb
\begin{verbatim}
def polyline(t, length, n, angle):
    """Vẽ n đoạn thẳng với chiều dài cho trước và góc
    (tính bằng độ) giữa chúng.  t là một Turtle.
    """    
    for i in range(n):
        fd(t, length)
        lt(t, angle)
\end{verbatim}
\afterverb
%
Docstring này là một chuỗi đặt trong ba dấu nháy, cũng được gọi
là chuỗi nhiều dòng vì ba dấu nháy cho phép chuỗi kéo dài qua
nhiều dòng liên tiếp.

\index{dấu nháy}
\index{chuỗi!đặt trong ba dấu nháy}
\index{ba dấu nháy (chuỗi)}
\index{chuỗi!trên nhiều dòng}

Tuy rất gọn gàng nhưng docstring này chứa đầy đủ tất cả những
thông tin thiết yếu cho người cần dùng đến hàm này. Nó giải thích
một cách cô đọng hàm này có nhiệm vụ gì (mà không nói chi tiết 
rằng hàm thực hiện bằng cách nào). Nó giải thích ảnh hưởng của
mỗi tham biến đối với biểu hiện của hàm và mỗi tham biến có kiểu
là gì (trong trường hợp không rõ ràng).

Việc ghi chép này là một phần quan trọng trong thiết kế giao diện.
Một giao diện được thiết kế tốt phải là giao diện rất dễ diễn giải;
nếu bạn gặp khó khăn khi giải thích các hàm mà bạn viết ra thì đó
có thể là dấu hiệu cho thấy giao diện của bạn có thể phải được
cải thiện.


\section{Gỡ lỗi}
\index{gỡ lỗi}
\index{giao diện}

Một giao diện cũng tựa như một giao kèo giữa hàm và chương trình
gọi. Chương trình đồng ý cung cấp những tham biến nhất định
còn hàm thì đồng ý thực hiện một việc nhất định.

Chẳng hạn, {\tt polyline} đòi hỏi bốn đối số. Thứ nhất phải là
một Turtle. Thứ hai phải là một số, và nó hẳn phải là một số dương,
dù rằng hàm vẫn hoạt động nếu không phải là số dương. Đối số thứ ba 
phải là một số nguyên; nếu không thì {\tt range} sẽ báo lỗi 
(điều này còn tùy vào phiên bản Python mà bạn đang dùng). 
Thứ tư phải là một số, ma ta hiểu là nó tính bằng độ.

Các yêu cầu trên được gọi là những {\bf điều kiện tiền đề} vì chúng
cần được đảm bảo là đúng trước khi hàm được thực hiện. Trái lại,
các điều kiện ở cuối hàm được gọi là {\bf trạng thái cuối}. Các
trạng thái cuối gồm có những hiệu ứng được mong đợi của hàm
(như việc vẽ các đoạn thẳng) và bất kì hiệu ứng phụ nào khác
(như di chuyển Turtle hoặc thay đổi gì đó trong khung cảnh).

\index{điều kiện tiền đề}
\index{trạng thái cuối}

Các điều kiện tiền đề thuộc về trách nhiệm của chương trình gọi. 
Nếu chương trình vi phạm một điều kiện tiền đề (đã được viết rõ
ở docstring) và hàm không thực hiện được việc, thì lỗi thuộc về
chương trình gọi chứ không thuộc về hàm.

% Removing this because we haven't seen conditionals yet!
%However, for purposes of debugging it is often a good idea for
%functions to check their preconditions rather than assume they are
%true.  If every function checks its preconditions before starting,
%then if something goes wrong, you will know which function to blame.


\section{Mục từ}

\begin{description}

\item[cá thể:] Một thành viên của tập hợp. Trong chương này, TurtleWorld
là một cá thể của tập hợp các TurtleWorld.
\index{cá thể}

\item[vòng lặp:] Một phần của chương trình được thực hiện lặp đi lặp lại.
\index{vòng lặp}

\item[bao bọc:] Quá trình đưa một danh sách các câu lệnh vào trong bên một
định nghĩa hàm.
\index{bao bọc}

\item[khái quát hoá:] Quá trình thay thế một thứ riêng biệt một cách không
cần thiết (chẳng hạn một con số) với một thứ khái quát thích hợp (như
một biến hoặc tham biến).
\index{khái quát hoá}

\item[đối số từ khoá:] Một đối số bao gồm cả tên của đối số đó dưới
hình thức của một ``từ khoá''.
\index{đối số từ khoá}
\index{đối số!từ khoá}

\item[giao diện:] Một đoạn mô tả cách dùng một hàm, bao gồm tên và
lời mô tả các đối số và giá trị được trả về.
\index{giao diện}

\item[kế hoạch phát triển:] Một quy trình để viết chương trình
máy tính.
\index{kế hoạch phát triển}

\item[docstring:]  Một chuỗi xuất hiện bên trong định nghĩa hàm
nhằm ghi chép lại giao diện của hàm đó.
\index{docstring}

\item[điều kiện tiền đề:] Một yêu cầu cần được thoả mãn bởi chương
trình gọi trước khi hàm được thực hiện.
\index{điều kiện tiền đề}

\item[trạng thái cuối:] Một điều kiện cần được hàm thoả mãn trước khi
nó kết thúc.
\index{trạng thái cuối}

\end{description}


\section{Bài tập}

\begin{ex}

Tải về mã lệnh trong chương này từ địa chỉ 
\url{thinkpython.com/code/polygon.py}.

\begin{enumerate}

\item Viết các docstring thích hợp cho {\tt polygon}, {\tt arc} và 
{\tt circle}.

\index{sơ đồ ngăn xếp}

\item Vẽ một sơ đồ ngăn xếp trong đó chỉ ra trạng thái của chương
trình khi chạy {\tt circle(bob, radius)}.  Bạn có thể tính tay hoặc
thêm vào các lệnh {\tt print} kèm theo mã lệnh.

\item Phiên bản {\tt arc} trong Mục~\ref{refactor} không chính xác
lắm vì cách xấp xỉ đoạn thẳng này luôn nằm ngoài đường tròn đúng.
Do đó, con rùa đã dừng lại ở cách đích cuối cùng một vài điểm. 
Cách làm của tôi đã giảm đi sai lệch này. Hãy đọc mã lệnh và
cố gắng hiểu nó. Bạn có thể vẽ biểu đồ và xem cơ chế hoạt động
của cách này.

\end{enumerate}

\end{ex}


\begin{ex}
\index{hoa}

Viết một tập hợp tổng quát gồm các hàm để vẽ những bông hoa như sau:

\centerline{\includegraphics[height=1in]{figs/flowers.eps}}

Bạn có thể tải về một lời giải từ \url{thinkpython.com/code/flower.py}.

\end{ex}


\begin{ex}
\index{hình quạt}

Viết một tập hợp tổng quát gồm các hàm để vẽ những hình như sau:

\centerline{\includegraphics[height=0.9in]{figs/pies.eps}}

Bạn có thể tải về một lời giải từ \url{thinkpython.com/code/pie.py}.

\end{ex}

\begin{ex}
\index{bảng chữ cái}
\index{bộ chữ turtle}

Các chữ cái trong bảng chữ có thể được xây dựng từ một số đủ
nhiều các thành phần cơ bản, như những đường thẳng đứng, đường
ngang, và đường cong. Hãy thiết kế một bộ phông chữ mà có thể
được vẽ với một số tốt thiểu các thành phần cơ bản như vậy; rồi
viết các hàm thực hiện việc vẽ chữ cái.

Bạn nên từng hàm riêng cho mỗi chữ cái, với tên hàm như 
\verb"draw_a", \verb"draw_b", v.v., và đặt chung các hàm vào một
file có tên là {\tt letters.py}.  Bạn có thể tải về một
``bộ chữ turtle'' từ \url{thinkpython.com/code/typewriter.py}
để so sánh với mã lệnh của bạn.

Bạn có thể tải về một lời giải từ \url{thinkpython.com/code/letters.py}.

\end{ex}



\chapter{Câu lệnh điều kiện và đệ quy}

\section{Toán tử chia dư}

\index{toán tử!chia dư}
\index{chia dư (toán tử)}

{\bf Toán tử chia dư} tính với các số nguyên và cho kết quả là phần dư
của phép chia số thứ nhất cho số thứ hai. Trong Python, toán tử chia dư
có kí hiệu là dấu phần trăm (\verb"%").  Cú pháp cũng giống như các
toán tử khác:

\beforeverb
\begin{verbatim}
>>> thuong = 7 / 3
>>> print thuong
2
>>> sodu = 7 % 3
>>> print sodu
1
\end{verbatim}
\afterverb
%
Như vậy 7 chia cho 3 bằng 2 dư 1.

Toán tử số dư bất ngờ trở nên có ích. Chẳng hạn, bạn có thể kiểm tra 
xem một số có chia hết cho số khác không---nếu 
{\tt x \% y} bằng không thì {\tt x} chia hết cho {\tt y}.

\index{chia hết}

Hơn nữa, bạn còn có thể lọc ra những chữ số cuối cùng bên phải từ
số ban đầu. Chẳng hạn, {\tt x \% 10} cho ta số hàng đơn vị của 
{\tt x} (trong hệ thập phân).  Tương tự, {\tt x \% 100} cho ta hai
chữ số hàng chục và đơn vị.


\section{Biểu thức Boole}
\index{biểu thức!Boole}
\index{Boole (biểu thức)}
\index{lô-gic (toán tử)}
\index{toán tử!lô-gic}

Một {\bf biểu thức Boole} là một biểu thức có giá trị đúng
hoặc sai. Các ví dụ sau đây dùng toán tử 
{\tt ==}, để so sánh hai toán hạng và 
trả lại kết quả {\tt True} (đúng) nếu chúng bằng nhau và {\tt False} 
(sai) trong trường hợp còn lại:

\beforeverb
\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
\afterverb
%
{\tt True} và {\tt False} là các giá trị đặc biệt thuộc về kiểu 
{\tt bool}; chúng không phải là các chuỗi:

\index{True (giá trị đặc biệt)}
\index{False (giá trị đặc biệt)}
\index{giá trị đặc biệt!True}
\index{giá trị đặc biệt!False}
\index{bool (kiểu)}
\index{kiểu!bool}

\beforeverb
\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
\afterverb
%
Toán tử {\tt ==} là một trong số các {\bf toán tử quan hệ}; các
toán tử quan hệ khác gồm có:

\beforeverb
\begin{verbatim}
      x != y               # x không bằng y
      x > y                # x lớn hơn y
      x < y                # x nhỏ hơn y
      x >= y               # x lớn hơn hoặc bằng y
      x <= y               # x nhỏ hơn hoặc bằng y
\end{verbatim}
\afterverb
%

Mặc dù có thể bạn đã quen thuộc với các toán tử này, song thực ra 
các kí hiệu Python khác với kí hiệu toán học. Một lỗi phổ biến là 
dùng nhầm một dấu bằng ({\tt =}) thay vì viết hai dấu bằng
({\tt ==}).  Nhớ lại rằng {\tt =} là một toán tử gán, còn 
{\tt ==} là một toán tử quan hệ. Ngoài ra không có toán tử nào 
được viết là {\tt =<} hoặc {\tt =>}.

\index{quan hệ (toán tử)}
\index{toán tử!quan hệ}


\section {Toán tử lô-gic}
\index{lô-gic (toán tử)}
\index{toán tử!lô-gic}

Có ba {\bf toán tử lô-gic}: {\tt and}, {\tt
or}, và {\tt not}. Nghĩa của các toán tử này giống như nghĩa
các từ tương ứng trong tiếng Anh. Chẳng hạn,
{\tt x > 0 and x < 10} chỉ đúng khi {\tt x} lớn hơn 0
{\em và} nhở hơn 10.

\index{and (toán tử)}
\index{or (toán tử)}
\index{not (toán tử)}
\index{toán tử!and}
\index{toán tử!or}
\index{toán tử!not}

{\tt n\%2 == 0 or n\%3 == 0} chỉ đúng khi {\em một trong hai} 
điều kiện là đúng; nghĩa là nếu số {\tt n} chia hết cho 2 {\em hoặc} 3.

Sau cùng, toán tử {\tt not} phủ định một biểu thức Boole. Do vậy 
{\tt not (x > y)} chỉ đúng khi {\tt x > y} là sai; tức là nếu
{\tt x} nhỏ hơn hoặc bằng {\tt y}.

Nói một cách chặt chẽ, các toán hạng đi theo toán tử lô-gic phải là
các biểu thức Boole, nhưng Python thì không chặt chẽ vậy. Bất kì
con số nào khác không đều được coi như True.

\beforeverb
\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
\afterverb
%
Sự linh hoạt này có thể có lợi, nhưng có một số điểm bất lợi nhỏ 
khiến người dùng nhầm lẫn. Có thể bạn muốn tránh dùng nó (trừ khi
bạn biết chắc rằng mình đang làm gì).


\section{Thực hiện lệnh theo điều kiện}
\label{conditional execution}

\index{câu lệnh!điều kiện}
\index{điều kiện (câu lệnh)}
\index{if (câu lệnh)}
\index{câu lệnh!if}
\index{cấu trúc rẽ nhánh}
\index{thực hiện lệnh theo điều kiện}

Để viết được những chương trình thực sự, chúng ta thường cần đến
khả năng kiểm tra những điều kiện nhất định và thay đổi biểu hiện
tương ứng của chương trình. Các {\bf câu lệnh điều kiện} cung cấp
cho ta khả năng này. Dạng đơn giản nhất là lệnh {\tt if}:

\beforeverb
\begin{verbatim}
if x > 0:
    print 'x là số dương'
\end{verbatim}
\afterverb
%
Biểu thức Boole ở cuối lệnh {\tt if} được gọi là 
{\bf điều kiện}. Nếu nó được thoả mãn thì đoạn lệnh bên trong 
được thực thi. Nếu không, sẽ chẳng có điều gì xảy ra.

\index{điều kiện}
\index{phức hợp (câu lệnh)}
\index{câu lệnh!phức hợp}

Các lệnh {\tt if} có cùng cấu trúc với các định nghĩa hàm: chúng
gồm có một phần đầu và tiếp theo là một lệnh bên trong được
viết thụt vào so với lề. Các câu lệnh kiểu như vậy được gọi là 
{\bf lệnh phức hợp}.

Không có quy định về giới hạn tối đa số câu lệnh ở trong phần thân,
nhưng ít nhất phải có một lệnh. Đôi khi ta cần có phần thân mà không
chứa một lệnh thực sự nào (thường là chỉ để giữ chỗ cho mã lệnh sau
này được viết thêm vào). Trong trường hợp đó, bạn có thể dùng lệnh
{\tt pass} để chỉ định ``không làm gì cả''.

\index{pass (câu lệnh)}
\index{câu lệnh!pass}

\beforeverb
\begin{verbatim}
if x < 0:
    pass          # cần phải xử lí giá trị âm!
\end{verbatim}
\afterverb
%

\section{Thực hiện lệnh theo lựa chọn}
\label{alternative execution}

\index{thực hiện lệnh theo lựa chọn}
\index{else (từ khoá)}
\index{từ khoá!else}

Dạng thứ hai của lệnh {\tt if} giúp cho việc {\bf thực hiện lệnh theo lựa chọn},
trong đó có hai khả năng và điều kiện được đặt ra để căn cứ vào
đó mà lựa chọn thực hiện một trong hai. Cú pháp có dạng như sau:

\beforeverb
\begin{verbatim}
if x%2 == 0:
    print 'x là số chẵn'
else:
    print 'x là số lẻ'
\end{verbatim}
\afterverb
%
Nếu phần dư của phép chia {\tt x} cho 2 là 0, thì chúng ta biết rằng 
{\tt x} là số chẵn, và chương trình sẽ hiển thị thông báo điều này.
Nếu điều kiện không được thoả mã thì lệnh thứ hai sẽ được thực hiện.
Vì điều kiện hoặc là được thoả mãn, hoặc không; nên luôn chỉ
có một trong hai phương án được thực hiện. Các phương án này được 
gọi là {\bf nhánh}, vì chúng là các nhánh rẽ trong luồng thực thi.

\index{nhánh}



\section{Các điều kiện xâu chuỗi}
\index{xâu chuỗi (điều kiện)}
\index{điều kiện!xâu chuỗi}

Đôi khi có nhiều hơn hai khả năng và ta cần nhiều nhánh. Một cách thể hiện
quy trình tính toán là dùng các {\bf điều kiện xâu chuỗi}:

\beforeverb
\begin{verbatim}
if x < y:
    print 'x nhỏ hơn  y'
elif x > y:
    print 'x lớn hơn y'
else:
    print 'x bằng y'
\end{verbatim}
\afterverb
%
{\tt elif} là chữ viết tắt của ``else if.''  Một lần nữa, chỉ có đúng một
nhánh được thực hiện. Không có giới hạn trên cho số các lệnh
{\tt elif}. Nếu có một vế {\tt else}, thì nó phải đứng cuối cùng.
Nhưng không nhất thiết cần có vế này.

\index{elif (từ khoá)}
\index{từ khoá!elif}


\beforeverb
\begin{verbatim}
if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
\end{verbatim}
\afterverb
%
Mỗi điều kiện được kiểm tra lần lượt. Nếu điều kiện thứ
nhất sai, điều kiện tiếp theo sẽ được kiểm tra, và cứ
như vậy. Nếu mộ ttrong các điều kiện đúng thì nhánh
tương ứng được thực hiện; và cả câu lệnh lớn sẽ kết
thúc. Ngay cả khi có nhiều hơn một điều kiện được
thoả mãn, chỉ có nhánh đúng đầu tiên được thực hiện.


\section{Các lệnh điều kiện lồng ghép}
\index{lồng ghép (điều kiện)}
\index{điều kiện!lồng ghép}

Một câu lệnh điều kiện có thể được đặt trong một lệnh điều khác.
Ta có thể viết lại ví dụ so sánh ba trường hợp như sau:

\beforeverb
\begin{verbatim}
if x == y:
    print 'x bằng y'
else:
    if x < y:
        print 'x nhỏ hơn y'
    else:
        print 'x lớn hơn y'
\end{verbatim}
\afterverb
% 
Câu lệnh điều kiện bên ngoài có hai nhánh. Nhánh thứ nhất
chỉ chứa một lệnh đơn giản. Nhánh thứ hai lại chứa một câu
lệnh {\tt if} khác, mà bản thân nó lại có hai nhánh.
Hai nhánh này đều chứa những câu lệnh đơn giản, mặc dù
dĩ nhiên chúng có thể là những câu lệnh điều kiện khác.

Tuy cách viết thụt vào trong làm cho cấu trúc rõ ý, nhưng 
{\bf các lệnh điều kiện lồng ghép} trở nên rất khó để người đọc nhanh.
Nhìn chung, tốt hơn là ta nên cố gắng tránh dùng chúng.

Các toán tử lô-gic thường cho ta cách đơn giản hoá các câu lệnh
điều kiện lồng ghép. Chẳng hạn, ta có thể viết lại mã lệnh sau
bằng một lệnh điều kiện đơn:

\beforeverb
\begin{verbatim}
if 0 < x:
    if x < 10:
        print 'x là số dương có một chữ số.'
\end{verbatim}
\afterverb
%

Lệnh {\tt print} chỉ được thực hiện một lần nếu ta làm cho nó qua cả
hai điều kiện, vì vậy đoạn lệnh sau với toán tử {\tt and} cũng có tác dụng 
tương tự:

\beforeverb
\begin{verbatim}
if 0 < x and x < 10:
    print 'x là số dương có một chữ số.'
\end{verbatim}
\afterverb




\section{Đệ quy}
\label{recursion}
\index{đệ quy}

Việc một hàm gọi một hàm khác là hợp lệ; một hàm gọi chính nó
cũng hợp lệ. Mặc dù bề ngoài thì có thể điều này không rõ hay dở
ra sao, nhưng thực ra đó chính là một trong những đặc điểm tuyệt
vời nhất trong lập trình.
Chẳng hạn, hãy xét hàm sau:

\beforeverb
\begin{verbatim}
def countdown(n):
    if n <= 0:
        print 'Bùm!'
    else:
        print n
        countdown(n-1)
\end{verbatim}
\afterverb
%
Nếu {\tt n} bằng 0 hoặc âm, chương trình sẽ in ra chữ, ``Bùm!''
Còn nếu không, nó sẽ in ra giá trị {\tt n} và sau đó gọi một hàm có tên {\tt
countdown}---nghĩa là chính nó---nhưng chuyển vào đối số {\tt n-1}.

Điều gì sẽ xảy ra khi ta gọi hàm kiểu như thế này?

\beforeverb
\begin{verbatim}
>>> countdown(3)
\end{verbatim}
\afterverb
%
Việc thực hiện {\tt countdown} bắt đầu với {\tt n=3}, và do 
{\tt n} lớn hơn 0, nó đưa ra giá trị 3, và rồi gọi chính nó...

\begin{quote}
Việc thực hiện {\tt countdown} bắt đầu với {\tt n=2}, và do 
{\tt n} lớn hơn 0, nó đưa ra giá trị 2, và rồi gọi chính nó...

\begin{quote}
Việc thực hiện {\tt countdown} bắt đầu với {\tt n=1}, và do 
{\tt n} lớn hơn 0, nó đưa ra giá trị 1, và rồi gọi chính nó...

\begin{quote}
Việc thực hiện {\tt countdown} bắt đầu với {\tt n=0}, và do 
{\tt n} không còn lớn hơn 0, nó đưa ra dòng chữ ``Bùm!'' và rồi
quay về.

\end{quote}

Hàm {\tt countdown} ứng với {\tt n=1} quay về.
\end{quote}

Hàm {\tt countdown} ứng với {\tt n=2} quay về.
\end{quote}

Hàm {\tt countdown} ứng với {\tt n=3} quay về.

Và rồi bạn trở về với \verb"__main__".  Như vậy,
toàn bộ kết quả đầu ra như sau:

\beforeverb
\begin{verbatim}
3
2
1
Bùm!
\end{verbatim}
\afterverb
%
Một hàm gọi chính nó được gọi tên là {\bf đệ quy}; quy trình
tương ứng cũng được gọi là {\bf đệ quy}.

\index{đệ quy}
\index{hàm!đệ quy}

Với ví dụ tiếp theo đây, ta viết một hàm để in một chuỗi
{\tt n} lần.

\beforeverb
\begin{verbatim}
def print_n(s, n):
    if n <= 0:
        return
    print s
    print_n(s, n-1)
\end{verbatim}
\afterverb
%
Nếu {\tt n <= 0} thì câu lệnh {\tt return} sẽ kết thúc hàm ngay.  Luồng 
thực hiện của chương trình sẽ lập tức trở về với nơi gọi nó, và phần còn
lại của hàm sẽ không được thực hiện.

\index{return (câu lệnh)}
\index{câu lệnh!return}

Phần còn lại của hàm cũng giống như {\tt countdown}: nếu {\tt n} 
lớn hơn 0, nó sẽ hiển thị {\tt s} và sau đó sẽ gọi chính nó để in lại
{\tt s} thêm $n-1$ lần nữa. Như vậy số dòng kết quả sẽ là 
{\tt 1 + (n - 1)}, tức là bằng {\tt n}.

Với những ví dụ đơn giản như trên, có thể sẽ dễ hơn nếu ta 
dùng một vòng lặp {\tt for}. Nhưng sau này ta sẽ gặp những ví dụ
mà ở đó rất khó viết một vòng lặp {\tt for} còn viết bằng đệ quy
sẽ dễ hơn, vì vậy việc làm quen với đệ quy từ sớm là rất tốt.



\section{Biểu đồ ngăn xếp cho các hàm đệ quy}
\index{biểu đồ ngăn xếp}
\index{khung hàm}
\index{khung}

Trong Mục~\ref{stackdiagram}, chúng ta đã dùng một biểu đồ
ngăn xếp để biểu thị trạng thái của một chương trình trong quá
trình hàm được gọi. Loại biểu đồ này cũng có thể được dùng để
diễn giải hàm đệ quy.

Mỗi khi hàm được gọi, Python tạo ra một ``khung'' mới cho hàm,
trong đó có chứa các biến cục bộ và tham số của hàm. Đối với
hàm đệ quy, có thể cùng một thời điểm trên ngăn xếp sẽ tồn tại 
nhiều khung hàm.

Hình vẽ này minh hoạ một sơ đồ ngăn xếp cho hàm {\tt countdown} 
khi gọi với {\tt n = 3}:

\beforefig
\centerline{\includegraphics{figs/stack2.eps}}
\afterfig

Như thường lệ, đỉnh của ngăn xếp là một khung cho \verb"__main__".
Nó trống không vì ta không tạo ra bất cứ biến nào trong 
\verb"__main__" hay chuyển đối số nào cho nó.

\index{trường hợp cơ sở}
\index{đệ quy!trường hợp cơ sở}

Bốn khung {\tt countdown} có các giá trị khác nhau cho tham biến
{\tt n}. Đáy của ngăn xếp, ở đó {\tt n=0}, được gọi là 
{\bf trường hợp cơ sở}.  Nó không thực hiện lời gọi đệ quy, do đó
không có thêm khung nào.

\begin{quote}
Hãy vẽ một biểu đồ ngăn xếp cho \verb"print_n" được gọi với
\verb"s = 'Xin chào'" và {\tt n=2}.
\end{quote}

\begin{quote}
Viết một hàm có tên \verb"do_n" trong đó nhận một đối tượng hàm
và một số, {\tt n}, làm hai tham biến, để gọi hàm được chỉ định
đúng {\tt n} lần.
\end{quote}



\section{Đệ quy vô hạn}
\index{đệ quy!vô hạn}
\index{runtime (lỗi)}
\index{lỗi!runtime}
\index{lần vết ngược}

Nếu một quá trình đệ quy không bao giờ đạt đến trường hợp cơ bản,
nó tiếp tục thực hiện gọi hàm đệ quy mãi mãi, và chương trình
không bao giờ kết thúc. Đây là {\bf đệ quy vô hạn}, và là điều ta 
thường tránh khi lập trình. Sau đây là một chương trình đơn giản nhất
có đệ quy vô hạn:

\beforeverb
\begin{verbatim}
def recurse():
    recurse()
\end{verbatim}
\afterverb
%
Trong phần lớn các ngôn ngữ lập trình, một chương trình có đệ quy vô hạn
sẽ không chạy mãi mãi. Python thông báo một lỗi khi chương trình đạt đến
mức độ sâu đệ quy tối đa:

\index{biệt lệ!RuntimeError}
\index{RuntimeError}

\beforeverb
\begin{verbatim}
  File "<stdin>", line 2, in recurse
  File "<stdin>", line 2, in recurse
  File "<stdin>", line 2, in recurse
                  .   
                  .
                  .
  File "<stdin>", line 2, in recurse
RuntimeError: Maximum recursion depth exceeded
\end{verbatim}
\afterverb
%
Lần này kết quả lần vết ngược lớn hơn một chút so với ở
chương trước. Khi một lỗi xảy ra, có 1000 khung hàm
{\tt recurse} trên ngăn xếp!


\section{Đầu vào từ bàn phím}
\index{đầu vào từ bàn phím}

Cho đến giờ, các chương trình ta đã viết có phần khuyết điểm ở chỗ
không cho người dùng nhập số liệu vào. Lần nào chương trình cũng
chạy y nguyên như thế.

Python cung cấp một hàm có sẵn, tên là \verb"raw_input" nhằm 
thu thập đầu vào từ bàn phím\footnote{Trong Python 3.0, hàm này 
có tên là {\tt input}.}.  Khi hàm này được gọi, chương trình tạm dừng
và chờ người dùng nhập thông tin từ bàn phím. Đến khi người dùng 
gõ phím {\sf Return} hoặc {\sf Enter}, chương trình chạy tiếp và
\verb"raw_input" trả lại những gì người dùng đã gõ vào dưới dạng
một chuỗi kí tự.

\index{Python 3.0}
\index{raw\_input (hàm)}
\index{hàm!raw\_input}

\beforeverb
\begin{verbatim}
>>> input = raw_input()
Bạn đang chờ đợi gì?
>>> print input
Bạn đang chờ đợi gì?
\end{verbatim}
\afterverb
%
Trước khi nhận thông tin từ người dùng, có thể sẽ tốt hơn nếu ta in ra
một lời nhắc để cho người dùng biết cần nhập vào điều gì. \verb"raw_input" 
có thể nhận lời nhắc như là một đối số:

\index{prompt}

\beforeverb
\begin{verbatim}
>>> name = raw_input('Tên bạn là gì?\n')
Tên bạn là gì?
Arthur, Vua xứ Britons!
>>> print name
Arthur, Vua xứ Britons!
\end{verbatim}
\afterverb
%
Chuỗi \verb"\n" ở cuối lời nhắc trên đại diện cho một {\bf newline} (dòng mới),
vốn là một kí tự đặc biệt để ngắt dòng. Điều này giải thích tại sao dòng chữ
người dùng nhập vào lại xuất hiện phía dưới lời nhắc.

\index{newline}

Nếu bạn trông đợi người dùng nhập vào một số nguyên, hãy thử chuyển đổi
giá trị thu được sang kiểu {\tt int}:

\beforeverb
\begin{verbatim}
>>> prompt = 'Một con chim én không mang gì có thể bay nhanh bao nhiêu?\n'
>>> speed = raw_input(prompt)
Một con chim én không mang gì có thể bay nhanh bao nhiêu?
17
>>> int(speed)
17
\end{verbatim}
\afterverb
%
Nhưng nếu người dùng nhập vào những thứ khác một chuỗi những chữ số thì
có thể sẽ nhận được thông báo lỗi:

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
Một con chim én không mang gì có thể bay nhanh bao nhiêu?
Ý của bạn là sao, một con én châu Phi hay châu Âu?
>>> int(speed)
ValueError: invalid literal for int()
\end{verbatim}
\afterverb
%
Trong các phần sau chúng ta sẽ xem xét cách khắc phục lỗi này.

\index{ValueError (lỗi giá trị)}
\index{biệt lệ!ValueError}


\section{Gỡ lỗi}
\label{whitespace}
\index{gỡ lỗi}
\index{lần vết ngược}

Mỗi khi có lỗi, công cụ lần vết ngược trong Python hiển thị rất
nhiều thông tin; có thể sẽ quá nhiều đối với người dùng, đặc biệt
là khi có nhiều khung trên ngăn xếp. Thường những phần quan trọng nhất
cần biết là:

\begin{itemize}

\item Lỗi này thuộc loại gì, và 

\item Nó xuất hiện ở đâu?

\end{itemize}

Các lỗi cú pháp thường dễ tìm, nhưng cũng có vài chỗ gây bất ngờ.
Các lỗi liên quan đến khoảng trắng có thể sẽ khó phát hiện vì trên
cửa sổ soạn thảo các dầu cách và dấu tab đều có thể lẫn với nhau.

\index{whitespace}

\beforeverb
\begin{verbatim}
>>> x = 5
>>>  y = 6
  File "<stdin>", line 1
    y = 6
    ^
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
Ở ví dụ này, sự phiền phức là ở chỗ dòng thứ hai được viết thụt vào
một dấu cách. Nhưng thông báo lỗi lại chỉ đến {\tt y}; điều này dễ gây
ngộ nhận. Nói chung, các thông báo lỗi đều chỉ ra trục trặc được phát
hiện ở đâu, nhưng lỗi thực sự lại có thể nằm ở trước đó trong đoạn mã
lệnh, đôi khi là ở dòng ngay trước đó.

\index{lỗi!runtime}
\index{runtime (lỗi)}

Điều tương tự cũng đúng với các lỗi runtime (lỗi trong lúc chạy).
Chẳng hạn bạn đang thử tính tỉ số tín hiệu so với nhiễu động theo 
đơn vị đề-xi-ben. Công thức là $SNR_{db} = 10 \log_{10} (P_{signal} / P_{noise})$.  
Trong Python, bạn có thể viết một đoạn mã giống như sau:

\beforeverb
\begin{verbatim}
import math
signal_power = 9
noise_power = 10
ratio = signal_power / noise_power
decibels = 10 * math.log10(ratio)
print decibels
\end{verbatim}
\afterverb
%
Nhưng khi chạy nó, bạn lại nhận được thông báo lỗi\footnote{Với Python 3.0,
bạn không còn phải nhận thông báo lỗi nữa; toán tử chia sẽ thực hiện phép 
chia với số có phần thập phân ngay cả khi các toán hạng là số nguyên.}:

\index{biệt lệ!OverflowError}
\index{OverflowError (lỗi tràn)}

\beforeverb
\begin{verbatim}
Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibels = 10 * math.log10(ratio)
OverflowError: math range error
\end{verbatim}
\afterverb
%
Thông báo lỗi chỉ ra dòng thứ 5, nhưng bản thân dòng đó không có gì sai.
Để tìm lỗi thực sự, có thể bạn cần phải in ra giá trị của {\tt ratio}, hoá ra
nó bằng 0. Vậy trục trặc xảy ra ở dòng 4, vì việc chia hai số tự nhiên 
là theo phép chia nguyên bỏ phần dư. Giải pháp khắc phục điều này là
biểu thị cả công suất tín hiệu và công suất nhiễu động dưới dạng các
giá trị số thập phân (dấu phẩy động).

\index{phép chia nguyên}

Nói chung, các thông báo lỗi sẽ cho bạn biết trục trặc được phát hiện ở đâu,
nhưng thường thì đó không phải là nguyên nhân gây ra lỗi.


\section{Thuật ngữ}

\begin{description}

\item[toán tử module:]  Toán tử, kí hiệu là dấu phần trăm,
({\tt \%}), được dùng với các số nguyên và trả lại phần dư của phép
chia hai số nguyên đó.
\index{module (toán tử)}
\index{toán tử!module}

\item[biểu thức Boole:]  Biểu thức có giá trị là 
{\tt True} (đúng) hoặc {\tt False} (sai).
\index{biểu thức Boole}
\index{biểu thức!Boole}

\item[toán tử quan hệ:] Một trong các toán tử để so sánh các toán hạng 
của nó: {\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, và {\tt <=}.

\item[toán tử lô-gic:] Một trong các toán tử để kết hợp các biểu thức Boole:
{\tt and}, {\tt or}, và {\tt not}.

\item[câu lệnh điều kiện:]  Câu lệnh để điều khiển dòng thực hiện 
chương trình tuỳ theo một điều kiện nào đó.
\index{điều kiện (câu lệnh)}
\index{câu lệnh!điều kiện}

\item[điêu kiện:]  Biểu thức Boole trong một câu lệnh điều kiện để quyết định
nhánh nào sẽ được thực hiện.
\index{điều kiện}

\item[câu lệnh phức hợp:]  Câu lệnh bao gồm một đoạn đầu và một phần
thana. Đoạn đầu kết thúc bởi dấu hai chấm (:).  Phần thân được viết thụt vào so
với đoạn đầu.
\index{câu lệnh phức hợp}

\item[phần thân:] Một loạt các câu lệnh ở trong một câu lệnh phức hợp.
\index{phần thân}

\item[nhánh:] Một trong số các phương án trong một câu lệnh điều kiện.
Mỗi phương án có thể gồm một loạt các câu lệnh.
\index{branch}

\item[câu lệnh điều kiện xâu chuỗi:]  Câu lệnh điều kiện với một chuỗi liên tiếp
các nhánh phương án.
\index{xâu chuỗi (câu lệnh điều kiện)}
\index{câu lệnh điều kiện!xâu chuỗi}

\item[câu lệnh điều kiện lồng ghép:]  Câu lệnh điều kiện xuất hiện bên trong của
một trong số các nhánh của một câu lệnh điều kiện khác.
\index{lồng ghép (câu lệnh điều kiện)}
\index{câu lệnh điều kiện!lồng ghép}

\item[đệ quy:]  Quá trình gọi hàm mà hiện thời đang được thực thi.
\index{đệ quy}

\item[trường hợp cơ bản:]  Nhánh điều kiện trong một hàm đệ quy mà bản thân không
gọi đệ quy.
\index{trường hợp cơ bản}

\item[đệ quy vô hạn:]  Đệ quy mà không có trường hợp cơ bản, hoặc không bao giờ đạt
đên trường hợp cơ bản. Đệ quy vô hạn cuối cùng sẽ gây ra lỗi thực thi (runtime error).
\index{đệ quy vô hạn}

\end{description}

\section{Bài tập}

\begin{ex}
\index{Định lý cuối cùng của Fermat}

Định lý cuối cùng của Fermat phát biểu rằng không có các số nguyên
$a$, $b$, và $c$ nào thoả mãn

\[ a^n + b^n = c^n \]
%
với bất kì giá trị nào của $n$ lớn hơn 2.

\begin{enumerate}

\item Viết một hàm có tên là \verb"check_fermat" nhận vào bốn
tham số---{\tt a}, {\tt b}, {\tt c} và {\tt n}---rồi kiểm tra xem 
có thoả mãn định lý Fermat không.  Nếu 
$n$ lớn hơn 2 và hoá ra 

\[a^n + b^n = c^n \]
%
thì chương trình sẽ in ra ``Trời, Fermat đã lầm!''
Còn nếu không thì chương trình sẽ in ra, ``Không, vẫn không đúng.''

\item Viết một hàm nhắc người dùng nhập vào các giá trị của 
Write a function that prompts the user to input values
{\tt a}, {\tt b}, {\tt c} và {\tt n}, chuyển chúng sang dạng số nguyên
và dùng \verb"check_fermat" để kiểm tra xem liệu chúng có vi phạm
định lý Fermat hay không.

\end{enumerate}

\end{ex}


\begin{ex}
\index{hình tam giác}

Nếu bạn có trong tay ba thanh thẳng, bạn có thể hoặc không thể xếp
thành một hình tam giác. Chẳng hạn, nếu một thanh dài 30 cm và
hai thanh kia chỉ đều chỉ dài 3 cm, rõ ràng là bạn không thể làm cho 
hai thanh ngắn nối với nhau được. Với ba thanh có độ dài bất kì, có
một cách đơn giản để kiểm tra xem chúng có tạo nên hình tam giác
được không.

\begin{quotation}
``Nếu bất kì một độ dài nào lớn hơn tổng hai độ dài còn lại thì
bạn không thể tạo thành tam giác. Ngược lại, bạn có thể.
\footnote{Nếu tổng hai độ dài bằng độ dài thứ ba thì chúng sẽ tạo ra
một ``tam giác suy biến''.}''
\end{quotation}

\begin{enumerate}

\item Viết một hàm có tên là \verb"is_triangle" nhận vào ba tham số
là các số nguyên, sau đó in ra ``Yes'' hoặc ``No,'' tuỳ theo bạn có thể
hay không thể tạo thành hình tam giác từ ba thanh với các độ dài đó.

\item Viết một hàm nhắc người dùng nhập vào độ dài ba thanh, chuyển
thành dạng số nguyên, rồi dùng \verb"is_triangle" để kiểm tra xem
ba thanh với các độ dài đó có thể được xếp thành tam giác hay không.

\end{enumerate}

\end{ex}

Các bài tập tiếp theo đây dùng TurtleWorld từ Chương~\ref{turtlechap}:

\index{TurtleWorld}

\begin{ex}

Hãy đọc hàm sau đây và thử xem bạn có thể hình dung được mục đích
của nó không. Sau đó thì chạy nó (xem các ví dụ ở Chương~\ref{turtlechap}).

\beforeverb
\begin{verbatim}
def draw(t, length, n):
    if n == 0:
        return
    angle = 50
    fd(t, length*n)
    lt(t, angle)
    draw(t, length, n-1)
    rt(t, 2*angle)
    draw(t, length, n-1)
    lt(t, angle)
    bk(t, length*n)
\end{verbatim}
\afterverb

\end{ex}


\begin{ex}

\index{Đường cong Koch}

Đường cong Koch là một hình phân mảnh (fractal) có dạng như hình sau:

\beforefig
\centerline{\includegraphics[height=1in]{figs/koch.eps}}
\afterfig

Để vẽ một đường cong Koch với độ dài $x$, tất cả những việc bạn cần làm là 

\begin{enumerate}

\item Vẽ một đường cong Koch với độ dài $x/3$.

\item Quay trái 60 độ.

\item Vẽ một đường cong Koch với độ dài $x/3$.

\item Quay phải 120 độ.

\item Vẽ một đường cong Koch với độ dài $x/3$.

\item Quay trái 60 độ.

\item Vẽ một đường cong Koch với độ dài $x/3$.

\end{enumerate}

Ngoại lệ duy nhất là nếu $x$ nhở hơn 3.  Trong trường hợp đó,
bạn chỉ cần vẽ một đoạn thẳng có độ dài $x$.

\begin{enumerate}

\item Viết một hàm có tên là {\tt koch} nhận vào các tham số
là một Turtle và một độ dài, sau đó dùng Turtle để vẽ một đường
cong Koch với độ dài cho trước đó.

\item Viết một hàm có tên là {\tt snowflake} để vẽ ba đường cong 
Koch nối thành hình một bông tuyết.

Bạn có thể xem lời giải của tôi ở \url{thinkpython.com/code/koch.py}.

\item Có một số cách khái quát hoá đường cong Koch. Hãy xem các
ví dụ ở \url{wikipedia.org/wiki/Koch_snowflake} và viết mã lệnh cho
ví dụ mà bạn thích.

\end{enumerate}
\end{ex}



\chapter{Các hàm trả lại kết quả}
\label{fruitchap}

\section{Các giá trị được trả về}
\index{giá trị được trả về}

Một số hàm dựng sẵn mà ta đã dùng, như các hàm toán học,
đều trả lại kết quả. Việc gọi hàm sẽ tạo ra một giá trị, mà chúng
ta thường gán vào một biến hoặc sử dụng như một phần của
một biểu thức.

\beforeverb
\begin{verbatim}
e = math.exp(1.0)
height = radius * math.sin(radians)
\end{verbatim}
\afterverb
%
Tất cả các hàm chúng ta đã viết đều là hàm rỗng; chúng chỉ
in ra thông tin hoặc di chuyển con rùa, nhưng kết quả mà
chúng trả về là {\tt None}.

Trong chương này, (cuối cùng thì) chúng ta (cũng) viết những
hàm có trả lại kết quả. Ví dụ đầu tiên là {\tt area}, có nhiệm 
vụ tính diện tích của một hình tròn với bán kính cho trước:

\beforeverb
\begin{verbatim}
def area(radius):
    temp = math.pi * radius**2
    return temp
\end{verbatim}
\afterverb
%
Ta đã thấy câu lệnh {\tt return} từ trước rồi, nhưng trong một
hàm trả lại kết quả, lệnh {\tt return} bao gồm một biểu thức.
Câu lệnh này có nghĩa là: ``Lập tức trở về chương trình chính
và dùng biểu thức bên cạnh để làm giá trị để trả lại.''
Vì biểu thức có thể phức tạp tù ý nên chúng ta có thể viết
hàm trên gọn lại như sau:

\index{return (câu lệnh)}
\index{câu lệnh!return}

\beforeverb
\begin{verbatim}
def area(radius):
    return math.pi * radius**2
\end{verbatim}
\afterverb
%
Tuy vậy, sự có mặt của các {\bf biến tạm thời} như {\tt temp} 
thường làm việc gỡ lỗi được dễ dàng hơn.

% \index{temporary variable}
\index{biến!tạm thời}

Đôi khi ta cần có nhiều câu lệnh return, mỗi lệnh ở một nhánh của 
lệnh điều kiện:

\beforeverb
\begin{verbatim}
def absolute_value(x):
    if x < 0:
        return -x
    else:
        return x
\end{verbatim}
\afterverb
%
Vì các lệnh {\tt return} này ở các nhánh điều kiện độc lập với nhau,
luôn chỉ có một trong số đó được thực hiện.

Ngay khi một lệnh return được thực hiện, hàm sẽ kết thúc ngay mà
không thực hiện bất cứ lệnh nào tiếp sau nó. Mã lệnh xuât hiện sau
dòng lệnh {\tt return}, hay nói chung, trong bất cứ chỗ nào khác của
chương trình mà không nằm trong luồng thực hiện thì được gọi là 
{\bf mã lệnh chết}.

\index{mã lệnh chết}

Trong một hàm có trả lại kết quả, ta nên đảm bảo rằng mỗi luồng thực
hiện khả dĩ đều dẫn tới một lệnh
{\tt return}. Chẳng hạn:

\beforeverb
\begin{verbatim}
def absolute_value(x):
    if x < 0:
        return -x
    if x > 0:
        return x
\end{verbatim}
\afterverb
%
Chương trình này không chính xác vì nếu chẳng may {\tt x} bằng 0
thì không có điều kiện nào được thoả mãn, và hàm sẽ kết thúc 
mà không gặp phải lệnh {\tt return} nào. Nếu dòng thực hiện 
đến được cuối của hàm thì giá trị trả về sẽ là {\tt None}, không phải
là giá trị tuyệt đối của 0.

\index{None (giá trị đặc biệt)}
\index{giá trị đặc biệt!None}

\beforeverb
\begin{verbatim}
>>> print absolute_value(0)
None
\end{verbatim}
\afterverb
%
Tiện thể cũng lưu ý các bạn rằng Python có sẵn một
hàm tên là {\tt abs} để tính giá trị tuyệt đối.

\index{abs (hàm)}
\index{hàm!abs}

\begin{ex}

\index{so sánh (hàm)}
\index{hàm!so sánh}

Viết một hàm tên là {\tt compare} (so sánh)
để trả lại {\tt 1} nếu {\tt x > y},
{\tt 0} nếu {\tt x == y}, và {\tt -1} nếu {\tt x < y}.
\end{ex}


\section{Phát triển tăng dần}
\label{incremental development}
\index{kế hoạch phát triển!tăng dần}


Khi bạn viết các hàm lớn hơn, có thể bạn sẽ dành nhiều thời gian để
gỡ lỗi.

Để giải quyết các chương trình với mức độ phức tạp ngày càng cao,
bạn có thể thử một quy trình gọi là {\bf phát triển tăng dần}.
Mục tiêu của phát triển tăng dần là tránh mất thời gian gỡ lỗi bằng
cách mỗi lúc chỉ thêm vào và thử nghiệm một đoạn mã lệnh rất ngắn.

\index{thử nghiệm!lập trình tăng dần}
\index{định lý Py-ta-go}

Ở ví dụ này, bạn cần tìm khoảng cách giữa hai điểm cho bởi các
toạ độ $(x_1, y_1)$ và $(x_2, y_2)$. Theo định lý Py-ta-go, khoảng
cách sẽ là:

\begin{displaymath}
\mathrm{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{displaymath}
%
Bước đầu tiên là cân nhắc xem một hàm {\tt distance} trong Python
sẽ trông như thế nào. Nói cách khác, các số liệu đầu vào (tham số) và
kết quả (giá trị trả lại) là gì?

Trong trường hợp này, số liệu đầu vào mô tả hai điểm; ta có thể biểu 
thị chúng bằng bốn số. Giá trị cần trả về là khoảng cách, tức là một
giá trị số có phần thập phân.

Bạn đã có thể phác thảo ngay ra hàm như sau:

\beforeverb
\begin{verbatim}
def distance(x1, y1, x2, y2):
    return 0.0
\end{verbatim}
\afterverb
%
Dĩ nhiên là mã lệnh trên chưa tính được khoảng cách; nó luôn trả về
số không. Nhưng về mặt cú pháp thì nó đúng, và nó chạy được, nghĩa
là bạn có thể thử nghiệm nó trước khi làm cho nó phức tạp thêm.

Để thử nghiệm hàm mới viết, hãy gọi nó với các tham số ví dụ:

\beforeverb
\begin{verbatim}
>>> distance(1, 2, 4, 6)
0.0
\end{verbatim}
\afterverb
%
Sở dĩ tôi chọn các tham số này vì khoảng cách ngang sẽ là 3 và khoảng
cách dọc là 4, theo đó thì kết quả sẽ bằng 5 (cạnh huyền của một tam
giác có các cạnh là 3-4-5). Khi thử nghiệm một hàm, bạn nên biết trước
kết quả đúng.

\index{thử nghiệm!biết trước kết quả}

Đến lúc này, chúng ta có thể khẳng định rằng hàm đã đúng về mặt
cú pháp, và chúng ta sẽ thêm mã lệnh vào phần thân. Một bước làm
hợp lí tiếp theo là tính các hiệu số $x_2 - x_1$ và $y_2 - y_1$.  
Đoạn mã tiếp theo sẽ lưu giữ các giá trị trên vào các biến tạm thời và
hiển thị chúng.

\beforeverb
\begin{verbatim}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print 'dx bằng', dx
    print 'dy bằng', dy
    return 0.0
\end{verbatim}
\afterverb
%
Nếu hàm số hoạt động được, nó sẽ hiển thị \verb"'dx is 3'" và {\tt
'dy is 4'}.  Nếu vậy, chúng ta biết rằng hàm đã nhận các đối số đúng
và thực hiện chính xác phép tính đầu tiên. Nếu không, chúng ta chỉ
cần phải kiểm tra một só ít các dòng lệnh.

Tiếp theo chúng ta tính tổng các bình phương của {\tt dx} và {\tt dy}:

\beforeverb
\begin{verbatim}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print 'd bình phương bằng: ', dsquared
    return 0.0
\end{verbatim}
\afterverb
%
Một lần nữa, bạn có thể chạy đoạn mã này và kiểm tra kết quả thu được
(nó phải bằng 25).
Cuối cùng, bạn có thể dùng {\tt math.sqrt} để tính toán và trả lại kết quả:

\index{sqrt (hàm)}
\index{hàm!sqrt}

\beforeverb
\begin{verbatim}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = math.sqrt(dsquared)
    return result
\end{verbatim}
\afterverb
%
Nếu đoạn mã trên hoạt động tốt, bạn đã giải quyết xong. Nếu không,
bạn có thể sẽ cần phải in  giá trị của {\tt result} trước câu lệnh
return.

Mã lệnh trên là phiên bản cuối cùng của hàm; nó không hiển thị gì khi
được chạy mà chỉ trả lại một giá trị. Các câu lệnh {\tt print} mà chúng
ta thêm vào chỉ hữu ích khi gỡ lỗi, nhưng một khi đã viết được hàm rồi
thì ta cần phải bỏ chúng đi. Các câu lệnh thêm vào như vậy còn có tên 
là {\bf dàn giáo} vì nó có ích cho việc xây dựng chương trình nhưng lại
không phải là một phần trong sản phẩm cuối cùng.

\index{dàn giáo}

Khi mới tập lập trình, mỗi lúc bạn chỉ nên viết thêm một hoặc hai
dòng lệnh. Sau này khi đã có kinh nghiệm, bạn sẽ viết và gỡ lỗi những
khối lệnh lớn hơn. Dù theo cách nào đi nữa, việc phát triển tăng dần
sẽ giúp bạn tiết kiệm nhiều thời gian dành cho gỡ lỗi.

Các điểm cơ bản của quy trình này là:

\begin{enumerate}

\item Bắt đầu với một chương trình chạy được và thêm vào những
thay đổi nhỏ. Bất cứ lúc nào khi gặp lỗi, bạn sẽ phát hiện được ngay
lỗi đó ở đâu.

\item Dùng các biến tạm để lưu giữ các giá trị trung gian, từ đó bạn
có thể hiển thị và kiểm tra chúng.

\item Một khi chương trình đã hoạt động, bạn có thể dỡ bỏ các đoạn
mã ``dàn giáo'', hoặc rút gọn nhiều câu lệnh về một biểu thức
phức hợp, nếu việc này không làm cho chương trình trở nên khó đọc hơn.

\end{enumerate}

\begin{ex}

\index{cạnh huyền}

Hãy dùng cách phát triển tăng dần để viết một hàm tên là {\tt hypotenuse} 
để trả lại chiều dài của cạnh huyền trong một tam giác vuông 
khi biết các đối số là chiều dài hai cạnh góc vuông. Hãy ghi lại từng bước
phát triển trong quá trình làm.
\end{ex}


\section{Hàm hợp}

\index{hàm hợp}

Đến bây giờ, bạn có thể trông đợi việc gọi một hàm từ bên trong một
hàm khác, Việc này được gọi là {\bf hợp} các hàm.

Với ví dụ dưới đây, ta sẽ viết một hàm nhận vào hai điểm là tâm của
đường tròn và một điểm trên đường tròn đó, rồi tính diện tích của
hình tròn.

Giả sử như toạ độ của tâm điểm được lưu trong các biến {\tt xc} và 
{\tt yc}, toạ độ điểm trên đường tròn là {\tt xp} và {\tt yp}. Bước
đầu tiên sẽ là tìm bán kính của đường tròn, vốn là khoảng cách 
giữa hai điểm đó. Ta vừa mới viết một hàm, {\tt
distance}, để làm việc này:

\beforeverb
\begin{verbatim}
radius = distance(xc, yc, xp, yp)
\end{verbatim}
\afterverb
%
Bước tiếp theo là tìm diện tích của một đường tròn có bán kính đó;
chúng ta cũng vừa viết một hàm thực hiện điều này:

\beforeverb
\begin{verbatim}
result = area(radius)
\end{verbatim}
\afterverb
%
Kết hợp hai bước này vào trong cùng một hàm, ta thu được:

\index{encapsulation}

\beforeverb
\begin{verbatim}
def circle_area(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
\end{verbatim}
\afterverb
%
Các biến tạm thời {\tt radius} và {\tt result} có ích cho việc phát
triển và gỡ lỗi chương trình, nhưng một khi chương trình đã hoạt động tốt,
ta có thể rút gọn nó lại bằng cách kết hợp các lời gọi hàm:

\beforeverb
\begin{verbatim}
def circle_area(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
\end{verbatim}
\afterverb
%

\section{Các hàm Boole}
\label{boolean}

\index{hàm Boole}

Các hàm có thể trả lại giá trị Boole, vốn rất tiện dụng cho việc ẩn giấu
các phép kiểm tra phức tạp vào trong một hàm. Chẳng hạn:

\beforeverb
\begin{verbatim}
def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
\end{verbatim}
\afterverb
%
Một cách làm thông thường là đặt tên các hàm Boole cho giống với các
câu hỏi có/không. Chẳng hạn (tiếng Anh: có chia hết)
\verb"is_divisible" trả lại {\tt True} hoặc {\tt False} để chỉ định rằng 
{\tt x} có chia hết cho {\tt y} hay không.

Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
>>>   is_divisible(6, 4)
False
>>>   is_divisible(6, 3)
True
\end{verbatim}
\afterverb
%
Kết quả của toán tử {\tt ==} là một giá trị Boole, vì vậy ta có thể viết hàm
gọn lại bằng cách trả lại giá trị trực tiếp như sau:

\beforeverb
\begin{verbatim}
def is_divisible(x, y):
    return x % y == 0
\end{verbatim}
\afterverb
%
Các hàm Boole thường được dùng trong các câu lệnh điều kiện:

\index{điều kiện (câu lệnh)}
\index{câu lệnh!điều kiện}

\beforeverb
\begin{verbatim}
if is_divisible(x, y):
    print 'x chia hết cho y'
\end{verbatim}
\afterverb
%
Có thể bạn sẽ muốn viết:

\beforeverb
\begin{verbatim}
if is_divisible(x, y) == True:
    print 'x is divisible by y'
\end{verbatim}
\afterverb
%
Nhưng phép so sánh thêm là hoàn toàn thừa.

\begin{ex}
Hãy viết một hàm \verb"is_between(x, y, z)" trả lại 
{\tt True} nếu $x \le y \le z$ hoặc {\tt False} trong trường hợp còn lại.
\end{ex}


\section{Nói thêm về đệ quy}

\index{đệ quy}
\index{Turing đầy đủ (ngôn ngữ)}
\index{ngôn ngữ!Turing đầy đủ}
\index{Turing, Alan}
\index{Luận án của Turing}

Chúng ta mới chỉ tìm hiểu một phần nhỏ của Python, nhưng bạn có thể
muốn biết rằng liệu phần nhỏ này có phải là một ngôn ngữ lập trình 
{\em đầy đủ} hay không, có nghĩa là dùng nó có thể diễn giải được mọi 
bài toán hay không. Bất kì chương trình máy tính nào cũng có thể được
viết lại chỉ dùng những đặc điểm ngôn ngữ mà chúng ta đã xét đến 
(thực ra, bạn cần thêm một số lệnh để điều khiển các thiết bị như
bàn phím, chuột, ổ đĩa, v.v..., nhưng đó là tất cả những điều cần thiết).

Việc chứng minh nhận định đó là một bài toán khó, lần đầu được Alan
Turing đưa ra.\footnote{Turing là một trong những nhà khoa học máy tính đầu tiên
(có người cho rằng ông là một nhà toán học, song cũng có nhiều nhà 
khoa học máy tính thời sơ khai bấy giờ xuất thân từ toán học).} Tương
ứng với bài toán này là "luận án Turing". Để tìm hiểu cặn kẽ về luận án
Turing, bạn nên đọc quyển sách {\em Introduction to the
Theory of Computation} (tạm dịch: ``Nhập môn lí thuyết tính toán'') 
của Michael Sipser.

Để cụ thể hoá tác dụng của những kiến thức lập trình mà bạn vừa được học,
chúng ta hãy cùng lập một số hàm toán học theo cách đệ quy. Một định
nghĩa đệ quy giống như việc định nghĩa vòng quanh; điểm tương đồng là
trong phần định nghĩa lại có tham chiếu đến sự vật được định nghĩa. Nhưng
cách định nghĩa vòng quanh thực sự thì không mấy có tác dụng:

\begin{description}

\item[frabjous:] Một tính từ được dùng để miêu tả một sự vật frabjous.

\end{description}

\index{frabjous}
\index{định nghĩa!vòng quanh}
\index{vòng quanh (định nghĩa)}

Bạn hẳn sẽ bực mình khi thấy một định nghĩa kiểu như vậy trong cuốn 
từ điển. Ngược lại, khi bạn xem định nghĩa về giai thừa (được kí hiệu bằng
dấu $!$) trong toan học, có thể bạn sẽ thấy:

\vspace{-0.35in}
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n (n-1)!
\end{eqnarray*}
\vspace{-0.25in}

Định nghĩa này phát biểu rằng giai thừa của 0 là 1, và giai thừa của
bất kì một giá trị nào khác, $n$, thì bằng $n$ nhân với giai thừa của $n-1$.

Theo đó, $3!$ bằng 3 nhân với $2!$, vốn lại bằng 2 nhân với $1!$, vốn bằng
1 nhân với $0!$. Gộp tất cả lại, ta có $3!$ bằng 3 nhân 2 nhân 1 nhân 1,
tức là bằng 6.

\index{giai thừa (hàm)}
\index{hàm!giai thừa}
\index{định nghĩa đệ quy}

Nếu bạn có thể phát biểu một định nghĩa có tính đệ quy cho một 
hàm nào đó thì bạn cũng có thể viết một chương trình Python để 
tính nó. Bước đầu tiên là xác định các tham số. Trong trường hợp này
rõ ràng {\tt factorial} nhận vào một số nguyên:

\beforeverb
\begin{verbatim}
def factorial(n):
\end{verbatim}
\afterverb
%
Nếu tham số bằng 0, chúng ta chỉ cần trả lại giá trị 1:

\beforeverb
\begin{verbatim}
def factorial(n):
    if n == 0:
        return 1
\end{verbatim}
\afterverb
%
Nếu điều đó không xảy ra (đây chính là phần hay nhất), chúng ta 
thực hiện lời gọi đệ quy để tính giai thừa của $n-1$ và sau đó nhân nó
với $n$:

\beforeverb
\begin{verbatim}
def factorial(n):
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result
\end{verbatim}
\afterverb
%
Luồng thực hiện của chương trình này cũng giống như của chương trình
{\tt countdown} trong Mục~\ref{recursion}.  Nếu ta gọi {\tt factorial}
với giá trị 3:

Vì 3 khác 0 nên ta chọn nhánh thứ hai và tính giai thừa của {\tt n-1}...

\begin{quote}
Vì 2 khác 0 nên ta chọn nhánh thứ hai và tính giai thừa của {\tt n-1}...

  \begin{quote}
  Vì 1 khác 0 nên ta chọn nhánh thứ hai và tính giai thừa của {\tt n-1}...

    \begin{quote}
    Vì 0 {\em bằng} 0 nên ta chọn nhánh thứ nhất và trả lại giá trị 1
    và không gọi đệ quy thêm lần nào nữa.
    \end{quote}

  Giá trị được trả về, 1, được nhân với $n$, vốn bằng 1, và kết quả 
  được trả lại.
  \end{quote}

Giá trị được trả về (1) được nhân với $n$, vốn bằng 2, và kết quả 
được trả lại.
\end{quote}

Giá trị được trả về (2) được nhân với $n$, vốn bằng 3, và kết quả, 6
trở thành giá trị trả về của hàm ứng với lúc bắt đầu gọi đệ quy.

\index{biểu đồ ngăn xếp}

Sau đây là nội dung của biểu đồ ngăn xếp khi một loạt các hàm được gọi:

\vspace{0.1in}
\beforefig
\centerline{\includegraphics{figs/stack3.eps}}
\afterfig
\vspace{0.1in}

Các giá trị trả lại như ở đây được chuyển về ngăn xếp. Ở mỗi khung, giá trị
trả lại chính là giá trị của {\tt result}, vốn là tích của {\tt n} và {\tt recurse}.

\index{khung}

Ở khung cuối cùng, các biến địa phương {\tt recurse} và {\tt result} đều 
không tồn tại, vì nhánh tạo ra chúng không được thực hiện.


\section{Niềm tin}
\index{đệ quy}
\index{niềm tin}

Việc dõi theo luồng thực hiện của chương trình là một cách đọc
mã lệnh, nhưng bạn sẽ nhanh chóng lạc vào mê cung. Một cách làm
khác mà tôi gọi là ``niềm tin'' như sau. Khi bạn dò đến một lời gọi
hàm, thay vì việc đi theo luồng thực hiện, hãy {\em coi như} là 
hàm đó hoạt động tốt và trả lại kết quả đúng.

Thật ra, bạn đã từng có ``niềm tin'' này khi dùng các hàm dựng sẵn.
Mỗi khi gọi {\tt math.cos} hay {\tt math.exp}, bạn không kiểm tra
nội dung bên trong các hàm này. Bạn chỉ việc giả sử rằng chúng chạy được 
vì những người lập trình ra các hàm đó đều giỏi.

Cũng như vậy khi bạn gọi các hàm riêng của mình. Chẳng hạn, trong 
Mục~\ref{boolean}, chúng ta đã viết một hàm tên là \verb"is_divisible"
để xác định xem một số có chia hết cho một số khác không. Một khi
chúng ta tự thuyết phục rằng hàm này đã viết đúng---bằng cách kiểm
tra và thử mã lệnh---chúng ta có thể sử dụng hàm mà không cần
phải xem lại phần thân hàm nữa.

\index{kiểm thử!niềm tin}

Điều tương tự cũng đúng với các chương trình đệ quy. Khi bạn đến điểm 
gọi đệ quy, thay vì đi theo luồng thực hiện, bạn cần phải coi rằng
lời gọi đệ quy hoạt động tốt (tức là cho kết quả đúng) và sau đó tự hỏi
mình ``Giả dụ như ta đã tìm được giai thừa của $n-1$, liệu ta có tính
được giai thừa của $n$ không?'' Trong trường hợp này, rõ ràng là ta
sẽ tính được, bằng cách nhân với $n$.

Dĩ nhiên là sẽ có chút kì lạ trong việc ta giả sử rằng hàm hoạt động tốt 
khi chưa viết xong nó, nhưng chính vì vậy mà ta gọi đó là niềm tin!


\section{Thêm một ví dụ}
\label{one more example}

\index{fibonacci (hàm)}
\index{hàm!fibonacci}

Sau {\tt factorial}, một ví dụ thông dụng khác về hàm toán học
được định nghĩa theo cách đệ quy là {\tt fibonacci}. Hàm này 
được xác định như sau:
\footnote{Xem 
  \url{vi.wikipedia.org/wiki/Số_Fibonacci}.}

\vspace{-0.25in}
\begin{eqnarray*}
&& \mathrm{fibonacci}(0) = 0 \\
&& \mathrm{fibonacci}(1) = 1 \\
&& \mathrm{fibonacci}(n) = \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2);
\end{eqnarray*}
%
Theo ngôn ngữ của Python, nó có dạng:

\beforeverb
\begin{verbatim}
def fibonacci (n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
\end{verbatim}
\afterverb
%
Nếu bạn thử gắng theo luồng thực hiện ở đây, ngay cả với các
giá trị nhỏ của $n$, bạn sẽ đau đầu ngay. Nhưng bằng 
niềm tin, nếu bạn coi rằng cả hai lời gọi đệ quy đều hoạt động
tốt, thì rõ ràng bạn sẽ thu được kết quả đúng khi cộng chúng
lại với nhau.

\index{luồng thực hiện}


\section{Kiểm tra kiểu}
\label{guardian}

\index{kiểm tra kiểu}
\index{kiểm tra lỗi}
\index{factorial function}

Điều gì sẽ xảy ra nếu ta gọi {\tt factorial} với đối số bằng 1.5?

\index{RuntimeError}

\beforeverb
\begin{verbatim}
>>> factorial(1.5)
RuntimeError: Maximum recursion depth exceeded
\end{verbatim}
\afterverb
%
Dường như đó là đệ quy vô hạn. Nhưng sao có thể xảy ra điều này?
Có một trường hợp cơ bản---khi {\tt n == 0}.  Nhưng nếu {\tt n} 
không phải là số nguyên, chúng ta có thể {\em lỡ mất} trường hợp
cơ bản và đệ quy diễn ra mãi mãi.

\index{vô hạn (đệ quy)}
\index{đệ quy!vô hạn}

Ở lời gọi đệ quy thứ nhất, giá trị của {\tt n} bằng 0.5.
Ở lần tiếp theo, {\tt n} bằng $-$0.5. Từ đó, nó ngày càng nhỏ hơn 
(càng âm), nhưng sẽ không bao giờ bằng được 0.

Chúng ta có hai sự lựa chọn. Một là thử khái quát hoá hàm {\tt factorial}
để làm việc được với các số có phần thập phân, hoặc ta có thể để {\tt
  factorial} kiểm tra kiểu đối số của nó. Lựa chọn thứ nhất gắn với
việc gọi hàm gamma\footnote{Xem
  \url{wikipedia.org/wiki/Gamma_function}.} và nó phần nào đã vượt ra 
ngoài phạm vi quyên sách này. Vì vậy ta sẽ xét đến cách thứ hai.

\index{hàm gamma}

Ta có thể dùng hàm dựng sẵn {\tt isinstance} để thẩm định kiểu
của đối số. Khi đã dùng nó rồi, có thể khẳng định rằng đối số là
số dương:

\index{isinstance (hàm)}
\index{hàm!isinstance}

\beforeverb
\begin{verbatim}
def factorial (n):
    if not isinstance(n, int):
        print 'Factorial chỉ được định nghĩa cho số nguyên.'
        return None
    elif n < 0:
        print 'Factorial chỉ được định nghĩa cho số nguyên dương.'
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
\end{verbatim}
\afterverb
%
Trường hợp cơ bản thứ nhất xử lí các số không nguyên;
trường hợp thứ hai bắt lỗi các số nguyên âm. Trong cả hai 
trường hợp, chương trinh đều in ra thông báo lỗi và trả về
{\tt None} để biểu thị rằng có điều gì sai đã xảy ra:

\beforeverb
\begin{verbatim}
>>> factorial('fred')
Factorial chỉ được định nghĩa cho số nguyên.
None
>>> factorial(-2)
Factorial chỉ được định nghĩa cho số nguyên dương.
None
\end{verbatim}
\afterverb
%
Nếu vượt qua được cả hai lần kiểm tra, thi $n$ chắc chắn là
một số nguyên dương, và ta có thể chứng minh rằng lời gọi
đệ quy sẽ kết thúc.

\index{chốt bảo vệ (dạng lập trình)}
\index{dạng lập trình!chốt bảo vệ}

Chương trình này minh hoạ cho một dạng lập trình đôi khi được gọi là 
{\bf chốt bảo vệ}. Hai lệnh điều kiện đầu có vai trò bảo vệ đoạn mã lệnh
tiếp theo khỏi những giá trị có thể gây ra lỗi. Những chốt bảo vệ này
giúp ta chứng minh được tính đúng đắn của mã lệnh.


\section{Gỡ lỗi}
\label{factdebug}

\index{gỡ lỗi}

Việc chia nhở một chương trình lớn thành những hàm con tự nó đã tạo ra
những điểm kiểm soát để gỡ lỗi. Nếu một hàm không hoạt động, 
có thể có ba khả năng cần xét đến:

\begin{itemize}

\item Các đối số mà hàm nhận vào có vấn đề; một điều kiện đầu 
bị vi phạm.

\item Bản thân hàm có vấn đề; một trạng thái sau bị vi phạm.

\item Giá trị trả lại hoặc cách dùng giá trị này có vấn đề.

\end{itemize}

Để loại trừ khả năng thứ nhất, bạn có thể thêm vào một câu lệnh {\tt print}
tại điểm đầu của hàm để hiển thị các giá trị của đối số (và có thể cả kiểu
của chúng nữa). Hoặc bạn có thể viết các đoạn mã kiểm tra những điều
kiện đầu này một cách tường minh.

\index{điều kiện đầu}
\index{trạng thái cuối}

Nếu các tham số có vẻ tốt, hãy thêm một lệnh {\tt print} vào trước mỗi
lệnh {\tt return} để hiển thị các giá trị được trả lại. Nếu có thể, hãy kiểm
tra các kết quả theo cách thủ công. Cân nhắc việc gọi hàm với các giá trị
mà ta dễ dàng kiểm tra kết quả (như ở Mục~\ref{phát triển tăng dần}).

Nếu hàm số dường như hoạt động tốt, hãy xem lời gọi hàm để chắc rằng
giá trị trả lại được dùng và dùng đúng.

\index{luồng thực hiện}

Việc thêm các lệnh print vào đầu và cuối một hàm có thể giúp cho
luông thực hiện được rõ ràng hơn. Chẳng hạn, sau đây là một dạng của
hàm {\tt factorial} với các lệnh print.

\beforeverb
\begin{verbatim}
def factorial(n):
    space = ' ' * (4 * n)
    print space, 'giai thừa', n
    if n == 0:
        print space, 'trả lại 1'
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        print space, 'trả lại', result
        return result
\end{verbatim}
\afterverb
%
{\tt space} là một chuỗi các kí tự trắng để điều khiển
mức độ thụt đầu dòng của chữ cần in ra. Sau đây là 
kết quả của {\tt factorial(5)} :

\beforeverb
\begin{verbatim}
                     giai thừa 5
                 giai thừa 4
             giai thừa 3
         giai thừa 2
     giai thừa 1
 giai thừa 0
 trả lại 1
     trả lại 1
         trả lại 2
             trả lại 6
                 trả lại 24
                     trả lại 120
\end{verbatim}
\afterverb
%
Kiểu in kết quả này có thể sẽ rất tốt nếu bạn bị lẫn khi tìm luồng 
thực hiện. Để dựng các ``dàn giáo'' một cách hiệu quả cũng cần chút
thời gian, nhưng thêm dàn giáo có thể giúp giảm thiểu việc gỡ lỗi.

\section{Thuật ngữ}

\begin{description}

\item[biến tạm thời:]  Một biến dùng để lưu một giá trị trung gian 
trong phép tính phức tạp.
\index{tạm thời (biến)}
\index{biến!tạm thời}

\item[đoạn mã chết:]  Phần chương trình không bao giờ được thực hiện,
thường là do nó xuất hiện sau một câu lệnh {\tt return}.
\index{đoạn mã chết}

\item[{\tt None}:]  Một giá trị đặc biệt được trả về từ các hàm không 
chứa câu lệnh return hoặc một câu lệnh return mà không kèm theo 
đối số.
\index{None (giá trị đặc biệt)}
\index{giá trị đặc biệt!None}

\item[phát triển tăng dần:]  Một kế hoạch phát triển chương trình
trong đó tránh gỡ lỗi bằng việc mỗi lúc chỉ thêm vào và kiểm thử một
đoạn mã lệnh ngắn.
\index{phát triển tăng dần}

\item[dàn giáo:]  Mã lệnh được dùng trong giai đoạn phát triển chương
trình nhưng bị bỏ đi ở phiên bản chương trình cuối.
\index{dàn giáo}

\item[chốt bảo vệ:]  Một dạng lập trình trong đó có dùng một câu lệnh
điều kiện để kiểm tra và xử lí các trường hợp có thể gây ra lỗi.
\index{chốt bảo vệ}
\index{dạng lập trình!chốt bảo vệ}

\end{description}


\section{Bài tập}

\begin{ex}
\index{biểu đồ ngăn xếp}

Vẽ biểu đồ ngăn xếp cho chương trình dưới đây. Chương trình
sẽ in ra cái gì?

\beforeverb
\begin{verbatim}
def b(z):
    prod = a(z, z)
    print z, prod
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    sum = x + y + z
    pow = b(sum)**2
    return pow

x = 1
y = x + 1
print c(x, y+3, x+y)
\end{verbatim}
\afterverb

\end{ex}


\begin{ex}
\index{Hàm Ackermann}
\index{hàm!ack}

Hàm Ackermann, $A(m, n)$, được định nghĩa là\footnote{Xem
  \url{vi.wikipedia.org/wiki/Hàm_số_Ackermann}.}:

\begin{eqnarray}
A(m, n) = \begin{cases} 
              n+1 & \mbox{nếu } m = 0 \\ 
        A(m-1, 1) & \mbox{nếu } m > 0 \mbox{ và } n = 0 \\ 
A(m-1, A(m, n-1)) & \mbox{nếu } m > 0 \mbox{ và } n > 0.
\end{cases} 
\end{eqnarray}
%
Viết một hàm có tên là {\tt ack} để tính hàm Ackermann. Sau đó
dùng hàm đã viết để tính {\tt ack(3, 4)}, kết quả đúng là 125.
Điều gì sẽ xảy ra với các giá trị {\tt m} và {\tt n} lớn hơn?

\end{ex}


\begin{ex}
\label{palindrome}

\index{từ đối xứng}

Một từ đối xứng là từ đọc xuôi ngược đều như nhau, chẳng hạn
``noon'' và ``redivider''. Theo cách đệ quy, một từ sẽ là đối xứng
nếu các chữ cái đầu và cuối là như nhau và phần giữa cũng là
một từ đối xứng.

Dưới đây là các hàm nhận vào một đối số chuỗi và trả lại
các chữ cái đầu, cuối và giữa:

\beforeverb
\begin{verbatim}
def first(word):
    return word[0]

def last(word):
    return word[-1]

def middle(word):
    return word[1:-1]
\end{verbatim}
\afterverb
%
Chúng ta sẽ xét bản chất của chúng trong Chương~\ref{strings}.

\begin{enumerate}

\item Hãy chép lại các hàm trên vào trong file có tên là {\tt palindrome.py}
và sau đó thử chúng. Điều gì sẽ xảy ra khi bạn gọi {\tt middle} với
một chuỗi chỉ có 2 chữ cái? 1 chữ cái? và chuỗi trống không có chữ
cái nào (được viết là \verb"''" )

\item Viết một hàm có tên là \verb"is_palindrome" nhận vào
một đối số chuỗi và trả lại {\tt True} nếu đó là một từ 
đối xứng và {\tt False} nếu không phải. Hãy nhớ rằng bạn
có thể dùng hàm dựng sẵn {\tt len} để biết độ dài của chuỗi.

\end{enumerate}

\end{ex}

\begin{ex}
Một số, $a$, là lũy thừa của $b$ nếu nó chia hết cho $b$ và 
$a/b$ cũng là một lũy thừa của $b$.  Hãy viết một hàm có tên là 
\verb"is_power" nhận vào các đối số {\tt a} và {\tt b}
rồi trả lại {\tt True} nếu {\tt a} là lũy thừa của {\tt b}.
\end{ex}


\begin{ex}

\index{ước số chung lớn nhất (GCD)}
\index{GCD (ước số chung lớn nhất)}

Ước số chung lớn nhất (GCD, greatest common divisor) của $a$ và $b$ 
là số lớn nhất mà cả $a$ và $b$ đều chia hết cho nó.\footnote{Bài tập này
dựa theo một ví dụ từ cuốn sách {\em Structure and
    Interpretation of Computer Programs} của Abelson and Sussman.}

Một cách tìm GCD của hai số là thuật toán Euclid, vốn dựa trên
nhận xét rằng nếu như $r$ là số dư của phép chia $a$ cho $b$, thì
$gcd(a, b) = gcd(b, r)$. Với trường hợp cơ bản, ta có thể coi $gcd(a, 0) = a$.

\index{Euclid (thuật toán)}
\index{thuật toán!Euclid}

Hãy viết một hàm có tên 
\verb"gcd" nhận vào hai tham số {\tt a} và {\tt b}, sau đó
trả lại ước số chung lớn nhất của chúng. Nếu bạn cần gợi ý,
hãy xem \url{http://vi.wikipedia.org/wiki/Thu%E1%BA%ADt_to%C3%A1n_Euclid}.

\end{ex}


\chapter{Lặp}
\index{iteration}


\section{Phép gán nhiều lần}

\index{gán}
\index{câu lệnh!gán}
\index{gán nhiều lần}

Có thể bạn đã phát hiện thấy rằng, việc gán nhiều giá trị
vào cùng một biến là điều hợp lệ. Một phép gán mới làm cho
biến hiện tại tham chiếu đến một giá trị mới (và bỏ tham 
chiếu đến giá trị cũ).

\beforeverb
\begin{verbatim}
bruce = 5
print bruce,
bruce = 7
print bruce
\end{verbatim}
\afterverb
%
Kết quả của chương trình này là {\tt 5 7}, vì lần đầu tiên khi 
{\tt bruce} được in ra, giá trị của nó là 5, và đến lần thứ hai,
giá trị là 7.  Dấu phẩy đặt ở cuối câu lệnh {\tt print} thứ nhất
ngăn cản việc xuống dòng, và đáp số của hai lần tính toán đều
xuât hiện trên cùng một dòng.

\index{newline}

Sơ đồ trạng thái sau cho thấy cơ chế của một phép {\bf gán nhiều lần}:

\index{trạng thái (sơ đồ)}
\index{sơ đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/assign2.eps}}
\afterfig

Trong việc gán nhiều lần, ta cần đặc biệt lưu ý để phân biệt giữa một
toán tử gán và một đẳng thức. Vì Python dùng dấu bằng ({\tt =}) 
cho một lệnh gán, ta có thể bị cám dỗ bởi ý nghĩ rằng một câu lệnh 
kiểu như  {\tt a = b} là một đẳng thức. Thực ra thì không phải vậy!

\index{đẳng thức và lệnh gán}

Trước hết, đẳng thức là một hệ thức đối xứng còn lệnh gán thì không phải.
Chẳng hạn, trong toán học, nếu $a = 7$ thì $7 = a$.  Nhưng trong Python, 
câu lệnh {\tt a = 7} thì hợp lệ còn {\tt 7 = a} thì không.

Hơn nữa, trong toán học, một đẳng thức thì có thể luôn đúng hoặc luôn sai.
Nếu bây giờ $a = b$ thì về sau này $a$ sẽ luôn bằng $b$. Trong Python,
một lệnh gán có thể làm cho hai biến bằng nhau, nhưng có thể sẽ không
bằng nhau mãi:

\beforeverb
\begin{verbatim}
a = 5
b = a    # bây giờ a và b bằng nhau
a = 3    # a và b không còn bằng nhau 
\end{verbatim}
\afterverb
%
Dòng lệnh thứ ba thay đổi giá trị của {\tt a} nhưng không thay đổi
giá trị của {\tt b}, vì vậy chúng không còn bằng nhau.

Mặc dù việc gán nhiều lần thường có ích, song bạn cần cẩn thận khi
sử dụng chúng. Việc giá trị của các biến thay đổi thường xuyên có thể
làm cho mã lệnh trở nên khó đọc và khó gỡ lỗi.


\section{Cập nhật các biến}
\label{update}

\index{cập nhật}
\index{biến!cập nhật}

Một trong các dạng thông dụng nhất của gán nhiều lần là một lệnh
{\bf cập nhật}, trong đó giá trị mới của biến phụ thuộc vào giá trị
cũ.

\beforeverb
\begin{verbatim}
x = x+1
\end{verbatim}
\afterverb
%
Lệnh này có nghĩa là ``lấy giá trị hiện thời của {\tt x}, cộng thêm một,
và cập nhật {\tt x} với giá trị mới.''

Nếu bạn thử cập nhật một biến mà hiện không tồn tại, bạn sẽ bị 
báo lỗi, vì Python luôn ước lượng vế phải trước khi gán một
giá trị cho {\tt x}:

\beforeverb
\begin{verbatim}
>>> x = x+1
NameError: name 'x' is not defined
\end{verbatim}
\afterverb
%
Trước khi có thể cập nhật một biến, bạn cần phải {\bf khởi tạo}
nó, thường là bằng một lệnh gán:

\index{khởi tạo (trước khi cập nhật)}

\beforeverb
\begin{verbatim}
>>> x = 0
>>> x = x+1
\end{verbatim}
\afterverb
%
Việc cập nhật một biến bằng cách cộng thêm 1 được gọi là 
{\bf tăng}; còn trừ đi 1 được gọi là {\bf giảm}.

\index{tăng}
\index{giảm}




\section{Lệnh {\tt while}}

\index{lệnh!while}
\index{while (vòng lặp)}
\index{vòng lặp!while}
\index{lặp}

Máy tính thường được dùng để tự động hoá các tác vụ có tính chất lặp
lại. Việc lặp lại những thao tác giống hệt hoặc tương tự nhau mà không
mắc phải lỗi chính là ``sở trường'' của máy tính đồng thời là việc mà
con người làm rất dở.

Ta đã thấy hai chương trình, {\tt countdown} và \verb"print_n", trong
đó dùng đệ quy để thực hiện thao tác lặp lại, hay còn gọi  là {\bf
lặp}.  Vì lặp là một thao tác thường dùng, nên Python có cung cấp một
số đặc điểm ngôn ngữ giúp cho việc thực hiện được dễ dàng. Một trong 
số đó là lệnh {\tt for} mà chúng ta đã gặp trong Mục~\ref{repetition}.
Chúng ta sẽ trở lại đó vào một dịp khác.

Một cách khác là dùng lệnh {\tt while}.  Sau đây là một phiên bản của {\tt
countdown} có dùng lệnh {\tt while}:

\beforeverb
\begin{verbatim}
def countdown(n):
    while n > 0:
        print n
        n = n-1
    print 'Bùm!'
\end{verbatim}
\afterverb
%
Bạn gần như có thể đọc lệnh {\tt while} giống cách đọc tiếng Anh:
``Khi {\tt n} còn lớn hơn 0, hãy hiển thị giá trị của {\tt n} 
rồi giảm giá trị của {\tt n} đi 1.  Khi đạt đến 0, hãy hiển thị chữ {\tt Bùm!}''

\index{luồng thực hiện}

Nói một cách hệ thống hơn, luồng thực hiện của câu lệnh {\tt while} như sau:

\begin{enumerate}

\item Ước lượng điều kiện, trả lại {\tt True} hoặc {\tt False}.

\item Nếu điều kiện không thoả mãn, thoát khỏi khối lệnh {\tt while} 
rồi thực hiện câu lệnh kế tiếp.

\item Nếu điều kiện được thoả mãn, thực hiện phần thần và quay trở lại
bước 1.

\end{enumerate}

Dạng luồng thực hiện này được gọi là một {\bf vòng lặp} vì sau bước thứ 3
quay trở về bước đầu tiên.

\index{điều kiện}
\index{vòng lặp}
\index{phần thân}

Phần thân của vòng lặp sẽ thay đổi giá trị của một hoặc nhiều biến sao cho 
cuối cùng thì điều kiện sẽ không thoả mãn và vòng lặp kết thúc. Còn nếu 
không thì vòng lặp sẽ tiếp diễn mãi mãi, và được gọi là một
{\bf vòng lặp vô hạn}. Một câu chuyện đùa về nhà khoa học máy tính xuất
phát từ việc quan sát thấy dòng chữ trên hướng dẫn sử dụng lọ dầu gội đầu:
``Lather, rinse, repeat,'' (Xoa dầu, xối nước và lặp lại) là một vòng lặp vô hạn.

\index{vô hạn (vòng lặp)}
\index{vòng lặp!vô hạn}

Trong trường hợp của {\tt countdown}, chúng ta có thể chứng tỏ rằng
vòng lặp sẽ kết thúc vì biết rằng giá trị của {\tt n} là hữu hạn, và mỗi
khi lặp lị thì giá trị của {\tt n} sẽ nhỏ đi. Vì vậy cuối cùng nó sẽ phải
trở về 0. Với các trường hợp khác, có thể sẽ không dễ chứng tỏ điều đó:

\beforeverb
\begin{verbatim}
def sequence(n):
    while n != 1:
        print n,
        if n%2 == 0:        # n chẵn
            n = n/2
        else:               # n lẻ 
            n = n*3+1
\end{verbatim}
\afterverb
%

Điều kện cho vòng lặp này là {\tt n != 1}, vì vậy vòng lặp sẽ tiếp tục
đến khi {\tt n} bằng {\tt 1}, khi đó điều kiện sẽ bị vi phạm.

Mỗi lần lặp, chương trình sẽ in ra giá trị của {\tt n} và kiểm tra xem
nó là chẵn hay lẻ. Nếu là chẵn, {\tt n} được đem chia cho 2. Nếu lẻ 
giá trị của {\tt n} được thay thế bởi {\tt n*3+1}. Chẳng hạn, nếu tham
biến được truyền cho {\tt sequence} là 3, thì chuỗi số thu được sẽ là
 3, 10, 5, 16, 8, 4, 2, 1.

Vì {\tt n} đôi khi tăng và đôi khi giảm, nên không có một chứng minh
rõ ràng nào cho thấy {\tt n} sẽ đạt được giá trị 1, hay là chương trình
kết thúc. Với một số giá trị riêng của {\tt n}, ta có thể chứng minh sự
kết thúc này. Chẳng hạn, nếu giá trị ban đầu là một số lũy thừa của 
2 thì giá trị của {\tt n} sẽ là chẵn trong mỗi lần lặp và đến khi nó đạt
bằng 1. Ở ví dụ trước đây, chuỗi cũng kết thúc theo cách tương tự kể
từ số 16.

\index{giả thiết Collatz}

Câu hỏi được đặt ra là liệu ta có thể chứng minh rằng chương trình sẽ
kết thúc với {\em mọi giá trị dương} của {\tt n} hay không. Cho đến giờ\footnote{Xem
  \url{wikipedia.org/wiki/Collatz_conjecture}.}, chưa ai có đủ khả năng
chứng minh {\em hoặc} bác bỏ nó!

\begin{ex}
Viết lại hàm \verb"print_n" ở 
Mục~\ref{recursion} dùng cách lặp thay vì đệ quy.
\end{ex}


\section{{\tt break}}
\index{break (câu lệnh)}
\index{câu lệnh!break}

Đôi khi bạn chỉ biết được rằng đã đến lúc kết thúc vòng lặp trong khi
đang thực hiện một nửa phần thân của vòng lặp đó. Trường hợp này
bạn có thể dùng câu lệnh {\tt break} để thoát khỏi vòng lặp.

Chẳng hạn, giả sử như bạn muốn nhận dữ liệu nhập vào bởi người dùng
cho đến lúc họ gõ {\tt xong}. Bạn có thể viết như sau:

\beforeverb
\begin{verbatim}
while True:
    line = raw_input('> ')
    if line == 'xong':
        break
    print line

print 'Xong!'
\end{verbatim}
\afterverb
%
Điều kiện lặp là {\tt True}, tức là luôn đúng, vì vậy vòng lặp tiếp diễn
đến khi nó gặp phải lệnh break.

Ở mỗi lần lặp, nó nhắc người dùng bằng cách hiện ra kí hiệu '>'. 
Nếu người dùng gõ vào chữ {\tt xong}, lệnh {\tt break} sẽ giúp
thoát khỏi vòng lặp. Còn không thì chương trình sẽ hiện lại bất cứ
dòng chữ gì người dùng đã nhập vào, rồi trở lại đầu vòng lặp. Sau
đây là một lần chạy thử:

\beforeverb
\begin{verbatim}
> chưa xong
chưa xong
> xong
Xong!
\end{verbatim}
\afterverb
%
Cách viết vòng lặp {\tt while} như thế này rất thường gặp vì bạn có thể
kiểm tra điều kiện ở bất kì nơi nào trong vòng lặp (chứ không riêng
ở đầu vòng lặp) và có thể khẳng định điều kiện dừng lặp (``hãy dừng
ngay khi điều này xảy ra'') thay vì chỉ nói một cách phủ định (``cứ tiếp
tục đến khi điều đó xảy ra.'').

\section{Căn bậc hai}

\index{căn bậc hai}

Các vòng lặp thường được dùng trong những chương trình ở đó
có tính các trị số bằng cách bắt đầu với một ước lượng rồi liên lục
tính lặp để có được xấp xỉ tốt hơn.

\index{Phương pháp Newton}

Chẳng hạn, một cách tính căn bậc hai là phương pháp Newton. Giả sử
bạn muốn tính căn bậc hai của $a$. Nếu bạn bắt đầu với một giá trị
ước lượng bất kì, $x$, bạn có thể tính ra một ước lượng khác
tốt hơn theo công thức:

\[ y = \frac{x + a/x}{2} \]
%
Chẳng hạn, nếu $a$ bằng 4 và $x$ bằng 3:

\beforeverb
\begin{verbatim}
>>> a = 4.0
>>> x = 3.0
>>> y = (x + a/x) / 2
>>> print y
2.16666666667
\end{verbatim}
\afterverb
%
Tức là giá trị mới đã sát hơn kết quả đúng ($\sqrt{4} = 2$). Nếu ta
tiếp tục lặp lại quá trình này bằng giá trị ước lượng mới, kết quả
thu được còn gần đúng nữa:

\beforeverb
\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00641025641
\end{verbatim}
\afterverb
%
Sau một số lần tính (cập nhật), kết quả ước lượng sẽ gần như chính xác:

\index{cập nhật}

\beforeverb
\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00001024003
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00000000003
\end{verbatim}
\afterverb
%
Nhìn chung ta không thể nói trước rằng sẽ cần tính lặp bao nhiêu
lần để thu được kết quả đúng, nhưng ta biết rằng khi ta tiến đến
giá trị đúng thì các giá trị ước lượng tìm được sẽ không còn dao động
nữa:

\beforeverb
\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.0
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.0
\end{verbatim}
\afterverb
%
Khi {\tt y == x}, ta có thể dừng lại. Sau đây là một vòng lặp
bắt đầu bằng một giá trị ước lượng, {\tt x}, và sau đó điều chỉnh
nó đến khi giá trị này ngừng dao động:

\beforeverb
\begin{verbatim}
while True:
    print x
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
\end{verbatim}
\afterverb
%
Với phần lớn các giá trị của {\tt a} cách làm này khá hiệu quả,
nhưng nói chung việc kiểm tra điều kiện bằng nhau giữa hai số
thập phân {\tt float} là nguy hiểm. Các giá trị số có phần thập phân
chỉ gần đúng: hầu hết các số hữu tỉ, như $1/3$, và vô tỉ, như
$\sqrt{2}$, đều không thể biểu diễn được chính xác dưới dạng {\tt float}.

\index{dấu phẩy động}
\index{epsilon}

Thay vì kiểm tra xem {\tt x} và {\tt y} có đúng bằng nhau không, cách
làm an toàn hơn là dùng hàm có sẵn {\tt abs} để tính giá trị tuyệt đối,
hay độ lớn của hiệu giữa hai số này:

\beforeverb
\begin{verbatim}
    if abs(y-x) < epsilon:
        break
\end{verbatim}
\afterverb
%
trong đó \verb"epsilon" nhận một giá trị như {\tt 0.0000001} tùy thuộc
vào yêu cầu độ chính xác mà ta cần là bao nhiêu.

\begin{ex}
\label{square_root}
\index{gói}

Hãy ``gói'' vòng lặp này vào trong một hàm có tên \verb"square_root"
nhận {\tt a} làm tham số, chọn một giá trị hợp lý của {\tt x}, và sau đó
trả lại ước lượng xấp xỉ căn bậc hai của {\tt a}.
\end{ex}


\section{Thuật toán}
\index{thuật toán}

Phương pháp Newton là ví dụ cho một {\bf thuật toán}: đó là một
quá trình, một cơ chế để giải một lớp các bài toán (trong trường hợp
này là bài toán tính căn bậc hai).

Thật không dễ định nghĩa một thuật toán. Có lẽ để tiện hơn, ta sẽ
xét một thứ không phải là thuật toán. Khi bạn học cách nhân hai chữ 
số với nhau, có thể bạn đã thuộc lòng bảng cửu chương. Như vậy
bạn đã ghi nhớ được 100 kết quả phép tính riêng biệt. Những
kiến thức như vậy không phải là thuật toán.

Nhưng nếu ``lười biếng,'' bạn có thể dùng mẹo để tính nhẩm.
Chẳng hạn, để tìm tích số giữa $n$ và 9, bạn có thể viết
chữ số đầu là $n-1$ và chữ số sau là $10-n$. Mẹo này cho 
lời giải tổng quát với mọi phép tính giữa số có một chữ số với 9.
Đó chính là thuật toán!

\index{phép cộng có nhớ}
\index{phép trừ có nhớ}

Tương tự, kĩ thuật mà bạn đã được học như phép cộng / trừ có
nhớ, phép chia có nhớ đều là các thuật toán. Một trong những
thuộc tính của thuật toán là để thực hiện chúng thì không cần trí
thông minh. Đó là những quá trình trong đó gồm các bước nối tiếp
nhau dựa trên một số quy luật đơn giản.

Theo tôi, thật đáng ngạc nhiên là chúng ta lại dành quá nhiều thời 
gian ở trường để học cách thực thi các thuật toán mà về bản chất thì
chúng không có tính trí tuệ chút nào.

Trái lại, quá trình thiêt kế các thuật toán mới thú vị, đầy tính thử
thách về trí tuệ, và là phần trọng tâm của việc mà ta gọi là lập trình.

Có những việc mà chúng ta làm một cách tự nhiên, chẳng chút khó
khăn hay phải nghĩ ngợi gì, lại chính là những điều khó diễn giải thành
thuật toán nhất. Một ví dụ điển hình là việc hiểu ngôn ngữ tự nhiên.
Tất cả chúng ta đều có khả năng này, nhưng đến nay chưa ai giải thích
được là {\em bằng cách nào} mà chúng ta hiểu nó, ít nhất là giải thích
không cần dưới hình thức một thuật toán.


\section{Gỡ lỗi}

Khi bạn bắt đầu viết những chương trình lớn, bạn có thể sẽ phải dành
nhiều thời gian hơn để gỡ lỗi. Nhiều dòng mã lệnh đồng nghĩa với 
nhiều khả năng mắc lỗi và nhiều chỗ dễ phát sinh ra lỗi hơn.

\index{gỡ lỗi!bằng cách phân đôi}
\index{phân đôi (gỡ lỗi)}

Một cách cắt giảm thời gian gỡ lỗi là ``phân đôi''.
Chẳng hạn, nếu chương trình của bạn có 100 dòng lệnh và
nếu bạn cần kiểm tra lần lượt từng dòng một sẽ mất 100 bước.

Thay vì vậy, hãy thử chia đôi bài toán. Nhìn vào khu vực giữa của
chương trình, kiếm lấy một giá trị trung gian mà bạn có thể
kiểm tra được. Thêm vào một câu lệnh {\tt print} (hoặc là một
cách nào khác để tạo ra một hiệu ứng giúp ta kiểm tra) rồi chạy
chương trình.

Nếu lần kiểm tra ở điểm giữa này mà không đạt, thì chắc chắn 
nửa đầu chương trình sẽ chứa lỗi. Nếu đạt, thì lỗi nằm ở nửa sau
chương trình.

Mỗi khi kiểm tra như thế này, bạn đã chia nửa số dòng lệnh cần
thiết phải tìm kiếm. Ít nhất là vết mặt lý thuyết thì sau sáu bước 
(tức là ít hơn 100), bạn sẽ có thể giảm số dòng lệnh cần kiểm tra
xuống còn 1 đến 2 dòng mà thôi.

Trên thực tế, ``điểm giữa của chương trình'' thường không rõ ràng
và đôi khi ta không thể kiểm tra được ở đó. Vì vậy việc đếm số dòng và
tìm chính xác điểm giữa là vô nghĩa. Thay vào đó, hãy nghĩ đến
những chỗ trong chương trình mà có nhiều khả năng xảy ra lỗi và
những chỗ dễ dàng đặt kiểm tra. Sau đó chọn một chỗ kiểm tra mà
bạn nghĩ khả năng xảy ra lỗi trước và sau điểm đó là ngang nhau.


\section{Thuật ngữ}

\begin{description}

\item[phép gán nhiều lần:] Việc thực hiện hơn một lần gán giá trị cho
cùng một biến khi thực thi một chương trình.
\index{phép gán nhiều lần}

\item[cập nhật:] Một phép gán trong đó giá trị mới của biến phụ thuộc
vào giá trị cũ.
\index{cập nhật}

\item[khởi tạo:] Một phép gán gán trị ban đầu cho một biến mà sau này
sẽ được cập nhật.
\index{khởi tạo!biến}

\item[tăng:] Việc cập nhật bằng cách cộng thêm vào giá trị sẵn có của một biến
(thường là thêm 1).
\index{tăng}

\item[giảm:] Việc cập nhật bằng cách bớt đi giá trị sẵn có của một biến.
\index{giảm}

\item[lặp:] Việc thực hiện liên tục nhiều lần một nhóm các lệnh bằng cách gọi
hàm đệ quy hoặc một vòng lặp.
\index{lặp}

\item[vòng lặp vô hạn:] Một vòng lặp trong đó điều kiện kết thúc không bao giờ
được thỏa mãn.
\index{vòng lặp!vô hạn}

\end{description}


\section{Bài tập}

\begin{ex}

\index{thuật toán!căn bậc hai}

Để kiểm tra thuật toán căn bậc hai trong chương này, bạn có thể so sánh
nó với {\tt math.sqrt}.  Hãy viết một hàm có tên \verb"test_square_root"
để in ra một bảng như sau:

\beforeverb
\begin{verbatim}
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0

\end{verbatim}
\afterverb
%
Cột đâu tiên có chứa một số, $a$; cột thứ hai là căn bậc
hai của $a$ được tính bằng hàm ở Bài tập~\ref{square_root}; 
cột thứ ba là căn bậc hai được tính từ
{\tt math.sqrt}; cột thứ tư là giá trị tuyệt đối của chênh lệch giữa
hai kết quả tính được theo hai cách trên.
\end{ex}


\begin{ex}

\index{eval (hàm)}
\index{hàm!eval}

Hàm dựng sẵn {\tt eval} nhận vào một chuỗi và dùng trình thông
dịch Python để định giá trị của nó. Chẳng hạn:

\beforeverb
\begin{verbatim}
>>> eval('1 + 2 * 3')
7
>>> import math
>>> eval('math.sqrt(5)')
2.2360679774997898
>>> eval('type(math.pi)')
<type 'float'>
\end{verbatim}
\afterverb
%
Hãy viết một hàm tên là \verb"eval_loop" để lặp lại các thao tác
nhắc người dùng nhập vào chuỗi biểu thức, định giá trị nó
bằng {\tt eval}, và sau đó in ra kết quả.

Vòng lặp cần tiếp tục đến tận khi người dùng nhập vào \verb"'xong'", 
và kết thúc bằng việc trả lại giá trị của biểu thức được định giá trị
sau cùng.
\end{ex}

\begin{ex}

\index{Ramanujan, Srinivasa}

Nhà toán học xuất sắc Srinivasa Ramanujan đã tìm ra một chuỗi số
vô tận\footnote{See \url{wikipedia.org/wiki/Pi}.} có thể được dùng
để phát sinh ra một giá trị xấp xỉ cho số $\pi$:

\index{pi}

\[\frac{1}{\pi} = \frac{2\sqrt{2}}{9801} 
\sum^\infty_{k=0} \frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}} \]

Hãy viết một hàm tên là \verb"estimate_pi" dùng công thức này để
tính và trả lại giá trị xấp xỉ của $\pi$.  Hãy dùng một vòng lặp {\tt while}
để tính các số hạng trong tổng đến khi số hạng cuối cùng nhỏ hơn
{\tt 1e-15} (vốn là cách biểu diễn của Python cho $10^{-15}$).
Bạn có thể kiểm tra kết quả tính được bằng cách so sánh nó với {\tt math.pi}.

Bạn có thể tham khảo đáp án của tôi ở \url{thinkpython.com/code/pi.py}.
\end{ex}


\chapter{Chuỗi kí tự}
\label{chuỗi kí tự}


\section{Chuỗi là một danh sách có thứ tự}
\index{danh sách}
\index{kí tự}
\index{ngoặc vuông (toán tử)}
\index{toán tử!ngoặc vuông}

Chuỗi là một {\bf danh sách có thứ tự} hợp thành từ những kí tự riêng rẽ.
Bạn có thể truy cập đến từng kí tự một bằng cách dùng toán tử là cặp
ngoặc vuông:

\beforeverb
\begin{verbatim}
>>> fruit = 'banana'
>>> letter = fruit[1]
\end{verbatim}
\afterverb
%
Câu lệnh thứ hai nhằm chọn ra chữ cái có thứ tự 1 của {\tt
fruit} và gán nó cho {\tt letter}.  

\index{chỉ số}

Biểu thức nằm ở trong cặp ngoặc vuông được gọi là {\bf chỉ số}.
Chỉ số biểu thị cho kí tự mà bạn đang cần trong chuỗi (vì thế mà
nó có tên là ``chỉ số''). 

Nhưng đối với bạn kết quả thu được có thể không như mong đợi:

\beforeverb
\begin{verbatim}
>>> print letter
a
\end{verbatim}
\afterverb
%
Với hầu hết chúng ta thì chữ cái thứ nhất của \verb"'banana'" là {\tt b}
chứ không phải {\tt a}. Nhưng với nhà khoa học máy tính, chỉ số là độ
dời đi so với vị trí đầu của chuỗi; và chữ cái đầu tiên thì có độ dời bằng 0.

\beforeverb
\begin{verbatim}
>>> letter = fruit[0]
>>> print letter
b
\end{verbatim}
\afterverb
%
Như vậy {\tt b} là chữ cái thứ 0 của \verb"'banana'", {\tt a}
là chữ cái thứ 1, và {\tt n} là chữ cái thứ 2.

\index{chỉ số!bắt đầu từ 0}
\index{0, chỉ số đầu tiên}

Bạn có thể dùng bất kì biểu thức nào, bao gồm các biến và toán tử,
cho một chỉ số, nhưng cuối cùng giá trị của chỉ số phải là số nguyên.
Nếu không thì bạn sẽ gặp lỗi:

\index{chỉ số}
\index{biệt lệ!TypeError}
\index{TypeError}

\beforeverb
\begin{verbatim}
>>> letter = fruit[1.5]
TypeError: string indices must be integers
\end{verbatim}
\afterverb
%

\section{{\tt len}}

\index{len (hàm)}
\index{hàm!len}

{\tt len} là một hàm có sẵn để trả lại số kí tự trong một chuỗi:

\beforeverb
\begin{verbatim}
>>> fruit = 'banana'
>>> len(fruit)
6
\end{verbatim}
\afterverb
%
Để lấy chữ cái cuối cùng của một chuỗi, có thể là bạn đã từng thử đoạn
lệnh như sau:

\index{biệt lệ!IndexError}
\index{IndexError}

\beforeverb
\begin{verbatim}
>>> length = len(fruit)
>>> last = fruit[length]
IndexError: string index out of range
\end{verbatim}
\afterverb
%
Lí do xuất hiện lỗi {\tt IndexError} là vì không có chữ cái nào ở vị trí chỉ số 6
trong chuỗi {\tt'banana'}. Vì chúng ta tính chỉ số từ 0, nên sáu chữ cái sẽ được
đánh số từ 0 đến 5. Để có được chữ cái cuối cùng, bạn phải trừ bớt 
{\tt length} đi 1:

\beforeverb
\begin{verbatim}
>>> last = fruit[length-1]
>>> print last
a
\end{verbatim}
\afterverb
%
Một cách khác là bạn dùng chỉ số âm, nghĩa là đếm ngược từ điểm cuối của
chuỗi. Biểu thức {\tt fruit[-1]} cho ra chữ cái cuối cùng, {\tt fruit[-2]} cho
chữ cái áp chót, và cứ như vậy.

\index{chỉ số!âm}
\index{số âm (chỉ số)}


\section{Duyệt bằng một vòng lặp {\tt for}}
\label{for}

\index{duyệt}
\index{vòng lặp!duyệt}
\index{for (vòng lặp)}
\index{vòng lặp!for}
\index{câu lệnh!for}

Có nhiều công việc tính toán liên quan đến xử lí một chuỗi theo từ
kí tự một. Bắt đầu từ điểm đầu của chuỗi, từng chữ cái được lựa chọn,
một số thao tác được thực hiện đối với chữ cái đó, và công việc được
tiếp diễn cho các chữ cái còn lại đến hết chuỗi. Kiểu xử lí như thế này
được gọi là {\bf duyệt}. Để viết mã lệnh thực hiện việc duyệt, ta có thể
dùng vòng lặp {\tt while}:

\beforeverb
\begin{verbatim}
index = 0
while index < len(fruit):
    letter = fruit[index]
    print letter
    index = index + 1
\end{verbatim}
\afterverb
%
Vòng lặp này để duyệt chuỗi và hiển thị từng chữ cái trên một dòng riêng.
Điều kiện lặp là {\tt index < len(fruit)}, như vậy khi {\tt index} bằng với
chiều dài của chuỗi, điều kiện bị vi phạm, và phần thân của vòng lặp
không được thực hiện. Chữ cái cuối cùng được truy cập đến sẽ tương ứng
với chỉ số {\tt len(fruit)-1}, cũng là chữ cái cuối cùng của chuỗi.

\begin{ex}
Hãy viết một hàm nhận vào đối số là một chuỗi và hiển thị lần lượt
các chữ cái theo thứ tự ngược lại, mỗi chữ cái trên một dòng riêng.
\end{ex}

Một cách khác để thực hiện việc duyệt là dùng một vòng lặp {\tt for}:

\beforeverb
\begin{verbatim}
for char in fruit:
    print char
\end{verbatim}
\afterverb
%
Mỗi lần qua vòng lặp, kí tự tiếp theo của chuỗi được gán cho biến {\tt char}. 
Vòng lặp tiếp diễn đến khi không còn kí tự nào nữa.

\index{ghép nối}
\index{danh sách!abc}
\index{McCloskey, Robert}

Ví dụ tiếp sau đây minh hoạc cho cách dùng phép ghép nối (phép ``cộng'' chuỗi)
và một vòng lặp {\tt for} để tạo ra một danh sách abc (tức là theo đúng thứ tự của
bảng chữ cái). Trong cuốn sách của McCloskey, {\em Make
Way for Ducklings} (Dành đường cho vịt con), tên của các chú vịt con là Jack, Kack, Lack,
Mack, Nack, Ouack, Pack, and Quack.  Vòng lặp sau đây sẽ cho ra những cái tên theo
đúng thứ tự:

\beforeverb
\begin{verbatim}
prefixes = 'JKLMNOPQ'
suffix = 'ack'

for letter in prefixes:
    print letter + suffix
\end{verbatim}
\afterverb
%
Kết quả là

\beforeverb
\begin{verbatim}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{verbatim}
\afterverb
%
Dĩ nhiên là kết quả trên không hoàn toàn đúng vì ``Ouack'' và
``Quack'' đã bị viết chệch đi.

\begin{ex}
Hãy sửa lại chương trình để có kết quả đúng.
\end{ex}



\section{Lát cắt trong chuỗi}
\label{lát cắt}

\index{lát cắt (toán tử)}
\index{toán tử!lát cắt}
\index{chỉ số!lát cắt}
\index{chuỗi!lát cắt}
\index{lát cắt!chuỗi}

Một đoạn trong chuỗi được gọi là {\bf lát cắt}. Việc chọn một lát cắt cũng
giống như chọn một kí tự:

\beforeverb
\begin{verbatim}
>>> s = 'Monty Python'
>>> print s[0:5]
Monty
>>> print s[6:12]
Python
\end{verbatim}
\afterverb
%
Toán tử {\tt [n:m]} trả lại phần của chuỗi tính từ kí tự thứ n  
cho đến kí tự thứ m, trong đó bao gồm kí tự thứ n và không kể kí tự thứ m.
Điều này nghe được hợp lý lắm, nhưng nó sẽ giúp bạn hình dung được
vị trí của chỉ số là ở {\em giữa} các kí tự, như trong sơ đồ sau:

\beforefig
\centerline{\includegraphics{figs/banana.eps}}
\afterfig

Nếu bạn bỏ qua chỉ số thứ nhất (trước dấu hai chấm) thì lát cắt sẽ
bắt đầu ở ngay điểm đầu của chuỗi. Nếu bạn bỏ qua chỉ số thứ hai thì
lát cắt sẽ kết thúc ở điểm cuối của chuỗi:

\beforeverb
\begin{verbatim}
>>> fruit = 'banana'
>>> fruit[:3]
'ban'
>>> fruit[3:]
'ana'
\end{verbatim}
\afterverb
%
Nếu chỉ số thứ nhất lớn hơn hoặc bằng chỉ số thứ hai thì kết quả thu
được sẽ là một {\bf chuỗi trống}, được biểu thị bằng hai dấu nháy:

\index{dấu nháy}

\beforeverb
\begin{verbatim}
>>> fruit = 'banana'
>>> fruit[3:3]
''
\end{verbatim}
\afterverb
%
Một chuỗi trống không chứa kí tự nào và có độ dài bằng 0, nhưng
các đặc điểm khác của nó thì cũng tương tự như một chuỗi bất kì.

\begin{ex}
Biết rằng {\tt fruit} là một chuỗi, thì
{\tt fruit[:]} nghĩa là gì?

\index{sao chép!lát cắt}
\index{lát cắt!sao chép}

\end{ex}


\section{Chuỗi không thể bị thay đổi}
\index{tính thay đổi}
\index{tính không thay đổi}
\index{chuỗi!không thay đổi}

Bạn có thể muốn dùng toán tử {\tt []} bên vế trái của một lệnh gán,
với ý định thay đổi một kí tự trong chuỗi. Chẳng hạn:

\index{TypeError}
\index{biệt lệ!TypeError}

\beforeverb
\begin{verbatim}
>>> greeting = 'Hello, world!'
>>> greeting[0] = 'J'
TypeError: object does not support item assignment
\end{verbatim}
\afterverb
%

Đối tượng (``object'') ở trong trường hợp này chính là chuỗi, còn
phần tử (``item'') là kí tự mà bạn muốn gán. Tạm thời bây giờ ta
coi {\bf đối tượng} cũng giống như một giá trị, nhưng sẽ định nghĩa
lại sau. Một {\bf phần tử} là một trong số các giá trị có trong chuỗi.

\index{đối tượng}
\index{phần tử!gán}
\index{phép gán!phần tử}
\index{tính không thay đổi}

Lí do gây ra lỗi là ở chỗ các chuỗi đều {\bf không thể thay đổi}, 
có nghĩa rằng bạn không thể thay đổi một chuỗi hiện có. Việc
tốt nhất mà bạn có thể làm được là tạo ra một chuỗi mới như một
biến thể của chuỗi ban đầu:

\beforeverb
\begin{verbatim}
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> print new_greeting
Jello, world!
\end{verbatim}
\afterverb
%
Ví dụ này ghép nối một chữ cái mới ở vị trí thứ nhất với lát cát
của {\tt greeting}. Nó không có ảnh hưởng gì đến chuỗi ban đầu.

\index{ghép nối}


\section{Tìm kiếm}
\label{find}

Hàm sau đây nhằm mục đích gì?

\index{tìm kiếm (hàm)}
\index{hàm!tìm kiếm}

\beforeverb
\begin{verbatim}
def find(word, letter):
    index = 0
    while index < len(word):
        if word[index] == letter:
            return index
        index = index + 1
    return -1
\end{verbatim}
\afterverb
%
Theo một nghĩa nào đó, {\tt find} chính là hàm ngược của toán tử {\tt []}.
Thay vì việc nhận một chỉ số và tìm ra kí tự tương ứng, hàm này lại nhận
một kí tự và tìm ra chỉ số là vị trí xuất hiện của kí tự đó. Nếu không tìm
thấy kí tự, hàm sẽ trả lại {\tt -1}.

Đây là ví dụ đầu tiên mà ta thấy một câu lệnh {\tt return} bên trong
vòng lặp. Nếu {\tt word[index] == letter}, hàm sẽ thoát khỏi vòng lặp
và trở về ngay lập tức.

Nếu kí tự không xuất hiện trong chuỗi, chương trình sẽ kết thúc vòng lặp
một cách bình thường và trả lại {\tt -1}.

Dạng tính toán như thế này---duyệt một danh sách và thoát khi ta tìm được
phần tử mà ta cần---được gọi là {\bf tìm kiếm}.

\index{duyệt}
\index{tìm kiếm (dạng)}
\index{dạng!tìm kiếm}

\begin{ex}
Chỉnh sửa hàm {\tt find} để nhận thêm tham biến thứ ba nữa, chỉ số
trong {\tt word} tại đó việc tìm kiếm được bắt đầu.
\end{ex}


\section{Lặp và đếm}
\label{counter}

\index{đếm}
\index{đếm và lặp}
\index{lặp và đếm}
\index{lặp!với chuỗi}

Chương trình sau đây đếm số lần xuất hiện của chữ cái {\tt a}
trong một chuỗi:

\beforeverb
\begin{verbatim}
word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print count
\end{verbatim}
\afterverb
%
Chương trình này giới thiệu một dạng tính toán nữa gọi là  {\bf
đếm}.  Biến {\tt count} được khởi tạo với giá trị 0 và sau đó
tăng thêm 1 mỗi lần chữ cái {\tt a} được tìm thấy. Khi vòng lặp
kết thúc, {\tt count} sẽ chứa kết quả---tổng số chữ cái {\tt a}.

\begin{ex}
\index{gói}

Hãy gói đoạn mã này vào trong một hàm có tên là {\tt
count}, và sau đó khái quát hóa sao cho nó nhận chuỗi và chữ cái
làm các tham biến.
\end{ex}

\begin{ex}
Hãy viết lại hàm sao cho, thay vì duyệt qua chuỗi, hàm sử dụng
dạng có 3 tham số của {\tt
find} từ mục trước.
\end{ex}


\section{Các phương thức của {\tt string} (chuỗi)}

Một {\bf phương thức} tương tự như một hàm---nó nhận vào các
đối số và trả lại một giá trị---nhưng cú pháp lại khác. Chẳng hạn,
phương thức {\tt upper} nhận một chuỗi và trả lại một chuỗi mới
trong đó tất cả các chữ cái đều được viết in:

\index{phương thức}
\index{chuỗi!phương thức}

Thay vì dạng cú pháp của hàm {\tt upper(word)}, kiểu
cú pháp của phương thức {\tt word.upper()} được dùng đến.

\index{kí hiệu dấu chấm}

\beforeverb
\begin{verbatim}
>>> word = 'banana'
>>> new_word = word.upper()
>>> print new_word
BANANA
\end{verbatim}
\afterverb
%
Dạng này của kí hiệu dấu chấm có nêu ra tên của phương thức, {\tt
upper}, và tên của chuỗi mà ta áp dụng phương thức, {\tt
word}. Cặp ngoặc tròn bỏ trống chỉ ra rằng phương thức này không
nhận tham biến.

\index{cặp ngoặc tròn!trống}

Một lời gọi phương thức được gọi là {\bf kích hoạt}; trong trường hợp
này ta nói rằng đã kích hoạt {\tt upper} đối với {\tt word}.

\index{kích hoạt}

Hóa ra rằng, cũng có một phương thức của chuỗi có tên {\tt find} 
thực hiện nhiệm vụ giống như hàm mà ta đã viết:

\beforeverb
\begin{verbatim}
>>> word = 'banana'
>>> index = word.find('a')
>>> print index
1
\end{verbatim}
\afterverb
%
Trong ví dụ này, ta đã kích hoạt {\tt find} đối với {\tt word} và sau đó
truyền chữ cái cần tìm vào như một tham biến.

Thật ra, phương thức {\tt find} tổng quát hơn so với hàm của chúng ta;
nó có thể tìm được cả các chuỗi con chứ không riêng gì chữ cái:

\beforeverb
\begin{verbatim}
>>> word.find('na')
2
\end{verbatim}
\afterverb
%
Nó có thể nhận một đối số thứ hai là chỉ số mà tại đó việc tìm kiếm bắt đầu:

\index{tùy chọn (chỉ số)}
\index{chỉ số!tùy chọn}

\beforeverb
\begin{verbatim}
>>> word.find('na', 3)
4
\end{verbatim}
\afterverb
%
Và tham số thứ ba là chỉ số mà tại đó dừng việc tìm kiếm:

\beforeverb
\begin{verbatim}
>>> name = 'bob'
>>> name.find('b', 1, 2)
-1
\end{verbatim}
\afterverb
%
Việc tìm kiếm trên bị thất bại vì {\tt b} không xuất hiện trong vùng
chỉ số từ {\tt 1} đến {\tt 2} (không bao gồm {\tt
2}).


\begin{ex}
\index{count (phương thức)}
\index{phương thức!count}

Có một phương thức của chuỗi có tên {\tt count} tương tự như hàm
ở trong bài tập trước đây. Hãy đọc tài liệu giải thích hàm này và
sau đó viết một lệnh kích hoạt để đếm số chữ cái {\tt a} có trong
\verb"'banana'".
\end{ex}


\section{Toán tử {\tt in}}
\label{inboth}

\index{in (toán tử)}
\index{toán tử!in}
\index{boole (toán tử)}
\index{toán tử!boole}

Từ tiếng Anh {\tt in} cũng chính là tên một toán tử nhận vào hai chuỗi
và trả lại {\tt True} nếu chuỗi thứ nhật là một chuỗi con của chuỗi thứ hai:

\beforeverb
\begin{verbatim}
>>> 'a' in 'banana'
True
>>> 'seed' in 'banana'
False
\end{verbatim}
\afterverb
%
Chẳng hạn, hàm sau iin ra tất cả các chữ có trong
 {\tt word1} đồng thời cũng xuất hiện trong {\tt word2}:

\beforeverb
\begin{verbatim}
def in_both(word1, word2):
    for letter in word1:
        if letter in word2:
            print letter
\end{verbatim}
\afterverb
%
Với các tên biến được chọn hợp lý thì mã lệnh Python
đôi khi đọc lên cũng giống tiếng Anh. Nếu dịch nôm na bằng
tiếng Việt thì vòng lặp trên sẽ thành:
``với (mỗi) chữ cái trong từ (thứ nhất), nếu chữ cái (này) 
(cũng có) trong từ (thứ hai) thì in ra chữ cái (này).''

Và sau đây là kết quả thu được khi bạn so sánh apples (táo) với
oranges (cam):

\beforeverb
\begin{verbatim}
>>> in_both('apples', 'oranges')
a
e
s
\end{verbatim}
\afterverb
%

\section{So sánh chuỗi}

\index{chuỗi!so sánh}
\index{so sánh!chuỗi}

Các toán tử quan hệ cũng có tác dụng đối với chuỗi. Để xem hai chuỗi
có bằng nhau hay không:

\beforeverb
\begin{verbatim}
if word == 'banana':
    print  'Được rồi, bananas.'
\end{verbatim}
\afterverb
%
Các toán tử quan hệ khác sẽ giúp ích khi cần xếp các từ theo thứ tự bảng chữ
cái:

\beforeverb
\begin{verbatim}
if word < 'banana':
    print 'Từ của bạn,' + word + ', xếp trước banana.'
elif word > 'banana':
    print 'Từ của bạn,' + word + ', xếp sau banana.'
else:
    print 'Được rồi, bananas.'
\end{verbatim}
\afterverb
%
Python không xử lí được chữ in và chữ thường theo cách chúng ta thường làm.
Tất cả chữ in đều được xếp trước chữ thường, vì vậy:

\beforeverb
\begin{verbatim}
Từ của bạn, Pineapple, xếp trước banana.
\end{verbatim}
\afterverb
%
Một cách làm thông thường để giải quyết điều này là chuyển đổi chuỗi
về một dạng chung, như dạng chữ thường, trước khi thực hiện so sánh.
Hãy nhớ điều này khi bạn cần phải tự bảo vệ mình trước một gã vừa vớ lấy
Pineapple (quả dứa) làm vũ khí.


\section{Gỡ lỗi}
\index{gỡ lỗi}

\index{duyệt}

Khi bạn dùng chỉ số để duyệt các giá trị trong một danh s, việc lấy
đúng các điểm đầu và cuối danh sách cũng là một mẹo cần lưu ý. Sau đây
là một hàm dự định để so sánh hai từ và trả lại {\tt True} 
nếu từ này là dạng đảo ngược của từ kia; nhưng nó đã có hai lỗi sai:

\beforeverb
\begin{verbatim}
def is_reverse(word1, word2):
    if len(word1) != len(word2):
        return False
    
    i = 0
    j = len(word2)

    while j > 0:
        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{verbatim}
\afterverb
%
Lệnh {\tt if} thứ nhất kiểm tra xem các từ có cùng độ dài hay không.
Nếu không, ta lập tức trả lại {\tt False}; sau đó trong phần còn lại 
của hàm, ta coi như các từ đã có cùng độ dài. Đây là một ví dụ cho
cách dùng kiểu mẫu chốt chặn trong Mục~\ref{guardian}.

\index{chốt chặn (kiểu mẫu)}
\index{kiểu mẫu!chốt chặn}
\index{chỉ số}

{\tt i} và {\tt j} là các chỉ số: {\tt i} duyệt trên {\tt word1} theo hướng
tiến còn {\tt j} duyệt trên {\tt word2} theo hướng lùi. Nếu phát hiện
được hai chữ cái không khớp nhau, ta sẽ lập tức trả lại {\tt False}. 
Nếu như có thể đi qua được toàn bộ vòng lặp và các cặp chữ cái
đều khớp nhau thì ta sẽ trả lại {\tt True}.

Nếu kiểm tra hàm này với các từ ``pots'' và ``stop'', có lẽ chúng ta
trông đợi kết quả trả về là {\tt True}, nhưng thật ra sẽ nhận được 
thông báo lỗi IndexError:

\index{IndexError}
\index{biệt lệ!IndexError}

\beforeverb
\begin{verbatim}
>>> is_reverse('pots', 'stop')
...
  File "reverse.py", line 15, in is_reverse
    if word1[i] != word2[j]:
IndexError: string index out of range
\end{verbatim}
\afterverb
%
Để gỡ lỗi kiểu này, hành động trước tiên của tôi là in các giá trị
chỉ số ngay trước dòng lệnh có lỗi xảy ra.

\beforeverb
\begin{verbatim}
    while j > 0:
        print i, j        # đặt lệnh print ở đây
        
        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1
\end{verbatim}
\afterverb
%
Bây giờ khi chạy lại chương trình, tôi sẽ thu được thêm thông tin:

\beforeverb
\begin{verbatim}
>>> is_reverse('pots', 'stop')
0 4
...
IndexError: string index out of range
\end{verbatim}
\afterverb
%
Lần đầu tiên chạy vòng lặp, giá trị của {\tt j} là 4,
nghĩa là vượt ra ngoài phạm vi của chuỗi \verb"'pots'".
Chỉ số của kí tự cuối cùng bằng 3, vì vậy giá trị 
ban đầu của {\tt j} phải là {\tt len(word2)-1}.

\index{ngữ nghĩa (lỗi)}
\index{lỗi!ngữ nghĩa}

Nếu sửa lại lỗi đó và chạy lại chương trình, tôi sẽ thu được:

\beforeverb
\begin{verbatim}
>>> is_reverse('pots', 'stop')
0 3
1 2
2 1
True
\end{verbatim}
\afterverb
%
Lần này thì chúng ta có kết quả đúng, nhưng dường như vòng lặp
chỉ được thực hiện ba lần, điều này thật đáng ngờ. Để thấy rõ hơn
điều gì đã xảy ra, ta cần vẽ một biểu đồ trạng thái. Trong suốt lần
lặp thứ nhất, khung chứa \verb"is_reverse" sẽ trông như sau:

\index{trạng thái (biểu đồ)}
\index{biểu đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/state4.eps}}
\afterfig

Tôi đã sắp xếp các biến trong khung và vẽ thêm các
đường đứt nét để cho thấy các giá trị của {\tt i} và
{\tt j} dùng để chỉ đến các chữ cái trong {\tt word1} và {\tt word2}.

\begin{ex}
\label{is_reverse}
Bắt đầu từ biểu đồ này, hãy thực hiện nhẩm chương trình trên giấy, thay
đổi các giá trị của {\tt i} và {\tt j} ở mỗi lần lặp. Hãy tìm và sửa lại lỗi sai
thứ hai trong hàm này.
\end{ex}



\section{Thuật ngữ}

\begin{description}

\item[đối tượng:] Thứ mà một biến có thể chỉ định đến. Tạm thời bây giờ
bạn có thể coi ``đối tượng'' và ``giá trị'' là tương đương nhau.
\index{đối tượng}

\item[danh sách:] Một tập hợp có thứ tự; nghĩa là một tập hợp các giá trị mà mỗi
giá trị có thể được chỉ định bởi một chỉ số nguyên.
\index{danh sách}

\item[phần tử:] Một trong số các giá trị trong một danh s.
\index{phần tử}

\item[số thứ tự:] Một giá trị số nguyên dùng để chọn một phần tử trong danh s
chẳng hạn như một kí tự trong một chuỗi.
\index{số thứ tự}

\item[lát cắt:] Một phần của danh sách giới hạn giữa hai số thứ tự.
\index{lát cắt}

\item[chuỗi trống:] Một chuỗi mà không có kí tự nào; nó có độ dài bằng 0 và
được biểu thị bằng hai dấu nháy.
\index{chuỗi trống}

\item[(tính) không thể thay đổi:] Thuộc tính của một danh sách trong đó các phần tử của nó
không thể gán giá trị được.
\index{không thể thay đổi}

\item[duyệt:] Việc lặp lại qua các phần tử trong một danh sách, trong khi thực hiện 
cùng một thao tác với mọi phần tử.
\index{duyệt}

\item[tìm kiếm:]  Một kiểu mẫu duyệt trong đó khi tìm được phần tử mong muốn
thì dừng lại.
\index{tìm kiếm (kiểu mẫu)}
\index{kiểu mẫu!tìm kiếm}

\item[biến đếm:] Một biến dùng để đếm thứ gì đó, thường được khởi tạo giá trị 
không và sau đó tăng dần lên.
\index{biến đếm}

\item[phương thức:] Một hàm được gắn liền với một đối tượng và được gọi theo
kiểu cú pháp dấu chấm.
\index{phương thức}

\item[kích hoạt:] Một câu lệnh làm nhiệm vụ gọi một phương thức.
\index{kích hoạt}

\end{description}


\section{Exercises}

\begin{ex}

\index{kích cỡ của bước}
\index{toán tử!lát cắt}
\index{lát cắt (toán tử)}

Một lát cắt của chuỗi có thể nhận một chỉ số thứ ba để chỉ định
``kích cỡ của bước''; nghĩa là số khoảng cách giữa các kí tự kế tiếp.
Một bước bằng 2 nghĩa là cách một kí tự lấy một; bước 3 nghĩa là 
cách hai kí tự mới lấy một, v.v...

\beforeverb
\begin{verbatim}
>>> fruit = 'banana'
>>> fruit[0:5:2]
'bnn'
\end{verbatim}
\afterverb

Một bước bằng -1 sẽ duyệt toàn bộ của từ theo hướng ngược lại,
vì vậy lát cắt \verb"[::-1]" cho ta một chuỗi lộn ngược lại.

\index{palindrome}

Dùng cách kí hiệu trên để viết một câu lệnh cho hàm \verb"is_palindrome"
ở Bài tập~\ref{palindrome}.
\end{ex}


\begin{ex}
\index{chuỗi (phương thức)}
\index{phương thức!chuỗi}

Hãy đọc tài liệu hướng dẫn về những phương thức liên quan đến
chuỗi tại \url{docs.python.org/lib/string-methods.html}.  Bạn có
thể muốn thử một số phương thức để nắm vững hoạt động của chúng.
{\tt strip} và {\tt replace} là hai phương thức đặc biệt có ích.

Tài liệu sử dụng một hình thức cú pháp có thể làm bạn hiểu lầm.
Chẳng hạn, trong \verb"find(sub[, start[, end]])", các cặp ngoặc
vuông là để chỉ những đối số có hay không đưa vào đều được.
Như vậy {\tt sub} là đối số bắt buộc phải có mặt, còn
{\tt start} thì tùy, và nếu bạn có đưa {\tt start} vào, thì 
{\tt end} vẫn có thể có mặt hoặc không.
\end{ex}

\begin{ex}
Các hàm sau đây đều dự kiến nhằm mục đích kiểm tra xem liệu một chuỗi
có bao gồm chữ cái viết thường không, nhưng ít nhất một vài trong số đó
bị sai. Với mỗi hàm, hãy mô tả xem tác dụng thực sự của nó là gì (với
giả thiết rằng tham biến truyền vào là một chuỗi).

\beforeverb
\begin{verbatim}
def any_lowercase1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def any_lowercase2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def any_lowercase3(s):
    for c in s:
        flag = c.islower()
    return flag

def any_lowercase4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def any_lowercase5(s):
    for c in s:
        if not c.islower():
            return False
    return True
\end{verbatim}
\afterverb

\end{ex}


\begin{ex}
\index{xoay, chữ}

\label{exrotate}
ROT13 là một dạng mã hóa yếu trong đó mỗi chữ cái được ``xoay'' đi
13 vị trí.\footnote{Xem
  \url{wikipedia.org/wiki/ROT13}.} Việc xoay một chữ cái có nghĩa
là dịch chuyển vị trí trong bảng chữ cái và đến cuối bảng thì quay lộn
về đầu. Chẳng hạn chữ 'A' dịch đi 3 thì cho chữ 'D' và 'Z' dịch đi 1 thì
cho chữ 'A'.

Hãy viết một hàm có tên là \verb"rotate_word" trong đó nhận các
tham biến gồm một chuỗi và một số nguyên, rồi trả lại một chuỗi mới
trong đó có chứa các chữ trong chuỗi đầu sau khi đã ``xoay'' đi 
số vị trí cho trước.

Chẳng hạn, ``cheer'' xoay đi 7 là ``jolly'' và ``melon'' xoay đi
-10 là ``cubed''.  

%For example ``sleep''
%rotated by 9 is ``bunny'' and ``latex'' rotated by 7 is ``shale''.

Bạn có thể cần dùng đến các hàm có sẵn {\tt ord}, which converts
a character to a numeric code, and {\tt chr}, which converts numeric
codes to characters.

Trên Internet đã có một số câu nói đùa khiêu khích được tạo ra
bằng ROT13. Nếu bạn không dễ bị chọc giận, hãy tìm kiếm một số
câu nói như vậy và thử giải mã xem.
\end{ex}


\chapter{Nghiên cứu cụ thể: trò chơi chữ}

\section{Đọc danh sách các từ}
\label{wordlist}

Với những bài tập trong chương này, ta cần đến một danh sách
các từ tiếng Anh. Trên mạng hiện nay có rất nhiều danh sách từ,
nhưng  danh sách thích hợp nhất được Grady Ward sưu tầm và 
đóng góp cho nguồn tài liệu công cộng, như một phần dự án
từ vựng Moby\footnote{\url{wikipedia.org/wiki/Moby_Project}.}. 
Nó là một danh sách gồm 113.809 từ chính thức được dùng trong
các ô chữ; nghĩa là những từ có nghĩa trong trò chơi ô chữ và các
trò đố chữ khác. Trong tuyển tập Moby, tên file danh sách từ là
 {\tt 113809of.fic}; tôi có kèm theo một bản sao của file này
với tên gọi đơn giản hơn {\tt words.txt}, trong bộ
Swampy.

\index{Swampy}
\index{trò chơi ô chữ}

File này chỉ chứa các kí tự thuần túy, vì vậy bạn có thể mở
bằng một trình soạn thảo; nhưng bạn cũng có thể dùng Python
để đọc. Hàm có sẵn {\tt open} sẽ nhận vào tên file như một
tham biến và trả lại một {\bf đối tượng file} mà bạn dùng nó
để đọc nội dung file.

\index{open (hàm)}
\index{hàm!open}
\index{plain text}
\index{text!plain}
\index{object!file}
\index{file object}

\beforeverb
\begin{verbatim}
>>> fin = open('words.txt')
>>> print fin
<open file 'words.txt', mode 'r' at 0xb7f4b380>
\end{verbatim}
\afterverb
%
{\tt fin} là một cái tên thông dụng để đặt cho đối tượng file
nhập vào (input). Chế độ \verb"'r'" chỉ định rằng file này được
mở để đọc (reading), khác với \verb"'w'" để ghi (writing).

\index{readline (phương thức)}
\index{phương thức!readline}

Đối tượng file cung cấp một số phương thức để đọc, trong đó có 
{\tt readline}, để đọc các kí tự từ một file cho đến hết dòng,
sang đến đầu dòng mới, và trả trả lại kết quả dưới dạng một chuỗi:

\beforeverb
\begin{verbatim}
>>> fin.readline()
'aa\r\n'
\end{verbatim}
\afterverb
%
Từ đầu tiên trong danh mục là ``aa,'' có nghĩa là một loại
dung nham. Chuỗi \verb"\r\n" biểu thị hai kí tự trống, một kí tự 
về đầu dòng (carriage return) và một kí tự nhảy dòng mới (newline), 
để ngăn cách từ này với từ tiếp theo.

Đối tượng file có nhiệm vụ theo dõi vị trí hiện thời trong file,
vì vậy nếu bạn gọi lại {\tt readline} lần nữa, bạn sẽ được từ kế tiếp:

\beforeverb
\begin{verbatim}
>>> fin.readline()
'aah\r\n'
\end{verbatim}
\afterverb
%
Từ tiếp theo là ``aah,'' là một từ hoàn toàn có nghĩa, vì vậy
bạn đừng nhìn tôi kiểu như vậy nữa nhé. À, nếu như các dấu trống
làm bạn không hài lòng thì hãy dùng phương thức chuỗi có tên là {\tt strip}:

\index{strip (phương thức)}
\index{phương thức!strip}

\beforeverb
\begin{verbatim}
>>> line = fin.readline()
>>> word = line.strip()
>>> print word
aahed
\end{verbatim}
\afterverb
%
Bạn cũng có thể dùng một đối tượng file như một bộ phận trong vòng lặp {\tt for}.
Chương trình sau sẽ đọc {\tt words.txt} và in ra các từ, mỗi từ trên một dòng:

\index{open (hàm)}
\index{hàm!open}

\beforeverb
\begin{verbatim}
fin = open('words.txt')
for line in fin:
    word = line.strip()
    print word
\end{verbatim}
\afterverb
%

\begin{ex}
Hãy viết một chương trình đọc vào {\tt words.txt} và chỉ in ra những từ dài hơn
20 kí tự (không kể dấu trống).
\index{dấu trống}

\end{ex}


\section{Bài tập}

Trong mục tiếp theo sẽ có lời giải cho các bài tập dưới đây. Vì vậy, bạn cần
phải ít ra là cố gắng thử giải chúng trước khi đọc đến đáp án.

\begin{ex}
Vào năm 1939, Ernest Vincent Wright đã xuất bản một cuốn tiểu thuyết gồm 50.000 từ
có tên là {\em Gadsby}, mà trong đó không chứa một chữ cái ``e'' nào. Việc này thật
chẳng dễ dàng vì trong tiếng Anh, ``e'' là chữ cái thường gặp nhất.

Thực ra khi không dùng chữ cái thông dụng nhất đó thì việc diễn đạt một ý tưởng
đơn lẽ cũng là khó rồi. Ban đầu bạn phải thử làm rất chậm, nhưng dần sau này khi
cẩn thận và đã có kinh nghiệm nhiều giờ thì bạn sẽ quen hơn.

Thôi, tôi sẽ không nói tiếp về điều đó nữa.

Yêu cầu của bài tập là viết một hàm tên là \verb"has_no_e" nhằm trả lại {\tt True} 
nếu từ đã cho không chứa chữ cái ``e'' trong đó.

Hãy chỉnh lại chương trình bạn đã viết trong mục trước để chỉ in ra những
từ mà không chứa chữ ``e'' và tính tỉ lệ phần trăm của các từ trong danh sách
mà không chứa chữ ``e''.

\index{lipogram (viết thiếu chữ)}

\end{ex}


\begin{ex} 
Hãy viết một hàm có tên là {\tt avoids}, trong đó nhận vào một từ và một chuỗi các
chữ cái bị cấm dùng, sau đó trả lại {\tt True} nếu từ đó không chứa bất kì
chữ cái nào trong danh sách bị cấm.

Hãy sửa lại chương trình của bạn để người dùng nhập vào một chuỗi các
chữ cái cấm dùng và sau đó in ra tổng số từ mà trong đó không chứa bất kì
chữ cái cấm nào.

Bạn có thể tìm được tập hợp 5 chữ cái cấm mà chỉ loại ra số ít nhất các từ
vi phạm những chữ cái cấm đó không?
\end{ex}

\begin{ex}
Hãy viết một hàm có tên là \verb"uses_only", trong đó nhận vào một từ và một
chuỗi các chữ cái, sau đó trả lại {\tt True} nếu từ đó chỉ cấu thành
từ những chữ có trong danh sách chữ cái. Bạn có thể đặt một câu trong
đó chỉ dùng các chữ cái {\tt acefhlo} không, ngoài câu ``Hoe alfalfa?''
\end{ex}


\begin{ex} 
Hãy viết một hàm có tên là \verb"uses_all", trong đó nhận vào một từ
và một chuỗi các chữ cái yêu cầu, sau đó trả lại {\tt True} nếu từ đó
dùng hết tất cả các chữ cái yêu cầu, mỗi chữ cái ít nhất là một lần.
Có bao nhiêu từ dùng tất cả các nguyên âm {\tt aeiou}? Dùng tất cả {\tt aeiouy}?
\end{ex}


\begin{ex}
Hãy viết một hàm có tên là \verb"is_abecedarian" để trả lại
{\tt True} nếu các chữ cái trong từ xuất hiện xuôi theo thứ tự của bảng
chữ cái (chấp nhận các chữ cái lặp lại hai lần). Có tất cả bao nhiêu từ
như vậy?
\end{ex}

\index{theo thứ tự abc}


%\begin{ex}
%\label{palindrome}
%A palindrome is a word that reads the same
%forward and backward, like ``rotator'' and ``noon.''
%Write a boolean function named \verb"is_palindrome" that
%takes a string as a parameter and returns {\tt True} if it is
%a palindrome.

%Modify your program from the previous section to print all
%of the palindromes in the word list and then print the total
%number of palindromes.
%\end{ex}



\section{Tìm kiếm}

\index{tìm kiếm (dạng mẫu)}
\index{dạng mẫu!tìm kiếm}

Tất cả các bài tập trong mục trước đều có điểm chung; chúng đều
giải quyết được bằng dạng mẫu tìm kiếm ở Mục~\ref{find}. Ví dụ đơn giản nhất là:

\beforeverb
\begin{verbatim}
def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
\end{verbatim}
\afterverb
%
Vòng lặp {\tt for} duyệt các kí tự có trong {\tt word}. Nếu ta thấy kí tự
``e'', ta có thể lập tức trả về {\tt False}; còn không thì tiếp tục đến
với kí tự tiếp theo. Nếu ta thoát khỏi vòng lặp một cách bình thường, nghĩa
là ta không tìm thấy chữ ``e'', thì ta sẽ trả về {\tt True}.

\index{duyệt}

% Removing this because we haven't seen the in operator yet.
%\index{in operator}
%\index{operator!in}

%You could write this function more concisely using the {\tt in}
%operator, but I started with this version because it 
%demonstrates the logic of the search pattern.

\index{khái quát hóa}

{\tt avoids} là một dạng khái quát của \verb"has_no_e" nhưng nó cũng có
cấu trúc tương tự:

\beforeverb
\begin{verbatim}
def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
\end{verbatim}
\afterverb
%
Chúng ta có thể trả về {\tt False} ngay khi tìm thấy một chữ cái bị cấm; còn
nếu chúng ta đến được cuối vòng lặp thì sẽ trả về {\tt True}.

\verb"uses_only" cũng tương tự, chỉ khác là điều kiện được đảo ngược lại:

\beforeverb
\begin{verbatim}
def uses_only(word, available):
    for letter in word: 
        if letter not in available:
            return False
    return True
\end{verbatim}
\afterverb
%
Thay vì một danh sách các chữ cái bị cấm, ta có một danh sách chữ cái được dùng.
Nếu ta tìm thấy một chữ cái trong {\tt word} mà không có trong 
{\tt available}, ta có thể trả về giá trị {\tt False}.

\verb"uses_all" tương tự, nhưng ta đảo lại vai trò của từ và dẫy các chữ cái:

\beforeverb
\begin{verbatim}
def uses_all(word, required):
    for letter in required: 
        if letter not in word:
            return False
    return True
\end{verbatim}
\afterverb
%
Thay vì việc duyệt các chữ cái trong {\tt word}, vòng lặp duyệt các chữ cái
được yêu cầu. Nếu bất kì chữ cái yêu cần nào mà không có mặt trong từ thì ta
có thể trả về giá trị  {\tt False}.

\index{duyệt}

Nếu bạn có thể tư duy như một nhà khoa học máy tính thực thụ, bạn có thể 
nhận thấy rằng \verb"uses_all" là một trường hợp của một bài toán mà trước
đây ta đã giải quyết rồi, và bạn có thể đã viết:

\beforeverb
\begin{verbatim}
def uses_all(word, required):
    return uses_only(required, word)
\end{verbatim}
\afterverb
%
Đó là ví dụ cho một phương pháp xây dựng chương trình gọi là {\bf nhận diện
bài toán}, trong đó bạn nhân ra bài toán mà bạn đang giải quyết chính là một
trường hợp của bài toán trước đây đã từng làm rồi, và chỉ cần áp dụng cách
giải trước đây.

\index{nhận diện bài toán}
\index{kế hoạch xây dựng!nhận diện bài toán}


\section{Lặp với các chỉ số}

\index{lặp!với các chỉ số}
\index{chỉ số!trong lệnh lặp}

Tôi đã viết các hàm trong mục trước đây bằng vòng lệnh {\tt for}
vì tôi chỉ cần các kí tự có trong chuỗi; tôi không cần làm gì với các chỉ số
(thứ tự) của từng kí tự.

Đối với \verb"is_abecedarian" chúng ta phải so sánh các chữ cái liền kề nhau,
điều này đòi hỏi phải có mẹo khi dùng một vòng lặp {\tt for}:

\beforeverb
\begin{verbatim}
def is_abecedarian(word):
    previous = word[0]
    for c in word:
        if c < previous:
            return False
        previous = c
    return True
\end{verbatim}
\afterverb

Một cách làm  khác là dùng đệ quy:

\beforeverb
\begin{verbatim}
def is_abecedarian(word):
    if len(word) <= 1:
        return True
    if word[0] > word[1]:
        return False
    return is_abecedarian(word[1:])
\end{verbatim}
\afterverb

hoặc dùng một vòng lặp {\tt while}:

\beforeverb
\begin{verbatim}
def is_abecedarian(word):
    i = 0
    while i < len(word)-1:
        if word[i+1] < word[i]:
            return False
        i = i+1
    return True
\end{verbatim}
\afterverb
%
Vòng lặp bắt đầu tại {\tt i=0} và kết thúc khi {\tt i=len(word)-1}.  
Mỗi lần duyệt qua vòng lặp, máy sẽ so sánh chữ cái thứ $i$ (mà bạn có
thể coi như chữ cái hiện hành) và chữ cái thứ $i+1$ (coi như chữ cái
tiếp theo).

Nếu chữ cái tiếp theo mà nhỏ hơn (tức là đứng trước theo bản chữ cái) 
chữ cái hiện hành, thì ta sẽ phát hiện được sự phá vỡ quy luật sắp xếp,
và sẽ trả lại giá trị {\tt False}.

Nếu ta đến được cuối vòng lặp mà không gặp lỗi nào, thì từ đã cho 
đạt yêu cầu kiểm trả. Để tự tin khẳng định rằng vòng lặp đã kết thúc đúng,
hãy xét một ví dụ như \verb"'flossy'".  Từ này có độ dài là 6, vì vậy
vòng lặp kết thúc lần cuối khi {\tt i} bằng 4, ứng với chỉ số của chữ cái
áp chót. Ở vòng lặp cuối, máy sẽ so sánh chữ cái áp chót với chữ cái cuối;
đây là điều chúng ta muốn.

\index{từ đối xứng}

Sau đây là một dạng khác của \verb"is_palindrome" (xem lại
Bài tập~\ref{palindrome}) trong đó có dùng hai biến chỉ số; một bắt đầu từ
chữ cái đầu và tăng dần lên; biến kia bắt đầu từ chữ cái cuối và giảm dần xuống.

\beforeverb
\begin{verbatim}
def is_palindrome(word):
    i = 0
    j = len(word)-1

    while i<j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{verbatim}
\afterverb

Hoặc là, nếu bạn nhận thấy rằng đây chỉ là một trường hợp của bài toán
đã giải trước đó, thì bạn có thể viết:

\beforeverb
\begin{verbatim}
def is_palindrome(word):
    return is_reverse(word, word)
\end{verbatim}
\afterverb

\index{nhận diện bài toán}
\index{kế hoạch xây dựng!nhận diện bài toán}

Với giả sử là bạn đã làm Bài tập~\ref{is_reverse}.


\section{Gỡ lỗi}

\index{gỡ lỗi}
\index{kiểm tra chương trình!tính khó}
\index{chương trình!kiểm tra}

Kiểm tra chương trình là một việc khó. Các hàm được viết trong chương
này đều khá dễ kiểm tra vì bạn có thể kiểm tra kết quả bằng cách tính
nhẩm. Tuy vậy, để chọn được toàn bộ tập hợp các từ nhằm kiểm tra 
chương trình để loại trừ mọi lỗi sẽ là việc rất khó, thậm chí là 
không thể.

Lấy \verb"has_no_e" làm ví dụ, hiển nhiên là có hai trường hợp để
kiểm tra: với những từ có chứa chữ 'e' cần phải trả lại {\tt False};
còn những từ khác thì phải trả lại {\tt True}. Bạn có thể dễ dàng
tìm được kết quả trong cả hai trường hợp.

Với mỗi trường hợp, vẫn có những trường hợp nhỏ mà khó nhận ra hơn. 
Trong số những từ có chứa ``e,'' bạn cần kiểm tra những từ có chứa ``e''
ở đầu, ở cuối, và ở đoạn giữa của từ. Bạn cần kiểm tra những từ dài,
từ ngắn, từ rất ngắn, và cả chuỗi trống nữa. Chuỗi trống chính là ví dụ
cho một {\bf trường hợp đặc biệt}, vốn là một trong số các trường hợp
không dễ thấy mà ở đó tường tiềm ẩn lỗi.

\index{trường hợp đặc biệt}

Ngoài những trường hợp kiểm tra mà bạn tự tạo ra, bạn còn có thể 
kiểm tra chương trình với một danh sách từ như {\tt words.txt}. 
Bằng cách lướt qua kết quả tìm được, bạn có thể phát hiện được lỗi,
nhưng hãy cẩn thận: bạn chỉ bắt được những lỗi theo một kiểu (ở
những từ vốn không nên có trong danh sách kết quả, nhưng lại có)
chứ không bắt được lỗi theo kiểu còn lại (những từ đáng ra có
trong danh sách kết quả nhưng lại không có).

Nói chung, việc kiểm tra có thể giúp bạn tìm ra lỗi, nhưng thật
không dễ tạo ra một bộ trường hợp kiểm tra thật tốt, và dù nếu bạn
có làm được vậy đi nữa, cũng không có gì đảm bảo được rằng chương
trình sẽ đúng.

\index{kiểm tra chương trình!không có lỗi}

Theo lời một nhà khoa học máy tính nổi tiếng: ``Việc kiểm tra chương trình
có thể được dùng để cho thấy sự tồn tại của lỗi, nhưng không bao giờ
có thể dùng để chứng tỏ được sự vắng mặt của chúng!''. Nguyên văn:

\begin{quote}
Program testing can be used to show the presence of bugs, but never to
show their absence!

--- Edsger W. Dijkstra
\end{quote}

\index{Dijkstra, Edsger}


\section{Thuật ngữ}
\begin{description}

\item[đối tượng file:]  Một giá trị để biểu thị một file được mở.
\index{file (đối tượng)}
\index{đối tượng!file}

\item[nhận diện bài toán:] Một cách giải quyết bài toán thông qua
việc diễn đạt đó như một trường hợp riêng của một bài toán khác đã
được giải quyết từ trước.
\index{nhận diện bài toán}

\item[trường hợp đặc biệt:] Một trường hợp kiểm tra thuộc vào dạng
không điển hình hoặc không dễ thấy (và thường cũng khó xử lí một cách
thích hợp).
\index{trường hợp đặc biệt}

\end{description}


\section{Bài tập}

\begin{ex}

\index{Car Talk}
\index{đố vui}
\index{lặp chữ cái}

Câu hỏi này được dựa trên mục đố vui phát sóng trong chương trình {\em Car
  Talk}\footnote{\url{www.cartalk.com/content/puzzler/transcripts/200725}.}:

\begin{quote}
Hãy cho tôi biết một từ trong đó chứa 3 cặp hai chữ cái giống nhau
liên tiếp. Tôi sẽ kể ra hai ví dụ gần đạt tiêu chuẩn như vậy. Chẳng hạn,
từ ``committee'', c-o-m-m-i-t-t-e-e. Từ này sẽ đạt yêu cầu nếu chữ `i' 
không có ở đó. Hoặc là Mississippi: M-i-s-s-i-s-s-i-p-p-i. Nếu bỏ hết các
chữ i trong đó ra, từ này cũng đạt yêu cầu. Nhưng mà có một từ mà tôi biết,
nó có 3 cặp đôi chữ cái liên tiếp. Dĩ nhiên là có thể có đến 500 từ tiếng
Anh khác như vậy nhưng đến giờ thì tôi chỉ biết được một từ. Đó là từ gì?
\end{quote}

Hãy viết một chương trình để tìm ra từ này. Bạn có thể tìm thấy lời giải 
của tôi ở \url{thinkpython.com/code/cartalk.py}.

\end{ex}


\begin{ex}
Sau đây là một câu đố khác trong {\em Car Talk}\footnote{\url{www.cartalk.com/content/puzzler/transcripts/200803}.}:

\index{Car Talk}
\index{đố vui}
\index{công-tơ-mét}
\index{từ đối xứng}

\begin{quote}
``Một ngày, khi đang lái xe trên đường cao tốc, tôi đột nhiên chú ý
đến đồng hồ công-tơ-mét trên xe. Cũng như các công-tơ-mét khác, nó chỉ
sáu chữ số, lấy tròn số dặm đường mà xe đi được. Như vậy, nếu xe tôi
đã chạy được 300.000 dặm chẳng hạn, thì tôi sẽ nhìn thấy  3-0-0-0-0-0.

``Bây giờ, trở về chuyện ngày hôm đó, tôi đã thấy một chi tiết thú vị.
Tôi nhận thấy rằng bốn chữ số cuối cùng đối xứng nhau; nghĩa là đọc
xuôi, đọc ngược đều như nhau. Chẳng hạn, 5-4-4-5 là một chuỗi đối xứng,
như vậy công-tơ-mét của tôi có thể đã chỉ 3-1-5-4-4-5.

``Một dặm sau đó, 5 chữ số cuối xếp thành danh sách đối xứng. Chẳng hạn, nó
có thể là 3-6-5-4-5-6. Một dặm sau, bốn chữ số giữa trong 6 số 
xếp thành danh sách 4 đối xứng. Bạn vẫn theo kịp tôi chứ? Này nhé, một dặm
sau đó thì cả chuỗi 6 số là đối xứng!

``Câu hỏi là, lần đầu tôi nhìn công-tơ-mét thì số chỉ của nó bằng
bao nhiêu?''
\end{quote}

Hãy viết một chương trình Python để kiểm tra tất cả các số gồm sáu
chữ số sau đó in ra những số thỏa mãn tất cả các điều kiện như vậy. 
Bạn có thể xem lời giải của tôi tại \url{thinkpython.com/code/cartalk.py}.

\end{ex}


\begin{ex}
Sau đây là một câu đố khác trong chương trình {\em Car Talk} mà bạn có
thể giải bằng cách tìm kiếm
\footnote{\url{www.cartalk.com/content/puzzler/transcripts/200813}}:

\index{Car Talk}
\index{đố vui}
\index{từ đối xứng}

\begin{quote}
``Gần đây tôi tới thăm mẹ và chúng tôi nhận ra rằng số tuổi của tôi 
khi viết ngược lại (đổi chỗ hai chữ số) sẽ trở thành tuổi mẹ. Chẳng hạn,
nếu mẹ tôi 73 tuổi thì tôi 37. Chúng tôi đã tự hỏi liệu điều này xảy ra
được mấy lần nhưng rồi chuyển sang câu chuyện khác mà không tìm ra
câu trả lời.

Khi quay trở về nhà tôi đã nhận ra rằng số tuổi của chúng tôi đã có
sáu trường hợp đổi chỗ như thế. Đồng thời tôi còn tính được, nếu may
mắn thì điều này sẽ xảy ra chỉ trong vài năm tới, và nếu rất may mắn
thì nó còn xảy ra thêm một lần nữa. Tóm lại là tổng cộng 8 lần có thể
xảy ra. Vậy câu hỏi là, bây giờ tôi đang bao nhiêu tuổi?''
\end{quote}

Hãy viết một chương trình Python để dò tìm lời giải cho câu đố này.
Gợi ý: bạn có thể tận dụng phương thức chuỗi có tên {\tt zfill}.

Bạn có thể xem lời giải của tôi tại \url{thinkpython.com/code/cartalk.py}.

\end{ex}



\chapter{Danh sách}

\index{danh sách}
\index{kiểu!danh sách}


\section{Danh sách là một dãy}

Cũng như một chuỗi, {\bf danh sách} cũng là một dãy các giá trị. Trong một chuỗi,
các giá trị đó là những kí tự; trong một danh sách, chúng có thể 
thuộc kiểu bất kì. Các giá trị trong một danh sách được gọi 
là các {\bf phần tử}.

\index{phần tử}
\index{danh sách}

Có một vài cách khác nhau để tạo ra một danh sách mới; cách đơn
giản nhất là bao quanh các phần tử bằng một cặp ngoặc vuông (\verb"[" và \verb"]"):

\beforeverb
\begin{verbatim}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
\end{verbatim}
\afterverb
%
Ở ví dụ thứ nhất bên trên, danh sách bao gồm 4 số nguyên. danh sách thứ hai thì có
ba chuỗi. Các phần tử trong một danh sách không nhất thiết có cùng kiểu. 
danh sách sau đây bao gồm một chuỗi, một số có phần thập phân, một số nguyên,
và (a ha!) một danh sách khác nữa:

\beforeverb
\begin{verbatim}
['spam', 2.0, 5, [10, 20]]
\end{verbatim}
\afterverb
%
Một danh sách nằm trong một danh sách khác thì được gọi là {\bf lồng ghép}.

\index{lồng ghép (danh sách)}
\index{danh sách!lồng ghép}

Một danh sách không chứa phần tử nào được gọi là danh sách trống; bạn có thể
tạo ra một dánh sách trống bầng một cặp ngoặc kép liền nhau, \verb"[]".

\index{trống (danh sách)}
\index{danh sách!trống}

Đúng như bạn có thể nghĩ đến, ta có thể gán các giá trị trong danh sách cho các
biến:

\beforeverb
\begin{verbatim}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print cheeses, numbers, empty
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
\end{verbatim}
\afterverb
%

\index{phép gán}

% From Jeff: write sum for a nested list?


\section{Danh sách là kiểu dữ liệu thay đổi được}

\index{danh sách!phần tử}
\index{truy cập}
\index{chỉ số}
\index{ngoặc vuông (toán tử)}
\index{toán tử!ngoặc vuông}

Cú pháp để thực hiện việc truy cập từng phần tử của một danh sách
cũng giống như truy cập từng kí tự trong một chuỗi---đó là dùng
toán tử ngoặc vuông. Biểu thức bên trong cặp ngoặc vuông xác định 
chỉ số. Chú ý rằng chỉ số bắt đầu từ 0:

\beforeverb
\begin{verbatim}
>>> print cheeses[0]
Cheddar
\end{verbatim}
\afterverb
%
Khác với các chuỗi, danh sách là kiểu dữ liệu thay đổi được. Khi 
toán tử ngoặc vuông xuất hiện ở vế trái một lệnh gán, nó sẽ chỉ
định phần tử của danh sách cần được gán.

\index{tính thay đổi được}

\beforeverb
\begin{verbatim}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print numbers
[17, 5]
\end{verbatim}
\afterverb
%
Phần tử có chỉ số 1 của {\tt numbers}, trước đó là phần tử 123,
giờ đã được thay bằng 5.

\index{chỉ số!bắt đầu từ không}
\index{số không, chỉ số đầu tiên}

Bạn có thể hình dung danh sách như là một mối quan hệ giữa các
chỉ số và phần tử. Mối quan hệ này được gọi là {\bf đánh số}; mỗi chỉ số
được ``đánh'' cho mỗi phần tử. Sau đây là một biểu đồ trạng thái biểu thị {\tt
cheeses}, {\tt numbers} và {\tt empty}:

\index{trạng thái (biểu đồ)}
\index{biểu đồ!trạng thái}
\index{đánh số}

\beforefig
\centerline{\includegraphics{figs/list_state.eps}}
\afterfig

Các danh sách được biểu thị bởi những khối với từ ``list'' ghi bên ngoài
và các phần tử ở bên trong nó. {\tt cheeses} tương ứng với một danh sách
với ba phần tử được đánh chỉ số 0, 1 và 2.
{\tt numbers} gồm có hai phần tử; và biểu đồ cho thấy rằng giá trị của
phần tử thứ hai đã được gán lại từ 123 thành 5.
{\tt empty} ứng với một danh sách không chứa phần tử nào.

\index{phần tử (gán)}
\index{phép gán!phần tử}

Các chỉ số trong dãy cũng có tác dụng như chỉ số của chuỗi:

\begin{itemize}

\item Bất kì một biểu thức số nguyên nào cũng có thể được dùng làm
chỉ số.

\item Nếu bạn cố gắng đọc hoặc ghi một phần tử mà bản thân nó không tồn tại,
bạn sẽ gặp phải lỗi {\tt IndexError}.

\index{biệt lệ!IndexError}
\index{IndexError}

\item Nếu một chỉ số có giá trị âm, nó sẽ được đếm ngược từ phía cuối danh sách.

\end{itemize}

\index{danh sách!chỉ số}


\index{danh sách!thành viên}
\index{thành viên!danh sách}
\index{in (toán tử)}
\index{toán tử!in}

Toán tử {\tt in} cũng dùng được với các danh sách.

\beforeverb
\begin{verbatim}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
\end{verbatim}
\afterverb


\section{Duyệt danh sách}
\index{danh sách!duyệt}
\index{duyệt!danh sách}
\index{for (vòng lặp)}
\index{vòng lặp!for}
\index{câu lệnh!for}

Cách thông dụng nhất để duyệt các phần tử trong một danh sách
là dùng một vòng lặp {\tt for}.  Cú pháp cũng tương tự như với
chuỗi:

\beforeverb
\begin{verbatim}
for cheese in cheeses:
    print cheese
\end{verbatim}
\afterverb
%
Cách này sẽ tốt nếu bạn chỉ cần đọc các phần tử trong danh sách.
Nhưng nếu bạn cần ghi hoặc cập nhật các phần tử trong danh sách,
bạn phải dùng đến chỉ số. Một cách làm hay dùng là kết hợp các
hàm {\tt range} và {\tt len}:

\index{vòng lặp!với chỉ số}
\index{chỉ số!với vòng lặp}

\beforeverb
\begin{verbatim}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
\end{verbatim}
\afterverb
%
Vòng lặp này duyệt danh sách và cập nhật từng phần tử.  {\tt len}
trả về số phần tử có trong danh sách. {\tt range} trả về một
danh sách các chỉ số từ 0 đến $n-1$, trong đó $n$ là chiều dài
của danh sách. Mỗi lần đi qua vòng lặp, {\tt i} sẽ nhận giá trị
chỉ số của phần tử kế tiếp. Lệnh gán trong phần thân sẽ dùng 
{\tt i} để đọc giá trị cũ của phần tử và gán giá trị mới.

\index{phần tử (cập nhật)}
\index{cập nhật!phần tử}

Một vòng lặp {\tt for} áp dụng với danh sách trống sẽ không bao giờ
thực hiện phân thân câu lệnh:

\beforeverb
\begin{verbatim}
for x in empty:
    print 'Không bao giờ được thực hiện.'
\end{verbatim}
\afterverb
%
Mặc dù một danh sách có thể bao gồm một danh sách khác, danh sách
được lồng ghép bên trong vẫn được tính như một phần tử đơn lẻ. 
Chiều dài của danh sách này là 4:

\index{lồng ghép (danh sách)}
\index{danh sách!lồng ghép}

\beforeverb
\begin{verbatim}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
\end{verbatim}
\afterverb



\section{Các phép toán với danh sách}
\index{danh sách!phép toán}

Toán tử {\tt +} có tác dụng ghép nối các danh sách:

\index{ghép nối!danh sách}
\index{danh sách!ghép nối}

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
\end{verbatim}
\afterverb
%
Cũng tương tự như vậy, toán tử {\tt *} lặp lại một danh sách với số lần định trước:

\index{lặp lại!danh sách}
\index{danh sách!lặp lại}

\beforeverb
\begin{verbatim}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{verbatim}
\afterverb
%
Ví dụ thứ nhất lặp lại {\tt [0]} bốn lần. Ví dụ thứ hai lặp lại danh sách {\tt [1, 2, 3]} 
ba lần.


\section{Lát cắt trong danh sách}

\index{lát cắt (toán tử)}
\index{toán tử!lát cắt}
\index{chỉ số!lát cắt}
\index{danh sách!lát cắt}
\index{lát cắt!danh sách}

Toán tử lát cắt cũng có tác dụng với các danh sách:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
\end{verbatim}
\afterverb
%
Nếu bạn bỏ qua chỉ số thứ nhất, lát cắt sẽ bắt đầu từ vị trí 
đầu tiên cảu danh sách. Nếu bạn bỏ qua chỉ số thứ hai, lát cắt
sẽ kéo dài đến cuối danh sách. Vì vậy nếu bạn bỏ qua cả hai
chỉ số, lát cắt sẽ là một bản sao của toàn bộ danh sách.

\index{danh sách!sao chép}
\index{lát cắt!sao chép}
\index{sao chép!lát cắt}

\beforeverb
\begin{verbatim}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%
Vì các danh sách có tính thay đổi cho nên sao chép là việc
ta nên làm trước khi thực hiện các thao tác gấp, xoay, hoặc
chia nhỏ danh sách.

\index{tính thay đổi}

Một toán tử bên vế trái cảu phép gán có thể cập nhật cùng lúc
nhiều phân tử:

\index{lát cắt!cập nhật}
\index{cập nhật!lát cắt}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print t
['a', 'x', 'y', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%

% You can add elements to a list by squeezing them into an empty
% slice:

% \beforeverb
% \begin{verbatim}
% >>> t = ['a', 'd', 'e', 'f']
% >>> t[1:1] = ['b', 'c']
% >>> print t
% ['a', 'b', 'c', 'd', 'e', 'f']
% \end{verbatim}
% \afterverb
%
% And you can remove elements from a list by assigning the empty list to
% them:

% \beforeverb
% \begin{verbatim}
% >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
% >>> t[1:3] = []
% >>> print t
% ['a', 'd', 'e', 'f']
% \end{verbatim}
% \afterverb
%
% But both of those operations can be expressed more clearly
% with list methods.


\section{Các phương thức đối với danh sách}

\index{danh sách!phương thức}
\index{phương thức, danh sách}

Python cung cấp các phương thức hoạt động với danh sách. Chẳng hạn,
{\tt append} thêm một phân tử mới vào cuối một danh sách:

\index{append (phương thức)}
\index{phương thức!append}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print t
['a', 'b', 'c', 'd']
\end{verbatim}
\afterverb
%
{\tt extend} nhận vào danh sách như một tham biến và tiếp nối tất cả
các phần tử chứa trong danh sách đó:

\index{extend (phương thức)}
\index{phương thức!extend}

\beforeverb
\begin{verbatim}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print t1
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%
Ở ví dụ trên, {\tt t2} không bị thay đổi.

{\tt sort} sắp xếp các phần tử của danh sách từ thấp lên cao:

\index{sort (phương thức)}
\index{phương thức!sort}

\beforeverb
\begin{verbatim}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print t
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%
Các phương thức với danh sách đều trống; chúng chỉ thay đổi danh sách và
trả về {\tt None}. Nếu bạn viết {\tt t = t.sort()}, bạn sẽ thất vọng với
kết quả nhận được.

\index{trống (phương thức)}
\index{phương thức trống}
\index{None (giá trị đặc biệt)}
\index{giá trị đặc biệt!None}


\section{Map, filter và reduce}

Để cộng tất cả các số có trong một danh sách lại, bạn có thể dùng vòng lặp như sau:

% see add.py

\beforeverb
\begin{verbatim}
def add_all(t):
    total = 0
    for x in t:
        total += x
    return total
\end{verbatim}
\afterverb
%
{\tt total} ban đầu được gán bằng 0. Mỗi lần chạy vòng lặp,
{\tt x} nhận một phần tử từ danh sách. Toán tử {\tt +=} giúp ta
cập nhật biến theo cách viết gọn gàng nhất. 
{\bf Câu lệnh gán rút gọn} sau:

\index{cập nhật (toán tử)}
\index{toán tử!cập nhật}

\index{lệnh gán!rút gọn}
\index{rút gọn (dạng lệnh gán)}

\beforeverb
\begin{verbatim}
    total += x
\end{verbatim}
\afterverb
%
tương đương với:

\beforeverb
\begin{verbatim}
    total = total + x
\end{verbatim}
\afterverb
%
Khi vòng lặp được thực hiện, {\tt total} sẽ tích lũy tổng của
các phần tử; một biến được dùng theo cách này đôi khi còn được
gọi là {\bf biến tích lũy}.

\index{biến tích lũy!tính tổng}

Việc cộng các phần tử trong một danh sách là thao tác rất 
thường gặp, và vì vậy Python có sẵn một hàm {\tt sum}:

\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> sum(t)
6
\end{verbatim}
\afterverb
%
Một thao tác như thế này, thực hiện dồn một dãy các phần tử
vào một giá trị đơn lẻ, đôi khi còn được gọi là {\bf rút gọn}.

\index{rút gọn (dạng mẫu)}
\index{dạng mẫu!rút gọn}
\index{duyệt}

Đôi khi bạn muốn duyệt một danh sách trong khi đồng thời lại tạo
một danh sách khác. Chẳng hạn, hàm sau đây nhận vào một danh sách
các chuỗi và trả về một danh sách mới bao gồm các chuỗi với kiểu chữ in:

\beforeverb
\begin{verbatim}
def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
\end{verbatim}
\afterverb
%
{\tt res} được khởi tạo với một danh sách trống; mỗi lần chạy qua 
vòng lặp, ta thêm vào đó phần tử tiếp theo. Vì vậy, {\tt res} cũng
là một kiểu biến tích lũy khác.

\index{biến tích lũy!danh sách}

Một thao tác kiểu như \verb"capitalize_all" (chuyển chữ in toàn bộ) 
đôi khi được coi tương đương như việc {\bf 
đánh số} vì nó dùng một hàm (trong trường hợp này là phương thức {\tt
capitalize}) để ``đánh'' cho mỗi phần tử trong một dãy.

\index{đánh số (dạng mẫu)}
\index{dạng mẫu!đánh số}
\index{lọc (dạng mẫu)}
\index{dạng mẫu!lọc}

Một thao tác thường gặp khác là chọn một số các phần tử từ danh sách
và trả về một danh sách con. Chẳng hạn, hàm sau đây nhận vào một danh sách
các chuỗi và sau đó trả về một danh sách trong đó chỉ bao gồm các
chuỗi viết bằng chữ in:

\beforeverb
\begin{verbatim}
def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
\end{verbatim}
\afterverb
%
{\tt isupper} là một phương thức chuỗi trả về {\tt True} nếu như chuỗi
chỉ bao gồm các chữ cái viết in.

Một thao tác kiểu như \verb"only_upper" được gọi là {\bf lọc} vì nó chọn
ra một số các phần tử đồng thời lọc bỏ các phần tử khác.

Các thao tác thông dụng nhất với danh sách hầu như đều có thể 
biểu diễn được dưới dạng kết hợp của đánh số, lọc và rút gọn. 
Vì những thao tác này quá thông dụng nên Python cung cấp cho ta
nhưng đặc điểm ngôn ngữ để hỗ trợ chúng, bao gồm hàm có sẵn 
{\tt map} và một toán tử có tên là ``list comprehension.''

\index{danh sách!list comprehension}

\begin{ex}
\label{cumulative}
\index{tổng lũy tích}

Hãy viết một hàm trong đó nhận vào một danh sách các số và trả về
tổng lũy tích, nghĩa là một danh sách mới trong đó phần tử thứ $i$
chính là tổng của $i+1$ phần tử đầu trong danh sách nhận vào.
Chẳng hạn, tổng lũy tích của {\tt [1, 2, 3]} là
{\tt [1, 3, 6]}. 
\end{ex}


\section{Xóa các phần tử}

\index{phần tử!xóa}
\index{xóa phần tử trong danh sách}

Có một vài cách làm khác nhau để xóa phần tử khỏi một danh sách.
Nếu đã biết chỉ số của phần tử bạn cần xóa, bạn có thể dùng 
{\tt pop}:

\index{pop (phương thức)}
\index{phương thức!pop}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print t
['a', 'c']
>>> print x
b
\end{verbatim}
\afterverb
%
{\tt pop} thay đổi danh sách và trả lại phần tử mà ta vừa xóa 
khỏi danh sách.
Nếu bạn không cung cấp chỉ số, nó sẽ xóa và trả lại phần tử
cuối cùng.

Nếu không cần giá trị cần được loại khỏi danh sách, bạn có thể
dùng toán tử {\tt del}:

\index{del (toán tử)}
\index{toán tử!del}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%

Nếu bạn biết phần tử cần được xóa (nhưng không biết chỉ số), bạn có thể
dùng {\tt remove}:

\index{remove (phương thức)}
\index{phương thức!remove}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%
Giá trị trả về tử {\tt remove} là {\tt None}.

\index{None (giá trị đặc biệt)}
\index{giá trị đặc biệt!None}

Để xóa nhiều hơn một phần tử, bạn có thể dùng {\tt del} với
một lát cắt chỉ số:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print t
['a', 'f']
\end{verbatim}
\afterverb
%
Như thường lệ, lát cắt sẽ chọn ra tất cả những phần tử cho đến
trước (không bao gồm) chỉ số thứ hai.


\section{Danh sách và chuỗi}

\index{danh sách}
\index{chuỗi}
\index{dãy}

Một chuỗi là một dãy các kí tự và một danh sách là một dãy các
giá trị, nhưng một danh sách các kí tự lại không giống như một
chuỗi. Để chuyển từ một chuỗi sang một danh sách các kí tự, bạn
có thể dùng {\tt list}:

\index{list!hàm}
\index{hàm!list}

\beforeverb
\begin{verbatim}
>>> s = 'spam'
>>> t = list(s)
>>> print t
['s', 'p', 'a', 'm']
\end{verbatim}
\afterverb
%
Vì {\tt list} cũng giống như tên của một hàm dựng sẵn, nên bạn
cần tránh đặt nó làm tên một biến. Tôi cũng tránh dùng {\tt l} vì
nó trông rất giống như số {\tt 1}.  Vì vậy tôi thường dùng {\tt t}.

Hàm {\tt list} phá vỡ một chuỗi thành các kí tự riêng lẻ. Nếu muốn
phá vỡ chuỗi thành các từ riêng lẻ, bạn có thẻ dùng phương thức {\tt split}:

\index{split (phương thức)}
\index{phương thức!split}

\beforeverb
\begin{verbatim}
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> print t
['pining', 'for', 'the', 'fjords']
\end{verbatim}
\afterverb
%
Bạn có thể kèm theo một đối số là một {\bf dấu phân cách}
chính là kí tự được dùng để ngăn cách giữa các từ.
Ví dụ sau đây có sử dụng dấu gạch nối để phân cách:

\index{tùy chọn (đối số)}
\index{đối số!tùy chọn}
\index{dấu phân cách}

\beforeverb
\begin{verbatim}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
\end{verbatim}
\afterverb
%
{\tt join} là hàm ngược của {\tt split}.  Nó
nhận vào một dãy các chuỗi và
nối chúng lại. {\tt join} là một phương thức chuỗi,
vì vậy bạn phải gọi nó từ biến là dấu phân cách và
sau đó truyền vào tham biến là danh sách:

\index{join (phương thức)}
\index{phương thức!join}
\index{ghép nối}

\beforeverb
\begin{verbatim}
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> delimiter.join(t)
'pining for the fjords'
\end{verbatim}
\afterverb
%
Trong trường hợp này, biến phân cách (delimiter) là một
kí tự dấu cách, vì vậy {\tt join} đặt dấu cách giữa
hai từ liên tiếp. Để nối liền các chuỗi mà không bị
ngăn cách, bạn có thể dùng chuỗi rỗng,
\verb"''", vào vai trò của dấu phân cách.

\index{rỗng (chuỗi)}
\index{chuỗi!rỗng}


\section{Đối tượng và giá trị}

\index{đối tượng}
\index{giá trị}

Nếu ta thực hiện các lệnh gán sau:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%
Ta biết rằng cả {\tt a} và {\tt b} đều tham chiếu
đến một chuỗi, nhưng ta không biết rằng liệu chúng
có tham chiếu đến {\em cùng} một chuỗi không.
Sau đây là hai trường hợp có thể xảy ra:

\index{aliasing}

\beforefig
\centerline{\includegraphics{figs/list1.eps}}
\afterfig

Trong một trường hợp, {\tt a} và {\tt b} tham chiếu đến hai đối tượng
khác nhau nhưng có cùng giá trị. Trong trường hợp thứ hai, chúng cùng
tham chiếu đến một đối tượng.

\index{is (toán tử)}
\index{toán tử!is}

Để kiểm tra xem liệu hai biến có cùng tham chiếu đến một đối tượng 
hay không, bạn có thể dùng toán tử {\tt is}.

\beforeverb
\begin{verbatim}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
\end{verbatim}
\afterverb
%
Ở ví d này, Python chỉ tạo ra một đối tượng chuỗi, và cả
{\tt a} và {\tt b} đều tham chiếu đến nó.

Nhưng khi bạn tạo ra hai danh sách, bạn sẽ thu được
hai đối tượng riêng biệt:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
\end{verbatim}
\afterverb
%
Vì vậy sơ đồ trạng thái sẽ trông như thế này:

\index{trạng thái (sơ đồ)}
\index{sơ đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/list2.eps}}
\afterfig

Trong trường hợp này ta nói rằng hai danh sách là {\bf tương đương} nhau,
vì chúng có những phần tử giống nhau, nhưng không {\bf đồng nhất}, vì
chúng không cùng là một đối tượng. Nếu hai đối tượng đồng nhất nhau thì
đồng thời cũng tương đương nhau, nhưng ngược lại nếu chúng tương đương thì
không nhất thiết phải đồng nhất.

\index{tương đương}
\index{đồng nhất}

Đến giờ, ta đã dùng các khái niệm ``đối tượng'' và ``giá trị'' để thay thế
dduwwojc cho nhau, nhưng sẽ chính xác hơn nếu nói rằng mỗi đối tượng có
một giá trị. Nếu bạn thực hiện biểu thức {\tt [1,2,3]}, bạn sẽ có một đối
tượng mà giá trị của nó là một chuỗi các số nguyên. Nếu một danh sách khác
có những phần tử như vậy, ta nói rằng chúng có cùng giá trị, nhưng hai
danh sách này vẫn là những đối tượng khác nhau.

\index{đối tượng}
\index{giá trị}


\section{Tham chiếu bội}

\index{tham chiếu bội}

Nếu {\tt a} tham chiếu đến một đối tượng và bạn gán {\tt b = a},
thì cả hai biến sẽ cùng chỉ đến một đối tượng:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
\end{verbatim}
\afterverb
%
Sơ đồ trạng thái sẽ trông như thế này:

\index{trạng thái (sơ đồ)}
\index{sơ đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/list3.eps}}
\afterfig

Việc gắn một biến với một đối tượng được gọi là  {\bf
tham chiếu}. Ở ví dụ này, có hai tham chiếu đến cùng
một đối tượng

\index{tham chiếu}

Một đối tượng có nhiều tham chiếu thì cũng có nhiều tên,
và chúng ta nói rằng đối tượng này được {\bf tham chiếu bội}.

\index{thay đổi được}

Nếu như đối tượng được tham chiếu bội có thể thay đổi được,
thì những thay đổi thực hiện với tham chiếu này cũng sẽ ảnh
hưởng với tham chiếu kia:

\beforeverb
\begin{verbatim}
>>> b[0] = 17
>>> print a
[17, 2, 3]
\end{verbatim}
\afterverb
%
Mặc dù tính chất này có thể hữu dụng nhưng chắc chắn rất dễ gây lỗi.
Nhìn chung, để an toàn ta nên tránh tham chiếu bội khi thao tác với
các đối tượng thay đổi được.

\index{không thay đổi}

Với các đối tượng không thay đổi như chuỗi, tham chiếu bội không còn
là vấn đề. Trong ví dụ này:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%
Hầu như không có khác biệt nào trong việc liệu {\tt a} và {\tt b} 
có tham chiếu đến cùng một chuỗi hay không.


\section{Danh sách với vai trò như đối số}

\index{danh sách!vai trò làm đối số}
\index{đối số}
\index{đối số!danh sách}
\index{tham chiếu}
\index{tham biến}

Khi bạn truyền một danh sách vào trong hàm, thì hàm sẽ nhận được
một tham chiếu đến danh sách đó.
Nếu hàm thay đổi một tham biến danh sách, thì đoạn chương trình gọi
sẽ thấy được sự thay đổi đó. Chẳng hạn, \verb"delete_head" 
xóa phần tử đầu khỏi danh sách:

\beforeverb
\begin{verbatim}
def delete_head(t):
    del t[0]
\end{verbatim}
\afterverb
%
Đây là khi hàm này được dùng:

\beforeverb
\begin{verbatim}
>>> letters = ['a', 'b', 'c']
>>> delete_head(letters)
>>> print letters
['b', 'c']
\end{verbatim}
\afterverb
%
Tham biến {\tt t} và biến {\tt letters} là các tham chiếu bội
đến cùng một đối tượng. Sơ đồ ngăn xếp sẽ trông như sau:

\index{ngăn xếp (sơ đồ)}
\index{sơ đồ!ngăn xếp}

\beforefig
\centerline{\includegraphics{figs/stack5.eps}}
\afterfig

Vì danh sách được dùng chung bởi hai khung riêng biệt
nên tôi đã vẽ nó giữa hai khung này.

Điều quan trọng là phân biết được các phép thao tác nhằm
thay đổi danh sách và thao tác nhằm tạo những danh sách mới.
Chẳng hạn, phương thức {\tt append} thay đổi một danh sách,
nhưng toán tử {\tt +} lại tạo ra một danh sách mới:

\index{append (phương thức)}
\index{phương thức!append}
\index{danh sách!concatenation}
\index{concatenation!list}

\beforeverb
\begin{verbatim}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print t1
[1, 2, 3]
>>> print t2
None

>>> t3 = t1 + [3]
>>> print t3
[1, 2, 3]
>>> t2 is t3
False
\end{verbatim}
\afterverb

Khác biệt này có thể trở nên quan trọng khi bạn viết những
hàm lẽ ra được dùng để thay đổi danh sách. Chẳng hạn, hàm
sau đây {\em không} xóa được phần tử đầu của danh sách:

\beforeverb
\begin{verbatim}
def bad_delete_head(t):
    t = t[1:]              # SAI!
\end{verbatim}
\afterverb

Toán tử lát cắt sẽ tạo ra một danh sách mới và lệnh gán làm
cho {\tt t} tham chiếu đến đó, nhưng tất cả những điều này đều 
không thay đổi gì đến danh sách vốn được truyền vào với vai trò như một
đối số.

\index{lát cắt (toán tử)}
\index{toán tử!lát cắt}

Một cách làm khác là viết một hàm để tạo ra và trả lại một danh sách mới.
Chẳng hạn, {\tt tail} trả lại toàn bộ danh sách chỉ trừ phần tử đầu tiên:

\beforeverb
\begin{verbatim}
def tail(t):
    return t[1:]
\end{verbatim}
\afterverb
%
Hàm này sẽ giữ nguyên, không làm thay đổi danh sách ban đầu.
Sau đây là một cách dùng nó:

\beforeverb
\begin{verbatim}
>>> letters = ['a', 'b', 'c']
>>> rest = tail(letters)
>>> print rest
['b', 'c']
\end{verbatim}
\afterverb


\begin{ex}

Hãy viết một hàm có tên là {\tt chop} trong đó nhận vào một danh sách
và thay đổi nó, xóa đi các phần tử đầu và phần tử cuối, rồi trả về {\tt None}.

Sau đó viết một hàm có tên là {\tt middle} trong đó nhận vào một danh
sách và trả về một danh sách mới bao gồm tất cả những phần tử chỉ trừ
hai phần tử đầu và cuối của danh sách gốc.

\end{ex}


\section{Gỡ lỗi}
\index{gỡ lỗi}

Sự bất cẩn khi dùng danh sách (và các đối tượng thay đổi được khác)
có thể dẫn đến mất thời gian hàng giờ đồng hồ để gỡ lỗi. Sau đây là
một số lỗi thường gặp và cách phòng tránh:

\begin{enumerate}

\item Đừng quên rằng hầu hết các phương thức làm việc với danh sách
  đều thay đổi danh sách (trong vai trò đối số) và trả về
  {\tt None}. Điều này ngược lại với các phương thức chuỗi
  trong đó trả về một chuỗi mới và giữ nguyên chuỗi cũ.
  
Nếu bạn quen viết mã lệnh với chuỗi như sau:

\beforeverb
\begin{verbatim}
word = word.strip()
\end{verbatim}
\afterverb

thì cũng rất dễ bị hấp dẫn bởi cách viết mã lệnh này đối với danh sách:

\beforeverb
\begin{verbatim}
t = t.sort()           # SAI!
\end{verbatim}
\afterverb

\index{sort (phương thức)}
\index{phương thức!sort}

Vì {\tt sort} trả về {\tt None} nên thao tác tiếp theo
thực hiện với {\tt t} dường như sẽ bị hỏng.

Trước khi dùng những phương thức và toán tử thực hiện trên danh sách, bạn 
cần đọc kĩ tài liệu và sau đó thử chúng ở chế độ tương tác lệnh. Các
phương thức và toán tử có chung giữa danh sách và những kiểu dãy khác
(như chuỗi) được mô tả ở \url{docs.python.org/lib/typesseq.html}.
Các phương thức và toán tử chỉ áp dụng được cho những dãy thay đổi
được có ở \url{docs.python.org/lib/typesseq-mutable.html}.


\item Chọn một cách viết mã lệnh và dùng nó một cách thống nhất.

Một trong số các nguyên nhân gây ra rắc rối liên quan đến
danh sách là có quá nhiều cách thực hiện cùng một công việc.
Chẳng hạn để xóa một phần tử khỏi một danh sách, bạn có thể dùng
{\tt pop}, {\tt remove}, {\tt del}, hoặc thậm chí một câu lệnh
gán với lát cắt.

Để thêm vào một phần tử, bạn có thể dùng phương thức {\tt append}
hoặc toán tử {\tt +} Nhưng đừng quên rằng hai cách sau đây là đúng:

\beforeverb
\begin{verbatim}
t.append(x)
t = t + [x]
\end{verbatim}
\afterverb

và tất cả những cách viết sau đều sai:

\beforeverb
\begin{verbatim}
t.append([x])          # SAI!
t = t.append(x)        # SAI!
t + [x]                # SAI!
t = t + x              # SAI!
\end{verbatim}
\afterverb

Hãy thử lại tất cả những ví dụ trên trong chế độ tương tác lệnh
và nắm vững được tác dụng của chúng. Lưu ý rằng chỉ có lệnh 
cuối cùng mới gây ra một lỗi thực thi; còn ba lệnh trên nó đều
hợp lệ, nhưng thực hiện việc mà chúng ta không cần đến.


\item Tạo ra các bản sao để tránh tham chiếu bội.

\index{tham chiếu bội!tránh bằng sao chép}
\index{sao chép!để tránh tham chiếu bội}

Nếu muốn dùng một phương thức như {\tt sort} để thay đổi
đối số (là danh sách) nhưng cũng cần giữ cả danh sách ban đầu,
bạn có thể tạo một bản sao.

\beforeverb
\begin{verbatim}
orig = t[:]
t.sort()
\end{verbatim}
\afterverb

Ở ví dụ này bạn cũng có thẻ dùng hàm có sẵn {\tt sorted}, với
trả lại một danh sách mới, được sắp xếp, đồng thời giữ nguyên
danh sách ban đầu. Nhưng trong trường hợp đó bạn cần tránh lấy
 {\tt sorted} để đặt cho tên biến!

\end{enumerate}



\section{Thuật ngữ}

\begin{description}

\item[danh sách:] Một dãy các giá trị.
\index{danh sách}

\item[phần tử:] Một trong số các giá trị của danh sách (hoặc một dãy
nói chung).
\index{phần tử}

\item[chỉ số:] Một giá trị số nguyên để chỉ định một phần tử trong danh sách.
\index{phần tử}

\item[danh sách lồng ghép:] Một danh sách đóng vai trò là phần tử trong một
danh sách khác.
\index{danh sách lồng ghép}

\item[duyệt danh sách:] Cách truy cập tuần tự từng phần tử trong danh sách.
\index{danh sách!duyệt}

\item[đánh số:] Mối quan hệ trong đó từng phần tử của một tập hợp tương ứng
với một phần tử trong tập hợp khác. Chẳng hạn, một danh sách là một phép
đánh số giữa các chỉ số với các phần tử.
\index{đánh số}

\item[biến tích lũy:] Một biến được dùng trong vòng lặp để cộng dồn
hoặc, nói chung là tích lũy để thu được một kết quả.
\index{biến tích lũy}

\item[gán rút gọn:] Một lệnh nhằm cập nhật giá trị của một biến bằng cách
dùng toán tử kiểu như \verb"+=".
\index{lệnh gán!rút gọn}
\index{rút gọn (lệnh gán)}

\index{duyệt}

\item[rút gọn:] Một dạng mẫu xử lý trong đó bao gồm duyệt một dãy và 
tính tích lũy với từng phần tử để gộp thành một kết quả cuối cùng.
\index{rút gọn (dạng mẫu)}
\index{dạng mẫu!rút gọn}

\item[map:] Một dạng mẫu xử lí duyệt chuỗi và thực hiện thao tác 
tính toán với từng phần tử.
\index{map (dạng mẫu)}
\index{dạng mẫu!map}

\item[lọc:] Một dạng mẫu xử lí duyệt chuỗi và lựa chọn những phần tử
thỏa mãn một điều kiện nào đó.
\index{lọc (dạng mẫu)}
\index{dạng mẫu!lọc}

\item[đối tượng:] Thứ mà biến có thể tham chiếu đến được. Một đối tượng có
kiểu và giá trị riêng của nó.
\index{đối tượng}

\item[tương đương:] Có cùng giá trị.
\index{tương đương}

\item[đồng nhất:] Cùng là một đố tượng (và mặc nhiên là tương đương).
\index{đồng nhất}

\item[tham chiếu:] Sự liên hệ giữa một biến và giá trị của nó.
\index{tham chiếu}

\item[tham chiếu bội:] Trường hợp trong đó hai hoặc nhiều biến cùng
tham chiếu đến một đối tượng.
\index{tham chiếu bội}

\item[dấu phân cách:] Một kí tự hoặc chuỗi được dùng để chỉ định những chỗ
mà chuỗi cho trước cần được tách. 
\index{dấu phân cách}

\end{description}


\section{Bài tập}

\begin{ex}
Hãy viết một hàm có tên là \verb"is_sorted" trong đó nhận vào tham biến
là một danh sách và trả về {\tt True} nếu danh sách đã được xếp teho 
thứ tự tăng dần và {\tt False} trong trường hợp còn lại. Bạn có thể 
giả sử rằng (qua khâu xử lí sơ bộ) danh sách chứa các phần tử có thể so sánh được bằng các
toán tử quan hệ {\tt <}, {\tt >}, v.v.

\index{xử lí sơ bộ}

Chẳng hạn, \verb"is_sorted([1,2,2])" sẽ trả về {\tt True}
và \verb"is_sorted(['b','a'])" trả về {\tt False}.
\end{ex}


\begin{ex}
\label{anagram}

\index{đảo chữ}

Hai từ là đảo của nhau nếu bạn có thể đảo các chữ cái trong từ này
để hình thành nên từ kia. Hãy viết một hàm có tên là \verb"is_anagram"
nhận vào hai chuỗi và trả về {\tt True} nếu chúng là đảo của nhau.
\end{ex}


\begin{ex}
\label{duplicate}


Nghịch lý ``Ngày sinh nhật'':

\begin{enumerate}

\index{nghịch lý Ngày sinh nhật}
\index{trùng nhau}

\item Hãy viết một hàm có tên là \verb"has_duplicates" trong đó
nhận vào một danh sách và trả về {\tt True} nếu có bất kì phần tử nào
xuất hiện nhiều hơn một lần. Danh sách ban đầu không được thay đổi.

\item Nếu như có 23 sinh viên trong lớp học của bạn, khả năng có được
hai người trùng ngày sinh với nhau là bao nhiêu? Bạn có thể ước lượng
khả năng (xác suất) này bằng cách phát sinh ra mẫu ngẫu nhiên gồm
23 ngày sinh rồi kiểm tra sự trùng lặp. Gợi ý: Bạn có thể phát sinh
những ngày sinh ngẫu nhiên bằng hàm {\tt randint} trong module
{\tt random}.

\index{random (module)}
\index{module!random}
\index{randint (hàm)}
\index{hàm!randint}

\end{enumerate}

Bạn có thể tìm hiểu thêm về bài toán này tại 
\url{wikipedia.org/wiki/Birthday_paradox}, và có thể xem lời giải của tôi
tại \url{thinkpython.com/code/birthday.py}.

\end{ex}


\begin{ex}

\index{trùng nhau}
\index{duy nhất}

Hãy viết một hàm có tên là \verb"remove_duplicates" trong đó nhận vào
một danh sách và trả về một danh sách mới chỉ gồm các phần tử duy nhất
(theo nghĩa không trùng nhau) từ danh sách gốc. Gợi ý: chúng không
nhất thiết phải xếp theo cùng thứ tự.
\end{ex}


\begin{ex}
\index{append (phương thức)}
\index{phương thức!append}
\index{danh sách!kết nối}
\index{kết nối!danh sách}

Hãy viết một hàm để đọc file {\tt words.txt} và tạo nên một
danh sách với mỗi phần tử cho một từ. Hãy viết hai dạng khác
nhau của hàm này, một dạng dùng phương thức {\tt append} và
dạng kia dùng cách viết {\tt t = t + [x]}.  Dạng nào chạy
tốn thời gian hơn? Tại sao?

Bạn có thể xem lời giải của tôi tại \url{thinkpython.com/code/wordlist.py}.
\end{ex}


\begin{ex}
\label{wordlist1}
\label{bisection}

\index{thành viên!tìm kiếm nhị phân}
\index{tìm kiếm nhị phân}
\index{nhị phân (tìm kiếm)}

Để kiểm tra xem một từ có trong danh sách các từ hay không, bạn 
có thể dùng toán tử {\tt in}, nhưng cách này sẽ rất chậm vì nó phải tìm
qua danh sách theo đúng thứ tự.

Vì các từ đã được xếp theo thứ tự ABC, nên chúng ta có thể tăng tốc
bằng cách tìm kiếm nhị phân, điều này cũng hơi giống với cách ta tra
từ điển. Ta bắt đầu bằng việc mở giữa quyển từ điển và kiểm tra xem liệu
từ cần tra có đứng trước từ nằm giữa trong danh sách hay không. Nếu
đúng vậy, ta tìm kiếm nửa đầu của từ điển theo cách tương tự. Còn nếu
không đúng, ta sẽ tìm kiếm nửa cuối.

Dù trường hợp nào xảy ra đi nữa, phạm vi tìm kiếm đã giảm xuống
chỉ còn một nửa. Nếu danh sách từ ban đầu có 113.809 từ, thì chỉ cần
khoảng 17 bước là tìm ra được từ hoặc kết luận rằng từ cần tìm không
có trong danh sách.

Hãy viết một hàm có tên là {\tt bisect} nhận vào một danh sách đã được
sắp xếp và giá trị cần tìm, sau đó trả lại chỉ số của giá trị trong 
danh sách nếu có, hoặc là {\tt None} nếu không.

\index{bisect (module)}
\index{module!bisect}

Hoặc bạn cũng có thể đọc tài liệu viết về module {\tt bisect} rồi
áp dụng nó!
\end{ex}

\begin{ex}
\index{cặp từ đảo}

Hai từ được gọi là một ``cặp đảo'' nếu như từ này là dạng viết dảo 
ngược của từ kia. Hãy viết một chương trình để tìm ra tất cả những
cặp từ dảo có trong danh sách từ.
\end{ex}

\begin{ex}
\index{cặp từ đan cài}

Hai từ được gọi là ``đan cài'' nhau nếu như lần lượt lấy mỗi chữ cái
của từng từ ta xếp lại được một từ mới\footnote{Bài tập này được bắt ngưồn
từ một ví dụ trong trang \url{puzzlers.org}.}.  Chẳng hạn, ``shoe'' và ``cold''
đan cài nhau để tạo ra ``schooled.''

\begin{enumerate}

\item Hãy viết một chương trình tìm ra tất cả những cặp từ đan cài.
  Gợi ý: đừng phát sinh đầy đủ tất cả các cặp từ để kiểm tra!

\item Bạn có thể tìm được từ đan cài ba lần; nghĩa là chia lần lượt các chữ cái
  thành ba nhóm theo đúng thứ tự thì ta được ba từ khác nhau?

\end{enumerate}
\end{ex}


\chapter{Từ điển}
\index{từ điển}

\index{từ điển}
\index{kiểu!dict}
\index{khóa}
\index{cặp khóa-trị}
\index{chỉ số}

{\bf Từ điển} giống như một danh sách, nhưng khái quát hơn. Trong
một danh sách, các chỉ số phải là số nguyên; trong từ điển chúng 
có thể thuộc về (gần như) bất kì kiểu dữ liệu nào.

Bạn có thể nghĩ về từ điển như một phép khớp giữa một tập hợp các
chỉ số (cũng gọi là {\bf khóa}) và một tập hợp các giá trị.
Mỗi khóa được đánh cho một giá trị. Sự liên hệ giữa khóa và 
giá trị được gọi là một {\bf cặp khóa-trị} và đôi khi được gọi là
một {\bf mục}.

Ví dụ như chúng ta lập một từ điển để khớp tương ứng giữa các từ
tiếng Anh và tiếng Tây Ban Nha, vì vậy tất cả các khóa và các
giá trị đều là những chuỗi.

Hàm {\tt dict} sẽ tạo ra một từ điển mới mà không có mục nào.
Vì {\tt dict} là tên của một hàm có sẵn, bạn không nên lấy tên này
để đặt cho một biến.

\index{dict (hàm)}
\index{hàm!dict}

\beforeverb
\begin{verbatim}
>>> eng2sp = dict()
>>> print eng2sp
{}
\end{verbatim}
\afterverb

Cặp ngoặc nhọn, \verb"{}", biểu thị một từ điển rỗng. Để thêm
các mục vào trong một từ điển, ta có thể dùng cặp ngoặc vuông:

\index{ngoặc nhọn}

\beforeverb
\begin{verbatim}
>>> eng2sp['one'] = 'uno'
\end{verbatim}
\afterverb
%
Dòng lệnh này tạo ra một mục trong đó khớp tương ứng khóa 
{\tt 'one'} với giá trị \verb"'uno'".  Nếu in lại nội dung
từ điển, ta sẽ thấy một cặp khóa-trị với dấu hai chấm ngăn cách
giữa phần khóa và phần trị:

\beforeverb
\begin{verbatim}
>>> print eng2sp
{'one': 'uno'}
\end{verbatim}
\afterverb
%
Hình thức hiển thị kết quả như vậy cũng dùng được để nhập
dữ liệu. Chẳng hạn, bạn có thể tạo một từ điển mới gồm ba mục:

\beforeverb
\begin{verbatim}
>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
\end{verbatim}
\afterverb
%
Nhưng nếu in {\tt eng2sp}, có thể bạn sẽ thấy ngạc nhiên:

\beforeverb
\begin{verbatim}
>>> print eng2sp
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
\end{verbatim}
\afterverb
%
Thứ tự của các cặp khóa-trị không còn giữ nguyên nữa. Thật ra, 
nếu bạn gõ lại ví dụ trên vào máy tính của mình, có thể kết
quả còn khác nữa. Nói chung, không thể biết trước thứ tự các mục 
trong một từ điển.

Tuy nhiên điều đó chẳng quan trọng vì các phần tử trong từ điển
không bao giờ được chỉ định bởi các chỉ số nguyên. Thay vào đó, bạn
dùng các khóa để tra tìm những giá trị tương ứng:

\beforeverb
\begin{verbatim}
>>> print eng2sp['two']
'dos'
\end{verbatim}
\afterverb
%
Khóa {\tt 'two'} luôn được khớp với giá trị \verb"'dos'" vì vậy
thứ tự của các mục không quan trọng.

Nếu như khóa cần tìm không xuất hiện trong từ điển, bạn sẽ nhận được
một biệt lệ:

\index{biệt lệ!KeyError}
\index{KeyError}

\beforeverb
\begin{verbatim}
>>> print eng2sp['four']
KeyError: 'four'
\end{verbatim}
\afterverb
%
Hàm {\tt len} có tác dụng trên từ điển; nó trả lại số cặp khóa-trị:

\index{len (hàm)}
\index{hàm!len}

\beforeverb
\begin{verbatim}
>>> len(eng2sp)
3
\end{verbatim}
\afterverb
%
Toán tử {\tt in} cũng có tác dụng trên từ điển; nó cho chúng ta biết liệu
có một {\em khóa} trong từ điển với tên gọi cho trước không (chứ không phải
là có giá trị với tên gọi như vậy).

\index{thành viên!từ điển}
\index{in (toán tử)}
\index{toán tử!in}

\beforeverb
\begin{verbatim}
>>> 'one' in eng2sp
True
>>> 'uno' in eng2sp
False
\end{verbatim}
\afterverb
%
Để xem rằng có một giá trị nào đó có trong từ điển với tên gọi cho trước không,
bạn có thể dùng phương thức {\tt values}, để trả về các giá trị như một
danh sách, và sau đó dùng toán tử {\tt in}:

\index{values (phương thức)}
\index{phương thức!values}

\beforeverb
\begin{verbatim}
>>> vals = eng2sp.values()
>>> 'uno' in vals
True
\end{verbatim}
\afterverb
%
Toán tử {\tt in} dùng các thuật toán khác nhau đối với danh sách và với từ điển.
Đối với danh sách, nó dùng một thuật toán tìm kiếm, như trong Mục~\ref{find}.  
Khi danh sách dài hơn, thời gian tìm kiếm cũng tăng lên tỉ lệ thuận với độ dài.
Đối với từ điển, Python dùng một thuật toán có tên là {\bf bảng băm} (hashtable)
với một tính chất ưu việt: toán tử {\tt in} được thực hiện với thời gian 
gần như không đổi bất kể độ dài của từ điển là bao nhiêu. Tôi sẽ không giải 
thích làm thế nào để có được điều đó, nhưng bạn có thể xem thêm ở
\url{wikipedia.org/wiki/Hash_table}.

\index{mảng băm}

\begin{ex}
\label{wordlist2}

\index{set (thành viên)}
\index{thành viên!set}

Hãy viết một hàm để đọc vào các từ trong {\tt words.txt} và lưu chúng
như những khóa trong một từ điển. Các giá trị bằng bao nhiêu thì
không quan trọng. Sau đó bạn có thể dùng toán tử {\tt in} để kiểm
tra nhanh xem một chuỗi cần tìm có trong từ điển hay không.

Nếu bạn đã làm Bài tập~\ref{wordlist1}, bạn có thể so sánh tốc độ
của lời giải này với toán tử {\tt in} dành cho danh sách cùng phép
tìm kiếm nhị phân.

\end{ex}


\section{Từ điển như một tập hợp các biến đếm}
\label{histogram}

\index{biến đếm}

Giả sử như bạn có một chuỗi và cần đến xem trong chuỗi đó, mỗi chữ cái
xuất hiện bao nhiêu lần. Có một vài cách để làm điều đó:

\begin{enumerate}

\item Bạn có thể tạo ra 26 biến, mỗi biến cho một chữ cái trong bảng.
Sau đó bạn duyệt chuỗi và với mỗi kí tự, tăng biến đếm tương ứng lên
một đơn vị, có thể dùng một câu lệnh điều kiện nhiều nhánh.

\item Bạn có thể tạo ra một danh sách gồm 26 phần tử. Sau đó bạn
chuyển đổi mỗi chữ cái thành một số (dùng hàm có sẵn 
{\tt ord}), dùng số này như là một chỉ số trong danh sách, và
tăng biến đếm tương ứng lên.

\item Bạn có thể tạo ra một từ điển với các kí tự như những khóa
và biến đếm như những giá trị tương ứng. Lần đầu khi bắt gặp một
kí tự, bạn thêm một mục vào từ điển. Những lần sau đó thì tăng
dần biến đếm cho những mục đã có trong từ điển.

\end{enumerate}

Các cách làm trên đây đều giống nhau về thao tác tính toán, nhưng
khác nhau về cách thực hiện tính toán đó.

\index{cách thực hiện}

{\bf Cách thực hiện} là một phương pháp tính toán; một số
cách thực hiện tốt hơn số còn lại. Chẳng hạn, thực hiện kiểu 
từ điển có lợi rằng chúng ta không cần biết trước là chữ cái nào 
sẽ xuất hiện trong chuỗi và chỉ cần dành chỗ cho những chữ cái
thực sự xuất hiện.

Đoạn mã có thể được viết như sau:

\beforeverb
\begin{verbatim}
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
\end{verbatim}
\afterverb
%
Tên của hàm là {\bf histogram}, chính là một thuật ngữ ngành thống kê 
để chỉ tập hợp các tần số.

\index{histogram}
\index{tần số}
\index{duyệt}

Dòng thứ nhất của hàm nhằm tạo ra một từ điển rỗng. Vòng lặp {\tt for} 
làm nhiệm vụ duyệt chuỗi. Qua mỗi vòng lặp, nếu kí tự  {\tt c} không có
trong từ điển, ta sẽ tạo ra một mục mới với khóa {\tt c} và giá trị ban đầu
bằng 1 (vì ta đã bắt gặp kí tự này một lần). Nếu {\tt c} đã có trong từ điển
thì ta sẽ tăng thêm 1 cho {\tt d[c]}.

\index{histogram}

Sau đây là tác dụng của nó:

\beforeverb
\begin{verbatim}
>>> h = histogram('brontosaurus')
>>> print h
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}
\end{verbatim}
\afterverb
%
Bảng phân bố tần số này cho thấy các chữ cái {\tt 'a'} và \verb"'b'"
xuất hiện một lần; \verb"'o'" xuất hiện hai lần, v.v.

\begin{ex}

\index{get (phương thức)}
\index{phương thức!get}

Từ điển có một phương thức gọi là {\tt get} nhận vào một khóa và
một giá trị mặc định. Nếu khóa này có xuất hiện trong từ điển, 
{\tt get} sẽ trả lại giá trị tương ứng; ngược lại nó sẽ trả về
giá trị mặc định nói trên. Chẳng hạn:

\beforeverb
\begin{verbatim}
>>> h = histogram('a')
>>> print h
{'a': 1}
>>> h.get('a', 0)
1
>>> h.get('b', 0)
0
\end{verbatim}
\afterverb
%
Hãy dùng {\tt get} để viết {\tt histogram} theo cách gọn gàng hơn. 
Bạn cần loại bỏ bớt một lệnh {\tt if}.
\end{ex}


\section{Thao tác lặp trong từ điển}

\index{từ điển!lặp}
\index{lặp!từ điển}
\index{duyệt}

Nếu bạn dùng một từ điển trong một lệnh {\tt for}, nó sẽ duyệt các
khóa của từ điển này. Chẳng hạn, \verb"print_hist" sẽ in các khóa
cùng với giá trị tương ứng:

\beforeverb
\begin{verbatim}
def print_hist(h):
    for c in h:
        print c, h[c]
\end{verbatim}
\afterverb
%
Và kết quả đầu ra sẽ có dạng sau:

\beforeverb
\begin{verbatim}
>>> h = histogram('parrot')
>>> print_hist(h)
a 1
p 1
r 2
t 1
o 1
\end{verbatim}
\afterverb
%
Một lần nữa ta thấy các khóa không xếp theo thứ tự cụ thể nào.

\begin{ex}

\index{keys (phương thức)}
\index{phương thức!keys}

Từ điển có một phương thức gọi là {\tt keys} để trả về các khóa
của bản thân nó, dưới dạng một danh sách không 
xếp theo thứ tự.

Hãy sửa \verb"print_hist" để in ra các khóa và giá trị theo 
thứ tự bảng chữ cái.

\end{ex}



\section{Tra ngược}

\index{từ điển!tra}
\index{từ điển!tra ngược}
\index{tra, từ điển}
\index{tra ngược, từ điển}

Cho trước một từ điẻn {\tt d} và khóa {\tt k}, ta dễ dàng tìm
được giá trị tương ứng {\tt v = d[k]}.  Thao tác này được gọi là
{\bf tra}.

Nhưng nếu bạn có {\tt v} và muốn tìm {\tt k} thì sao? 
Bạn gặp phải hai vấn đề: thứ nhất, có thể có nhiều khóa tương ứng
với giá trị {\tt v}. Tùy từng trường hợp cụ thể, bạn có thể chọn
một hoặc lập một danh sách chứa tất cả các khóa đó. Thứ hai, 
không có một dạng cú pháp đơn giản nào giúp {\bf tra ngược};
bạn phải thực hiện tìm kiếm.

Sau đây là một hàm nhận vào một giá trị và trả về khóa đầu tiên
mà khớp với giá trị đó:

\beforeverb
\begin{verbatim}
def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise ValueError
\end{verbatim}
\afterverb
%
Hàm này là một ví dụ nữa minh họa cho dạng mẫu tìm kiếm, nhưng nó
có một đặc điểm mà trước đây ta chưa từng bắt gặp, đó là {\tt raise}.
Lệnh {\tt raise} gây ra một biệt lệ; trong trường hợp này là {\tt
  ValueError}, nói chung thường dduwwojc dùng để chỉ rằng có 
điều gì đó không ổn với giá trị của một tham biến.

\index{tìm kiếm}
\index{dạng mẫu!tìm kiếm}
\index{raise (lệnh)}
\index{lệnh!raise}
\index{biệt lệ!ValueError}
\index{ValueError}

Nếu ta đến cuối vòng lặp, nghĩa là {\tt v} không xuất hiện trong
từ điển như một giá trị, thì ta sẽ gây ra một biệt lệ.

Sau đây là một ví dụ tra ngược thành công:

\beforeverb
\begin{verbatim}
>>> h = histogram('parrot')
>>> k = reverse_lookup(h, 2)
>>> print k
r
\end{verbatim}
\afterverb
%
Và một ví dụ không thành công:

\beforeverb
\begin{verbatim}
>>> k = reverse_lookup(h, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 5, in reverse_lookup
ValueError
\end{verbatim}
\afterverb
%
Kết quả nhận được khi bạn gây ra biệt lệ cũng giống như khi
Python gây ra: sẽ có thông báo lỗi cùng việc dò ngược về
vị trí xảy ra lỗi.

\index{dò ngược}
\index{tùy chọn (tham biến)}
\index{tham biến!tuỳ chọn}

Lệnh {\tt raise} nhận một tham biến tùy chọn là thông bào lỗi cụ thể.
Chẳng hạn:

\beforeverb
\begin{verbatim}
>>> raise ValueError, 'gia tri khong xuat hien trong tu dien'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: gia tri khong xuat hien trong tu dien
\end{verbatim}
\afterverb
%
Việc tra ngược chậm hơn nhiều so với tra xuôi; nếu bạn phải thường
xuyên thực hiện thao tác này, hoặc khi từ điển rất lớn, chương trình
sẽ chạy chậm.

\begin{ex}
Hãy sửa \verb"reverse_lookup" sao cho nó lập và trả về một danh sách
của {\em tất cả} các khóa khớp với {\tt v}, hoặc một danh sách rỗng
nếu không có khóa nào như vậy.
\end{ex}


\section{Từ điển và danh sách}

Danh sách có thể đóng vai trò làm giá trị trong từ điển. Chẳng hạn,
nếu bạn có một từ điển khớp những chữ cái với tần số xuất hiện của 
chúng, một việc có thể làm là đảo ngược nó; nghĩa là tạo ra một từ điẻn
khớp giữa tần số và chữ cái. Vì một số chữ cái có thể có cùng tần số,
nên mỗi giá trị trong từ điển ngược phải là một danh sách chữ cái.

\index{từ điển!ngược}

Sau đây là một hàm để đảo ngược từ điển:

\beforeverb
\begin{verbatim}
def invert_dict(d):
    inv = dict()
    for key in d:
        val = d[key]
        if val not in inv:
            inv[val] = [key]
        else:
            inv[val].append(key)
    return inv
\end{verbatim}
\afterverb
%
Qua mỗi vòng lặp, {\tt key} nhận một khóa từ {\tt d} và 
{\tt val} nhận giá trị tương ứng. Nếu {\tt val} không có trong {\tt inv},
nghĩa là chúng ta chưa từng bắt gặp nó, vì vậy chúng ta sẽ tạo ra
một mục mới và khởi tạo nó là một {\bf danh sách đơn} (một danh sách
chỉ chứa một phần tử). Ngược lại nếu đã thấy giá trị này từ trước, ta
sẽ điền thêm khóa tương ứng vào danh sách.

\index{singleton}

Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
>>> hist = histogram('parrot')
>>> print hist
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
>>> inv = invert_dict(hist)
>>> print inv
{1: ['a', 'p', 't', 'o'], 2: ['r']}
\end{verbatim}
\afterverb
%
Và sau đây là một sơ đồ chỉ {\tt hist} và {\tt inv}:

\index{trạng thái (sơ đồ)}
\index{sơ đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/dict1.eps}}
\afterfig

Từ điển được biểu diễn bởi một khung vời kiểu {\tt dict} phía trên nó
và các cặp khóa-trị bên trong. Nếu như các giá trị là số nguyên, số
có phần thập phân hoặc chuỗi, tôi thường vẽ chúng bên trong khung. Còn
danh sách thì tôi thường vẽ bên ngoài khung, để giữ cho sơ đồ được 
đơn giản.

Danh sách có thể là giá trị trong từ điển, như trong ví dụ này, nhưng
không thể là khóa. Sau đây là hậu quả nếu bạn thử điều này:

\index{TypeError}
\index{biệt lệ!TypeError}


\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> d = dict()
>>> d[t] = 'oops'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: list objects are unhashable
\end{verbatim}
\afterverb
%
Trước đây tôi đã đề cập rằng một từ điển được thực hiện bằng cách
dùng một mảng băm và điều đó có nghĩa là các khóa phải {\bf băm được}.

\index{hàm băm}
\index{có thể băm}

Một {\bf hàm băm} là một hàm nhận vào một giá trị (có kiểu bất kì)
và trả lại một số nguyên. Từ điển sử dụng những số nguyên này,
gọi là các giá trị hash, để lưu trữ và tra những cặp khóa-trị.

\index{tính không thay đổi}

Hệ thống này làm việc tốt nếu các khóa không thay đổi được. 
Nhưng nếu các khóa thay đổi được, như danh sách, thì mọi việc
tồi tệ có thể xảy ra. Chẳng hạn, khi bạn tạo ra một cặp khóa-trị,
Python tính hàm băm cho các khóa và lưu trữ chúng ở những địa chỉ tương
ứng. Nếu bạn thay đổi khóa và lại băm chúng thì sẽ đến những
địa chỉ khác. Trong trường hợp đó bạn có thể có hai mục cho cùng
một khóa, hoặc có thể không tìm được khóa; và dù thế nào thì 
từ điển cũng không hoạt động đúng.

Đó là lí do tại sao khóa phải băm được, và tại sao các kiểu dữ liệu
thay đổi được như danh sách thì không dùng được làm khóa. Cách 
đơn giản nhất để khắc phục hạn chế này là dùng các {\em bộ}, mà 
ta sẽ xét đến trong chương sau.

Vì từ điển có tính thay đổi được, bản thân chúng không thể dùng làm khóa,
nhưng chúng {\em có thể} dùng vào vai trò giá trị.

\begin{ex}
Hãy đọc tài liệu về phương thức {\tt setdefault} của từ điển và
dùng nó để viết một dạng gọn hơn cho \verb"invert_dict".

\index{setdefault (phương thức)}
\index{phương thức!setdefault}

\end{ex}


\section{Giá trị nhớ}

Nếu đã thử nghịch hàm {\tt fibonacci} ở 
Mục~\ref{one more example}, bạn có thể nhận thấy đối số bạn nhập vào
càng lớn thì chương trình chạy càng lâu.
Hơn nữa, thời gian chạy của chương trình tăng vọt một cách đáng kể.

\index{fibonacci (hàm)}
\index{hàm!fibonacci}

Để hiểu được tại sao, hãy xét {\bf đồ thị gọi} này của hàm
{\tt fibonacci} với {\tt n=4}:

\beforefig
\centerline{\includegraphics[height=2in]{figs/fibonacci.eps}}
\afterfig

Một đồ thị gọi cho thấy một loạt những khung biểu diễn hàm, với các đường
nối giữa khung hàm này với các khung hàm mà nó gọi đến. Trên đỉnh của đồ thị,
{\tt fibonacci} với {\tt n=4} gọi {\tt fibonacci} với {\tt
n=3} và {\tt n=2}.  Đến lượt mình, {\tt fibonacci} với {\tt n=3} lại gọi
{\tt fibonacci} với {\tt n=2} và {\tt n=1}.  Và cứ như vậy.

\index{khung hàm}
\index{khung}
\index{đồ thị gọi}

Hãy đến xem có bao nhiêu lần {\tt fibonacci(0)} và {\tt fibonacci(1)} được
gọi đến. Đây là một lời giải rất kém hiệu quả, và càng tồi hơn khi đối số
càng lớn.

\index{giá trị nhớ}

Một cách giải quyết là theo dõi những giá trị đã được tính bằng cách 
lưu nó vào trong một từ điển. Một giá trị đã tính trước rồi được lưu để
sau này dùng được gọi là một {\bf giá trị nhớ}\footnote{Xem
  \url{wikipedia.org/wiki/Memoization}.}.  Sau đây là một
cách thực hiện {\tt fibonacci} có dùng giá trị nhớ:

\beforeverb
\begin{verbatim}
known = {0:0, 1:1}

def fibonacci(n):
    if n in known:
        return known[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    return res
\end{verbatim}
\afterverb
%
{\tt known} là một từ điển theo dõi các số Fibonacci mà ta đã biết.
Nó bắt đầu với hai mục: 0 khớp với 0 và 1 khớp với 1.

Mỗi khi {\tt fibonacci} được gọi, nó sẽ kiểm tra {\tt known}.
Nếu kết quả đã có ở đấy rồi, nó có thể trả lại lập tức. Còn nếu không,
nó phải tính giá trị mới, bổ sung vào từ điển, và trả lại giá trị này.


\begin{ex}
Hãy chạy hàm {\tt fibonacci} trên và phiên bản ban đầu của hàm này
với một loạt các tham số rồi so sánh thời gian thực hiện của chúng.
\end{ex}


\section{Biến toàn cục}

\index{biến!toàn cục}

Trong ví dụ trước, {\tt known} được tạo ra bên ngoài hàm,
vì vậy nó thuộc về một khung đặc biệt có tên là \verb"__main__".
Các biến trong \verb"__main__" đôi khi được gọi là {\bf toàn cục}
vì chúng có thể được truy cập từ bất kì hàm nào. Khác với các
biến địa phương, mà sẽ biến mất ngay sau khi hàm kết thúc, các biến
toàn cục vẫn tồn tại từ một lần gọi hàm sang đến lần gọi tiếp theo.

\index{cờ}

Các biến toàn cục thường được dùng làm {\bf cờ}; tức là 
các biến kiểu boole để chỉ định (như ``lá cờ'') xem môt điều kiện
có đúng hay không. Chẳng hạn, một số chương trình dùng một cờ
có tên là {\tt verbose} để điều khiển mức độ chi tiết của kết quả
được xuất ra:

\beforeverb
\begin{verbatim}
verbose = True

def example1():
    if verbose:
        print 'Running example1'
\end{verbatim}
\afterverb
%
Nếu bạn thử gán lại giá trị cho một biến toàn cục, bạn có thể sẽ
ngạc nhiên. Ví dụ sau đây vốn được viết với ý định theo dõi xem
hàm có được gọi hay chưa:


\index{gán!nhiều lần}

\beforeverb
\begin{verbatim}
been_called = False

def example2():
    been_called = True         # SAI
\end{verbatim}
\afterverb
%
Nhưng nếu chạy nó, bạn sẽ thấy giá trị của \verb"been_called"
không hề thay đổi. Vấn đề là hàm {\tt example2} tạo ra một biến 
địa phương khác có tên là \verb"been_called". Biến địa phương
sẽ biến mất ngay khi hàm kết thúc và không ảnh hưởng gì đến 
biến toàn cục.

\index{toàn cục (lệnh)}
\index{lệnh!toàn cục}
\index{khai báo}

Để gán lại giá trị cho một biến toàn cục bên trong một hàm,
bạn phải {\bf khai báo} biến toàn cục trước khi sử dụng nó:

\beforeverb
\begin{verbatim}
been_called = False

def example2():
    global been_called 
    been_called = True
\end{verbatim}
\afterverb
%
Lệnh {\tt global} báo cho trình thông dịch biết một thông tin
kiểu như, ``Trong hàm này, khi nói đến \verb"been_called", ý
của tôi là biến toàn cục; đừng tạo ra một biến địa phương.''

\index{cập nhật!biến toàn cục}
\index{biến toàn cục!cập nhật}

Sau đây là một ví dụ cố gắng cập nhật một biến toàn cục:

\beforeverb
\begin{verbatim}
count = 0

def example3():
    count = count + 1          # SAI
\end{verbatim}
\afterverb
%
Nếu chạy nó bạn sẽ thu được:

\index{UnboundLocalError}
\index{biệt lệ!UnboundLocalError}

\beforeverb
\begin{verbatim}
UnboundLocalError: local variable 'count' referenced before assignment
\end{verbatim}
\afterverb
%
Python coi rằng {\tt count} là biến địa phương, nghĩa là bạn sẽ
đọc biến này trước khi ghi giá trị vào nò. Để sửa lỗi sai này, một lần nữa
bạn phải khai báo {\tt count} là biến toàn cục.

\index{biến đếm}

\beforeverb
\begin{verbatim}
def example3():
    global count
    count += 1
\end{verbatim}
\afterverb
%
Nesu biến toàn cục thuộc kiểu thay đổi được, bạn có thể sửa nó
mà không phải khai báo:

\index{thay đổi được}

\beforeverb
\begin{verbatim}
known = {0:0, 1:1}

def example4():
    known[2] = 1
\end{verbatim}
\afterverb
%
Như vậy bạn có thể thêm vào, bỏ bớt, và thay thế các phần tử của
một danh sách hoặc từ điển toàn cục, nhưng nếu bạn muốn gán lại
giá trị cho biến, bạn phải khai báo nó:

\beforeverb
\begin{verbatim}
def example5():
    global known
    known = dict()
\end{verbatim}
\afterverb
%

\section{Số nguyên dài}

\index{số nguyên dài}
\index{số nguyên!long}
\index{kiểu!long}

Nếu tính {\tt fibonacci(50)}, bạn sẽ thu được:

\beforeverb
\begin{verbatim}
>>> fibonacci(50)
12586269025L
\end{verbatim}
\afterverb
%
Chữ {\tt L} ở cuối chỉ định rằng kết quả có dạng số nguyên dài
\footnote{Ở Python 3.0, kiểu {\tt long} bị rút bỏ, tất cả số nguyên
  dù lớn đến đâu đều có kiểu {\tt int}.}, hoặc kiểu {\tt long}.

\index{Python 3.0}

Các giá trị thuộc kiểu {\tt int} bị giới hạn về độ lớn;
các số nguyên dài có thể lớn tùy ý, nhưng khi lớn lên chúng sẽ
chiếm nhiều dung lượng bộ nhớ và cần nhiều thời gian xử lí.

Các toán tử số học và các hàm trong module {\tt math} cũng
dùng được với số nguyên dài, vì vậy nói chung bất kì đoạn mã
nào chạy được với số nguyên {\tt int} cũng chạy được với {\tt long}.

Bất cứ khi nào kết quả tính toán quá lớn không thể biểu diễn được bởi số
nguyên thường, Python sẽ tự chuyển sang dạng số nguyên dài:

\beforeverb
\begin{verbatim}
>>> 1000 * 1000
1000000
>>> 100000 * 100000
10000000000L
\end{verbatim}
\afterverb
%
Trong trường hợp đầu, kết quả có kiểu {\tt int}; ở trường hợp thứ hai
là kiểu {\tt long}.

\begin{ex}

\index{mã hóa}
\index{RSA (thuật toán)}
\index{thuật toán!RSA}

PHép lũy thừa các số nguyên lớn là cơ sở của các thuật toán thông dụng
để mã hóa khóa công khai. Hãy đọc trang web Wikipedia
về thuật toán RSA\footnote{\url{en.wikipedia.org/wiki/RSA}.}
và viết các hàm thực hiện mã hóa và giải mã một đoạn tin.

\end{ex}


\section{Gỡ lỗi}
\index{debugging}

Khi bạn làm việc với các bộ dữ liệu lớn, việc gỡ lỗi bằng cách 
in ra và kiểm tra dữ liệu thủ công là việc không tưởng. Sau đây
là một số gơi ý cho việc gỡ lỗi các bộ dữ liệu lớn:

\begin{description}

\item[Thu nhỏ dữ liệu đầu vào:] Nếu có thể, hãy thu gọn kích thước
của bộ dữ liệu. Chẳng hạn, nếu chương trình cần đọc một file kí tự,
hãy bắt đầu bằng việc đọc 10 dòng đầu tiên, hoặc với một ví dụ
nhỏ nhất mà bạn có thể kiếm được. Bạn có thể tự tạo ra file, hoặc
(tốt hơn là) sửa đổi chương trình  để nó chỉ đọc {\tt n} dòng đầu tiên.

Nếu có lỗi xảy ra, bạn có thể giảm {\tt n} xuống đến giá trị nhỏ nhất
mà còn có lỗi, sau đó tăng dần lên đồng thời tiến hành tìm kiếm và
sửa các lỗi.

\item[Kiểm tra các kết quả tóm tắt và kiểu các biến:] 
Thay vì in và kiểm tra toàn bộ dữ liệu, bạn có thể cân nhắc in ra 
phần tóm lược cho dữ liệu thôi; chẳng hạn, số các mục trong một từ điển
hoặc tổng của các số trong một danh sách.

Một nguyên nhân thường gây ra lỗi thực thi là khi một giá trị không
nhận được kiểu đúng. Để gỡ những lỗi dạng này, thường ta chỉ cần in ra
kiểu của một giá trị.

\item[Viết chương trình kiểm tra:] Đôi khi bạn có thể viết đoạn mã lệnh
để tự động kiểm tra lỗi. Chẳng hạn, nếu bạn tính trị trung bình của một  
dãy các số, bạn có thể kiểm tra rằng kết quả không lớn hơn giá trị lớn nhất
trong dãy hoặc không nhỏ hơn giá trị nhỏ nhất. Đây được gọi là ``kiểm
tra độ lành mạnh'' vì nó phát hiện được các kết quả vô lí hết mức.

\index{kiểm tra độ lành mạnh}
\index{kiểm tra độ nhất quán}

Một dạng kiểm tra nữa nhằm so sánh kết quả giữa hai lần tính khác nhau
để xem chúng có nhất quán không. Đây được gọi là ``kiểm tra độ nhất quán''.

\item[In đẹp kết quả đầu ra:] Việc định dạng kết qủa đầu ra khi gỡ lỗi
có thể đơn giản hóa việc phát hiện lỗi. Ta đã thấy một ví dụ trong 
Mục~\ref{factdebug}.  Module {\tt pprint} cho ta một hàm
{\tt pprint} để hiển thị thông tin về các kiểu có sẵn theo hình thức
dễ đọc hơn.

\index{in đẹp}
\index{pprint (module)}
\index{module!pprint}

\end{description}

Một lần nữa, thời gian mà bạn dành cho việc dựng dàn giáo có thể giúp
giảm bớt thời gian mất để gỡ lỗi.

\index{dàn giáo}

\section{Thuật ngữ}

\begin{description}

\item[từ điển:] Dạng khớp từ một tập hợp các khóa với các giá trị 
tương ứng của chúng.
\index{từ điển}

\item[cặp khóa-trị:] Dạng biểu diễn sự khớp giữa một khóa với
một giá trị.
\index{cặp khóa-trị}

\item[mục:] Tên gọi khác cho cặp khóa-trị.
\index{mục!từ điển}

\item[khóa:] Một đối tượng xuất hiện trong từ điển với vai trò
bộ phận đầu của một cặp khóa-trị.
\index{khóa}

\item[trị:] Một đối tượng xuất hiện trong từ điển với vai trò
bộ phận thứ hai của một cặp khóa-trị. Khái niệm này đặc thù hơn
so với ``giá trị'' mà ta dùng trước đây.
\index{trị}

\item[thực thi:] Một cách tiến hành tính toán.
\index{thực thi}

\item[bảng băm:] Thuật toán được dùng để thực thi các từ điển
trong Python.
\index{bảng băm}

\item[hàm băm:] Hàm được dùng bởi một bảng băm để tính ra
vị trí cho một khóa.
\index{hàm băm}

\item[băm được:] Kiểu dữ liệu có hàm băm. Các kiểu
không thay đổi được như số nguyên, số có phần thập phân, và
chuỗi đều băm được; các kiểu thay đổi được như danh sách và
từ điển thì không.
\index{băm được}

\item[tra:] Thao tác trên từ điển, nhận vào một khóa và
tìm ra trị tương ứng.
\index{tra}

\item[tra ngược:] Thao tác trên từ điển, nhận vào một trị và
tìm ra một hoặc nhiều khóa khớp với nó.
\index{tra ngược, từ điển}

\item[danh sách đơn:] Danh sách (hoặc một dãy nói chung) có một 
phần tử duy nhất.
\index{danh sách đơn}

\item[biểu đồ gọi:] Đồ thị biểu diễn tất cả các khung được tạo ra
khi chạy một chương trình, với một mũi tên chỉ từ khung gọi đến
khung được gọi.
\index{đồ thị gọi}
\index{biểu đồ!đồ thị gọi}

\item[histogram:] Tập hợp các biến đếm.
\index{histogram}

\item[giá trị nhớ:] Giá trị sau khi tính toán được lưu trữ để tránh
phải tính lại sau này.
\index{giá trị nhớ}

\item[biến toàn cục:] Biến dược định nghĩa bên ngoài mọt hàm. Các biến
toàn cục có thể được truy cập từ bất kì hàm nào.
\index{biến toàn cục}

\item[cờ:] Biến kiểu boole được dùng để chỉ định một điều kiện có đúng
hay không.
\index{cờ}

\item[khai báo:] Lệnh kiểu như {\tt global} để báo cho trình thông dịch
biết thông tin về một biến.
\index{khai báo}

\end{description}

\section{Bài tập}

\begin{ex}
\index{trùng nhau}

Nếu bạn đã làm Bài tập~\ref{duplicate}, bạn đã có một hàm có tên
\verb"has_duplicates" để nhận vào một danh sách với vai trò tham biến và
trả lại {\tt True} nếu có bất kì đối tượng nào trong danh sách 
xuất hiện nhiều hơn một lần.

Hãy dùng một từ điển để viết một dạng nhanh hơn và đơn giản hơn cho
\verb"has_duplicates".
\end{ex}


\begin{ex}
\label{exrotatepairs}

\index{xoay chữ}
\index{xoay!chữ}

Hai từ tạo thành một ``cặp xoay'' nếu như bạn xoay từ này để được từu kia
(xem \verb"rotate_word" ở Bài tập~\ref{exrotate}).

Hãy viết một chương trình đọc vào một danh sách các từ và tìm tất cả
những cặp xoay.
\end{ex}


\begin{ex}
\index{Car Talk}
\index{câu đố}

Sau đây là một câu đố khác từ chương trình {\em Car
Talk}\footnote{\url{www.cartalk.com/content/puzzler/transcripts/200717}.}:

\begin{quote}
Câu đố này được ông Dan O'Leary gửi đến. Ông bắt gặp một từ rất thông dụng;
từ này có 5 chữ cái và chỉ một âm tiết, với đặc tính riêng như sau.
Khi bạn bỏ đi chữ cái thứ nhất, các chữ cái còn lại sẽ hình thành một
từ đồng âm với từ gốc. Bây giờ trả lại chữ cái thứ nhất và bỏ đi chữ cái
thứ hai, một lần nữa ta lại thu  được từ đồng âm với từ gốc. Câu hỏi là,
từ gốc là gì?

Bây giờ tôi sẽ lấy thí dụ một từ chưa đạt yêu cầu. Hãy xét từ gồm 5 chữ cái
sau, `wrack.' W-R-A-C-K. Nếu tôi bỏ đi chữ cái thứ nhất, tôi được một từ
bốn chữ cái 'R-A-C-K.' À đó là một từ đồng âm, theo tiếng Anh. Bây giờ
nếu bạn hoàn trả lại chữ `w', và bỏ đi chữ `r', bạn sẽ còn lại từ
`wack', cũng là một từ có nghĩa, chỉ có điều là không đồng âm với hai
từ trước.

Tuy nhiên vẫn có ít nhất một từ mà Dan và chúng ta đều biết đến, một từ
mà sẽ cho ra hai từ đồng âm khác gồm bốn chữ cái, khi ta bỏ đi lần lượt chữ cái thứ nhất
và chữ cái thứ hai của từ gốc. Câu hỏi là, từ đó là gì?
\end{quote}

\index{từ đồng âm}
\index{từ có thể giản lược}

Bạn có thể dùng từ điển trong Bài tập~\ref{wordlist2} để kiểm tra xem 
một chuỗi có ở trong danh sách các từ hay không.

Để kiểm tra xem hai từ có đồng âm hay không, bạn có thể dùng
Từ điển Phát âm CMU. Bạn có thể tải về từ 
\url{www.speech.cs.cmu.edu/cgi-bin/cmudict} hoặc
\url{thinkpython.com/code/c06d} và bạn cũng có thẻ tải về
\url{thinkpython.com/code/pronounce.py}, trong đó có hàm
tên là \verb"read_dictionary". Hàm này đọc vào một từ điển phát âm và
trả về một từ điển Python khớp mỗi từ với một chuỗi
mô tả cách phát âm của nó.

Hãy viết một chương trình liệt kê tất cả các từ thỏa mãn yêu cầu
của câu đố. Bạn có thể xem lời giải của tôi tại \url{thinkpython.com/code/homophone.py}.

\end{ex}



\chapter{Bộ}
\label{tuplechap}

\section{Bộ là kiểu dữ liệu không thay đổi}

\index{bộ}
\index{kiểu!bộ}
\index{dãy}

Bộ là một dãy các giá trị. Các giá trị có thể thuộc kiểu dữ liệu bất kì,
và chúng đánh thứ tự bởi các số nguyên, và vì vậy bộ khá giống với
danh sách. Điểm khác nhau quan trọng là ở chỗ bộ có tính không thay đổi.

\index{tính thay đổi}
\index{tính không thay đổi}

Về mặt cú pháp, một bộ là một dãy các giá trị được phân cách bởi dấu phẩy:

\beforeverb
\begin{verbatim}
>>> t = 'a', 'b', 'c', 'd', 'e'
\end{verbatim}
\afterverb
%
Mặc dù không cần thiết, nhưng người ta thường dùng cặp ngoặc tròn
để bao lại phần nội dung của một bộ:

\index{ngoặc tròn!bộ}

\beforeverb
\begin{verbatim}
>>> t = ('a', 'b', 'c', 'd', 'e')
\end{verbatim}
\afterverb
%
Để tạo ra một bộ với một phần tử duy nhất, bạn phải viết thêm một dấu phẩy
ở phía cuối:

\index{bộ đơn}

\beforeverb
\begin{verbatim}
>>> t1 = 'a',
>>> type(t1)
<type 'tuple'>
\end{verbatim}
\afterverb
%
Một giá trị ở trong cặp ngoặc tròn không phải là một bộ:

\beforeverb
\begin{verbatim}
>>> t2 = ('a')
>>> type(t2)
<type 'str'>
\end{verbatim}
\afterverb
%
Một cách làm khác để tạo ra một bộ là dùng hàm có sẵn {\tt tuple}.
Khi không có đối số, nó sẽ tạo ra một bộ rỗng:

\index{tuple (hàm)}
\index{hàm!tuple}

\beforeverb
\begin{verbatim}
>>> t = tuple()
>>> print t
()
\end{verbatim}
\afterverb
%
Nếu đối số là một dãy (như chuỗi, danh sách hoặc bộ), thì kết quả sẽ
là một bộ có chứa các phần tử của dãy đó:

\beforeverb
\begin{verbatim}
>>> t = tuple('lupins')
>>> print t
('l', 'u', 'p', 'i', 'n', 's')
\end{verbatim}
\afterverb
%
Vì {\tt tuple} là tên của một hàm có sẵn, bạn cần tránh lấy nó đặt cho
tên biến.

Hầu hết các toán tử với danh sách cũng có tác dụng đối với bộ. Toán tử
ngoặc vuông để chỉ định một phần tử:

\index{ngoặc vuông (toán tử)}
\index{toán tử!ngoặc vuông}

\beforeverb
\begin{verbatim}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print t[0]
'a'
\end{verbatim}
\afterverb
%
Và toán tử lát cắt để chọn một khoảng các phần tử.

\index{lát cắt (toán tửu)}
\index{toán tử!lát cắt}
\index{bộ!lát cắt}
\index{lát cắt!bộ}

\beforeverb
\begin{verbatim}
>>> print t[1:3]
('b', 'c')
\end{verbatim}
\afterverb
%
Nhưng nếu bạn thử thay đổi một phần tử trong bộ, bạn sẽ bị báo lỗi:

\index{biệt lệ!TypeError}
\index{TypeError}
\index{phép gán!phần tử}

\beforeverb
\begin{verbatim}
>>> t[0] = 'A'
TypeError: object doesn't support item assignment
\end{verbatim}
\afterverb
%
Bạn không thể sửa đổi được các phần tử của bộ, nhưng có thể thay thế
một bộ với một bộ khác:

\beforeverb
\begin{verbatim}
>>> t = ('A',) + t[1:]
>>> print t
('A', 'b', 'c', 'd', 'e')
\end{verbatim}
\afterverb
%

\section{Phép gán thực hiện với bộ}
\label{tuple assignment}

\index{bộ!phép gán}
\index{phép gán!bộ}
\index{tráo đổi (dạng mẫu)}
\index{dạng mẫu!tráo đổi}

Ta thường gặp tình huống cần tráo đổi giá trị của hai biến.
Với câu lệnh gán truyền thống, bạn phải dùng một biến tạm thời.
Chẳng hạn, để tráo đổi {\tt a} với {\tt b}:

\beforeverb
\begin{verbatim}
>>> temp = a
>>> a = b
>>> b = temp
\end{verbatim}
\afterverb
%
Cách giải này lủng củng; và {\bf phép gán với bộ} sẽ đẹp hơn:

\beforeverb
\begin{verbatim}
>>> a, b = b, a
\end{verbatim}
\afterverb
%
Vế trái là một bộ các biến; vế phải là một bộ các biểu thức.
Mỗi giá trị được gán cho biến tương ứng với nó. Tất cả các 
biểu thức ở vế phải đều được định lượng trước khi thực hiện
gán.

Số các biến ở vế trái và số các giá trị ở vế phải cần phải
bằng nhau:

\index{biệt lệ!ValueError}
\index{ValueError}

\beforeverb
\begin{verbatim}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
\end{verbatim}
\afterverb
%
Tổng quát hơn, vế phải có thể là bất cứ dạng dãy nào (chuỗi,
danh sách hoặc bộ). Chẳng hạn, để tách một địa chỉ email thành
các phần tên người dùng và tên miền, bạn có thể viết:

\index{split (phương thức)}
\index{phương thức!split}
\index{địa chỉ email}

\beforeverb
\begin{verbatim}
>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')
\end{verbatim}
\afterverb
%
Giá trị trả về từ {\tt split} là một dãy gồm hai phần tử;
phần tử đầu được gán cho {\tt uname}, phần tử thứ hai cho
{\tt domain}.

\beforeverb
\begin{verbatim}
>>> print uname
monty
>>> print domain
python.org
\end{verbatim}
\afterverb
%

\section{Bộ với vai trò là các giá trị được trả về}

\index{bộ}
\index{giá trị!bộ}
\index{giá trị trả về!bộ}
\index{hàm, trả về bộ}

Chặt chẽ mà nói, một hàm chỉ có thể trả về một giá trị, nhưng
nếu giá trị đó là một bộ, thì tác dụng này cũng như là trả về
nhiều giá trị. Chẳng hạn, nếu bạn muốn chia hai số tự nhiên để
tìm ra thương và số dư, việc tính {\tt x/y} trước rồi đến {\tt x\%y}
là không hiệu quả. Cách tốt hơn là đồng thời tính chúng.

\index{divmod}

Hàm có sẵn {\tt divmod} nhận vào hai đối số và trả về
một bộ hai giá trị, là thương và số dư. Bạn có thể lưu kết quả
dưới dạng một bộ:

\beforeverb
\begin{verbatim}
>>> t = divmod(7, 3)
>>> print t
(2, 1)
\end{verbatim}
\afterverb
%
Hoặc dùng phép gán với bộ để lưu các phần tử một cách riêng rẽ:

\index{bộ!phép gán}
\index{phép gán!bộ}

\beforeverb
\begin{verbatim}
>>> quot, rem = divmod(7, 3)
>>> print quot
2
>>> print rem
1
\end{verbatim}
\afterverb
%
Sau đây là ví dụ một hàm trả lại một bộ:

\beforeverb
\begin{verbatim}
def min_max(t):
    return min(t), max(t)
\end{verbatim}
\afterverb
%
{\tt max} và {\tt min} là các hàm có sẵn để tìm
các phần tử lớn nhất và nhỏ nhất trong một dãy.  \verb"min_max"
tính cả hai và trả lại một bộ hai giá trị.

\index{max (hàm)}
\index{hàm!max}
\index{min (hàm)}
\index{hàm!min}


\section{Bộ đối số có độ dài thay đổi}

\index{bộ đối số có độ dài thay đổi}
\index{đối số!bộ có độ dài thay đổi}
\index{thu gom}
\index{tham số!thu gom}
\index{đối số!thu gom}

Số lượng các đối số cho một hàm là thay đổi được. Một tham biến
mà tên bắt đầu bởi {\tt *} sẽ {\bf thu gom} các đối số vào trong
một bộ. Chẳng hạn, {\tt printall} nhận vào một số lượng 
đối số tùy ý và in chúng ra:

\beforeverb
\begin{verbatim}
def printall(*args):
    print args
\end{verbatim}
\afterverb
%
Bạn có thể đặt tên tham biến dùng để thu gom là gì cũng được, nhưng
{\tt args} là một cái tên quy ước. Sau đây là cách dùng hàm này:

\beforeverb
\begin{verbatim}
>>> printall(1, 2.0, '3')
(1, 2.0, '3')
\end{verbatim}
\afterverb
%
Thao tác bổ sung cho thu gom là {\bf phát tán}. Nếu bạn có một dãy
các giá trị và muốn truyền cho một hàm dưới dạng nhiều đối số,
bạn có thể dùng toán tử {\tt *}.
Chẳng hạn, {\tt divmod} nhận vào đúng hai tham số; nó sẽ không 
hoạt động với một bộ:

% removing this because we haven't seen optional parameters yet
%You can combine the gather operator with required and positional
%arguments:

%\beforeverb
%\begin{verbatim}
%def pointless(required, optional=0, *args):
%    print required, optional, args
%\end{verbatim}
%\afterverb
%
%Run this function with 1, 2, 3 and 4 or more arguments and
%make sure you understand what it does.

\index{phát tán}
\index{phát tán tham biến}

\index{TypeError}
\index{biệt lệ!TypeError}

\beforeverb
\begin{verbatim}
>>> t = (7, 3)
>>> divmod(t)
TypeError: divmod expected 2 arguments, got 1
\end{verbatim}
\afterverb
%
Nhưng nếu bạn phát tán bộ đó thì câu lệnh sẽ có tác dụng:

\beforeverb
\begin{verbatim}
>>> divmod(*t)
(2, 1)
\end{verbatim}
\afterverb
%
\begin{ex}
Rất nhiều hàm có sẵn sử dụng bộ đối số có chiều dài thay đổi.
Chẳng hạn, {\tt max} và {\tt min} có thể nhận bao nhiêu
đối số cũng được:

\index{max (hàm)}
\index{hàm!max}
\index{min (hàm)}
\index{hàm!min}

\beforeverb
\begin{verbatim}
>>> max(1,2,3)
3
\end{verbatim}
\afterverb
%
Nhưng {\tt sum} thì không thể.

\index{sum (hàm)}
\index{hàm!sum}

\beforeverb
\begin{verbatim}
>>> sum(1,2,3)
TypeError: sum expected at most 2 arguments, got 3
\end{verbatim}
\afterverb
%
Hãy viết một hàm có tên {\tt sumall} nhận vào bao nhiêu đối số cũng được
và trả về tổng của chúng.

\end{ex}


\section{Danh sách và bộ}

\index{zip (hàm)}
\index{hàm!zip}

{\tt zip} là một hàm có sẵn; nó nhận vào nhiều dãy và đan cài chúng vào
một danh sách duy nhất\footnote{Trong Python 3.0, {\tt zip} trả lại một
  nguồn lặp các bộ, nhưng thường thì người ta vẫn coi một nguồn lặp tựa
  như một danh sách.}  chứa các bộ trong đó mỗi bộ có một phần tử của mỗi
  dãy. (zip là tên gọi của phéc-mơ-tuya có hình ảnh giống
với thao tác đan cài này.)
\index{Python 3.0}

Ví dụ sau đan cài một chuỗi và một danh sách:

\beforeverb
\begin{verbatim}
>>> s = 'abc'
>>> t = [0, 1, 2]
>>> zip(s, t)
[('a', 0), ('b', 1), ('c', 2)]
\end{verbatim}
\afterverb
%
Kết quả là một danh sách các bộ trong đó mỗi bộ chứa một kí tự của chuỗi
và phần tử tương ứng của danh sách ban đầu.

\index{danh sách!các bộ}

Nếu các dãy không có cùng độ dài thì kết quả sẽ dài bằng dãy ngắn hơn.

\beforeverb
\begin{verbatim}
>>> zip('Anne', 'Elk')
[('A', 'E'), ('n', 'l'), ('n', 'k')]
\end{verbatim}
\afterverb
%
Bạn có thể dùng phép gán bộ trong vòng lặp {\tt for} để duyệt một danh sách
các bộ:

\index{duyệt}
\index{bộ (phép gán)}
\index{phép gán!bộ}

\beforeverb
\begin{verbatim}
t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print number, letter
\end{verbatim}
\afterverb
%
Mỗi lần lặp, Python sẽ chọn ra bộ tiếp theo trong danh sách và gán các
phần tử của nó cho {\tt letter} và {\tt number}. Kết quả đầu ra của vòng lặp
này là:

\index{vòng lặp}

\beforeverb
\begin{verbatim}
0 a
1 b
2 c
\end{verbatim}
\afterverb
%
Nếu kết hợp {\tt zip}, {\tt for} và phép gán bộ, bạn sẽ có một
cách viết rất hữu ích để duyệt hai (hoặc nhiều) dãy cùng lúc. Chẳng hạn,
\verb"has_match" nhận vào hai dãy, {\tt t1} và
{\tt t2}, rồi trả lại {\tt True} nếu có một chỉ số {\tt i} 
sao cho {\tt t1[i] == t2[i]}:

\index{vòng lặp!for}

\beforeverb
\begin{verbatim}
def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
\end{verbatim}
\afterverb
%
Nếu cần duyệt các phần tử trong một dãy và các chỉ số của chúng,
bạn có thể dùng hàm có sẵn {\tt enumerate}:

\index{duyệt}
\index{enumerate (hàm)}
\index{hàm!enumerate}

\beforeverb
\begin{verbatim}
for index, element in enumerate('abc'):
    print index, element
\end{verbatim}
\afterverb
%
Kết quả đầu ra của vòng lặp này là:

\beforeverb
\begin{verbatim}
0 a
1 b
2 c
\end{verbatim}
\afterverb
%
Một lần nữa.


\section{Từ điển và bộ}

\index{từ điển}
\index{items (phương thức)}
\index{phương thức!items}
\index{cặp khóa-trị}

Từ điển có một phương thức tên là {\tt items} để trả lại một danh sách
các bộ, trong đó mỗi bộ là một cặp khóa-trị\footnote{Điều này sẽ 
  hơi khác trong Python 3.0.}.

\beforeverb
\begin{verbatim}
>>> d = {'a':0, 'b':1, 'c':2}
>>> t = d.items()
>>> print t
[('a', 0), ('c', 2), ('b', 1)]
\end{verbatim}
\afterverb
%
Với từ điển, như bạn có thể đoán được, các mục đều không có
một thứ tự nào.

\index{từ điển!khởi tạo}

Ngược lại, bạn có thể dùng danh sách các bộ để khởi tạo một
từ điển mới:

\beforeverb
\begin{verbatim}
>>> t = [('a', 0), ('c', 2), ('b', 1)]
>>> d = dict(t)
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}
\afterverb

Kết hợp {\tt dict} với {\tt zip} ta được một cách nhanh gọn để tạo ra
một từ điển:

\index{zip (hàm)!dùng với dict}

\beforeverb
\begin{verbatim}
>>> d = dict(zip('abc', range(3)))
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}
\afterverb
%
Phương thức {\tt update} của từ điển cũng nhận vào một danh sách
các bộ và gộp chúng lại, theo các cặp khóa-trị, vào từ điển sẵn có.

\index{update (phương thức)}
\index{phương thức!update}

\index{duyệt!từ điển}
\index{từ điển!duyệt}

Kết hợp {\tt items}, phép gán bộ và {\tt for} lại với nhau, bạn
có một cách viết chương trình duyệt các khóa và trị của từ điển:

\beforeverb
\begin{verbatim}
for key, val in d.items():
    print val, key
\end{verbatim}
\afterverb
%
Kết quả đầu ra của vòng lặp này là:

\beforeverb
\begin{verbatim}
0 a
2 c
1 b
\end{verbatim}
\afterverb
%
Giống như trước.

\index{bộ!như một khóa trong từ điển}
\index{băm được}

Bộ thường được dùng làm khóa trong từ điển (chủ yếu là vì bạn
không thể dùng danh sách). Chẳng hạn, một danh bạ điện thoại có thể
khớp giữa cặp họ, tên với số điện thoại. Giả sử rằng ta đã 
định nghĩa {\tt ho}, {\tt ten} và {\tt so}, ta có thể viết:

\beforeverb
\begin{verbatim}
danhba[ho,ten] = so
\end{verbatim}
\afterverb
%
Biểu thức trong ngoặc vuông là một bộ. Chúng ta có thể dùng 
phép gán cho bộ để duyệt từ điển này.

\index{bộ!trong cặp ngoặc vuông}

\beforeverb
\begin{verbatim}
for ho,ten in danhba:
    print ho, ten, danhba[ho,ten]
\end{verbatim}
\afterverb
%
Vòng lặp này duyệt các khóa trong {\tt danhba}, vốn là các bộ. Nó gán
các phần tử của từng bộ cho {\tt ho} và {\tt ten}, sau đó in ra
họ tên và số điện thoại tương ứng.

Có hai cách biểu diễn bộ trong một sơ đồ trạng thái. Cách chi tiết hơn
chỉ rõ các chỉ số và phần tử giống như với danh sách. Chẳng hạn,
bộ \verb"('Cleese', 'John')" sẽ được biểu diễn như sau:

\index{trạng thái (sơ đồ)}
\index{sơ đồ!trạng thái}

\beforefig
\centerline{\includegraphics{figs/tuple1.eps}}
\afterfig

Nhưng trong một sơ đồ lớn hơn bạn có thể muốn bỏ qua các chi tiết.
Chẳng hạn, sơ đồ của một danh bạ điện thoại có thể như sau:

\beforefig
\centerline{\includegraphics{figs/dict2.eps}}
\afterfig

Ở đây các bộ được ghi dưới dạng cú pháp Python, cũng để ghi tắt
trên sơ đồ.

Số điện thoại trong sơ đồ là đường dây góp ý cho đài phát thanh BBC,
vậy nên bạn đừng gọi số đó.



\section{So sách các bộ}

\index{so sánh!bộ}
\index{bộ!so sánh}
\index{sort (phương thức)}
\index{phương thức!sort}

Các toán tử quan hệ cũng có tác dụng với bộ và các dãy khác;
Python bắt đầu với việc so sánh phần tử thứ nhất của từng dãy.
Nếu chúng bằng nhau thì việc so sánh tiếp tục với các phần tiếp
kế sau, và cứ như vậy, cho đến khi tìm được phần tử khác nhau.
Các phần tử còn lại thì không được xét đến nữa (dù chúng có
lớn đến đâu).

\beforeverb
\begin{verbatim}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
\end{verbatim}
\afterverb
%
Hàm {\tt sort} cũng hoạt động theo cách tương tự. Nó sắp xếp
theo phần tử thứ nhất, nhưng nếu chúng bằng nhau thì xếp theo
phần tử thứ hai, và cứ như vậy.

Đặc điểm này dựa trên một dạng mẫu có tên {\bf DSU}, vốn là viết tắt của

\begin{description}

\item[Decorate] (``trang trí'') một dãy bằng cách tạo dựng một danh sách
các bộ với một hoặc nhiều khóa sắp xếp đi trước những phần tử của dãy,

\item[Sort] (sắp xếp) danh sách các bộ, và

\item[Undecorate] (``gỡ bỏ trang trí'') bằng cách kết xuất các phần tử đã
được sắp xếp của dãy.

\end{description}

\label{DSU}
\index{DSU (dạng mẫu)}
\index{dạng mẫu!DSU}
\index{decorate-sort-undecorate (dạng mẫu)}
\index{dạng mẫu!decorate-sort-undecorate}

Chẳng hạn, nếu bạn có một danh sách những từ cần sắp xếp từ dài đến ngắn:

\beforeverb
\begin{verbatim}
def sort_by_length(words):
    t = []
    for word in words:
       t.append((len(word), word))

    t.sort(reverse=True)

    res = []
    for length, word in t:
        res.append(word)
    return res
\end{verbatim}
\afterverb
%
Vòng lặp thứ nhất tạo dựng một danh sách các bộ, trong đó mỗi bộ là
một từ và trước đó là chiều dài của từ đó.

{\tt sort} thực hiện so sánh phần tử thứ nhất (tức độ dài) trước, và chỉ khi độ dài 
như nhau thì mới xét đến phần tử thứ hai. Từ khóa đối số 
{\tt reverse=True} báo cho {\tt sort} thực hiện theo chiều giảm dần.

\index{từ khóa đối số}
\index{đối số!từ khóa}
\index{duyệt}

Vòn lặp thứ hai duyệt danh sách các bộ và tạo dựng một danh sách các từ theo
thứ tự giảm dần về độ dài.

\begin{ex}
Ở ví dụ này, để phân định thứ tự giữa các từ cùng độ dài sẽ
dựa vào thứ tự của từ đó xếp trong bảng chữ cái. Trong trường hợp
khác bạn có thể phân định theo tiêu chí ngẫu nhiên. Hãy sửa lại
ví dụ này sao cho những từ cùng độ dài được xếp theo thứ tự
ngẫu nhiên. Gợi ý: dùng hàm {\tt random} trong module
{\tt random}.

\index{random (module)}
\index{module!random}
\index{random (hàm)}
\index{hàm!random}

\end{ex}


\section{Dãy chứa các dãy}
\index{dãy}

Đến giờ tôi mới tập trung vào danh sách các bộ, nhưng hầu hết các ví dụ
trong chương này cũng thực hiện được với danh sách chứa các danh sách, bộ chứa
các bộ, và bộ chứa các danh sách. Để tránh phải liệt kê tất cả những sự kết hợp
có thể, ta sẽ nói gọn là dãy chứa các dãy.

Trong nhiều trường hợp, những dạng khác nhau của dãy (chuỗi, danh sách và
bộ) có thể được dùng hoán đổi cho nhau được. Vì vậy tại sao và bằng cách nào
mà bạn lựa chọn dạng này thay vì dạng kia?


\index{chuỗi}
\index{danh sách}
\index{bộ}
\index{thay đổi được}
\index{không thay đổi được}

Bắt đầu với điều hiển nhiên, chuỗi thì có tính năng hạn chế rất nhiều
so với các loại dãy khác vì những phần tử của nó chỉ có thể là kí tự.
Chuỗi cũng là kiểu không thay đổi được. Nếu bạn muốn có tính năng thay đổi
những kí tự trong chuỗi mà không muốn tạo ra một chuỗi mới, có lẽ bạn sẽ
phải dùng một danh sách các kí tự để thay thế.

Danh sách thì thông dụng hơn bộ, chủ yếu là vì chúng thay đổi được.
Nhưng cũng có một vài trường hợp bạn muốn dùng bộ hơn:

\begin{enumerate}

\item Trong một số trường hợp, như trong câu lệnh {\tt return}, việc tạo ra một bộ 
thì đơn giản hơn một danh sách, về hình thức cú pháp. Trong những
trường hợp khác, có thể bạn nên dùng danh sách.

\item Nếu muốn tạo một dãy để làm khóa cho từ điển, bạn phải dùng
một kiểu dữ liệu không thay đổi như bộ hoặc chuỗi.

\item Nếu bạn chuyển một dãy với vài trò đối số cho một hàm, 
việc dùng bộ sẽ làm giảm khả năng gây lỗi bắt nguồn từ tham chiếu bội.

\end{enumerate}

Vì bộ là kiểu không thay đỏi được, chúng không có những phương thức 
như {\tt sort} và {\tt reverse}, vốn để sửa đổi một danh sách sẵn có.
Nhưng Python lại cung cấp các hàm có sẵn {\tt sorted}
và {\tt reversed} để nhận vào một chuỗi bất kì làm tham biến và
trả lại một danh sách mới với cùng các phần tử theo một thứ tự khác.

\index{sorted (hàm)}
\index{hàm!sorted}
\index{reversed (hàm)}
\index{hàm!reversed}


\section{Gỡ lỗi}

\index{gỡ lỗi}
\index{cấu trúc dữ liệu}
\index{hình dạng (lỗi)}
\index{lỗi!hình dạng}

Danh sách, từ điển và bộ thường được gọi chung là  {\bf cấu trúc 
dữ liệu}; trong chương này ta bắt đầu thấy những cấu trúc dữ liệu
phứ hợp, như danh sách các bộ, và từ điển có khóa là các bộ và trị là
các danh sách. Cấu trúc dữ liệu phức hợp rất có ích, nhưng chúng dễ
mắc phải vấn đề mà tôi gọi là {\bf lỗi hình dạng}; nghĩa là những lỗi
phát sinh khi một cấu trúc dữ liệu có kiểu, kích thước hoặc cấu trúc sai.
Chẳng hạn, nếu bạn trông đợi một danh sách có chứa một số nguyên mà tôi lại
cho bạn một số nguyên (không phải danh sách) thì chương trình không hoạt động.

\index{structshape (module)}
\index{module!structshape}

Để giúp cho việc gỡ lỗi kiểu như vậy, tôi đã viết một module
có tên {\tt structshape} trong đó có một hàm cùng tên
{\tt structshape}, nhận vào bất kì một cấu trúc dữ liệu nào làm đối số và
trả về một chuỗi làm nhiệm vụ tóm lược lại hình dạng của nó.
Bạn có thể tải nó về từ \url{thinkpython.com/code/structshape.py}

Sau đây là kết quả cho một dãy đơn giản:

\beforeverb
\begin{verbatim}
>>> from structshape import structshape
>>> t = [1,2,3]
>>> print structshape(t)
list of 3 int
\end{verbatim}
\afterverb
%
Một chương trình đẹp hơn có thể in ra ``list of 3 int{\em s},'' nhưng
không tính đến danh từ số nhiều thì sẽ dễ hơn. Sau đây là một
danh sách các danh sách:

\beforeverb
\begin{verbatim}
>>> t2 = [[1,2], [3,4], [5,6]]
>>> print structshape(t2)
list of 3 list of 2 int
\end{verbatim}
\afterverb
%
Nếu các phần tử của danh sách không có cùng kiểu thì
{\tt structshape} sẽ nhóm chúng lại theo dạng, đúng theo
thứ tự:

\beforeverb
\begin{verbatim}
>>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
>>> print structshape(t3)
list of (3 int, float, 2 str, 2 list of int, int)
\end{verbatim}
\afterverb
%
Sau đây là một danh sách các bộ:

\beforeverb
\begin{verbatim}
>>> s = 'abc'
>>> lt = zip(t, s)
>>> print structshape(lt)
list of 3 tuple of (int, str)
\end{verbatim}
\afterverb
%
Và sau đây là một từ điển có 3 mục trong đó khớp số nguyên với chuỗi..

\beforeverb
\begin{verbatim}
>>> d = dict(lt) 
>>> print structshape(d)
dict of 3 int->str
\end{verbatim}
\afterverb
%
Nêu bạn vẫn vướng mắc trong việc theo dõi các cấu trúc dữ liệu thì
{\tt structshape} có thể sẽ hữu ích.


\section{Thuật ngữ}

\begin{description}

\item[bộ:] Dãy các phần tử không thể thay đổi được.
\index{bộ}

\item[phép gán bộ:] Phép gán với một dãy ở vế phải và một bộ
các biến ở vế trái. Vế phải được định lượng và sau đó các
phần tử của nó được gán cho các biến ở vế trái.
\index{bộ (phép gán)}
\index{phép gán!bộ}

\item[thu gom:] Thao tác tập hợp một bộ các đối số có độ dài
thay đổi.
\index{thu gom}

\item[phát tán:] Thao tác xử lí dãy như một danh sách các đối số.
\index{phát tán}

\item[DSU:] Viết tắt của ``decorate-sort-undecorate,'' một dạng
mẫu bao gồm tạo dựng một danh sách các bộ, sắp xếp, và kết xuất
một phần của kết quả.
\index{DSU (dạng mẫu)}

\item[cấu trúc dữ liệu:] Tập hợp các giá trị có liên hệ với nhau,
thường được tổ chức dưới dạng danh sách, từ điển, bộ, v.v.
\index{cấu trúc dữ liệu}

\item[hình dạng (của cấu trúc dữ liệu):] Dạng tóm lược của kiểu,
hình dạng và thành phần của một cấu trúc dữ liệu.
\index{hình dạng}

\end{description}


\section{Bài tập}

\begin{ex}
Hãy viết một hàm có tên \verb"most_frequent" nhận vào một chuỗi
và in ra các chữ cái theo thứ tự tần số xuất hiện giảm dần. Hãy tìm
những đoạn văn viết bằng vài thứ tiếng khác nhau và xem tần số chữ cái
của chúng khác nhau thế nào. So sách kết quả bạn tìm được với bảng
thống kê tại \url{wikipedia.org/wiki/Letter_frequencies}.

\index{chữ cái, tần suất}
\index{tần suất!chữ cái}

\end{ex}


\begin{ex}
\label{anagrams}

\index{đảo chữ, tập hợp}
\index{tập hợp!đảo chữ}

Thêm bài về đảo chữ!

\begin{enumerate}

\item Hãy viết một chương trình đọc vào danh sách các từ trong 
một file (xem Mục~\ref{wordlist}) và in ra tất cả tập hợp
các từ gồm những chữ cái đảo nhau.

Sau đây là một ví dụ kết quả có thể tìm được:

\beforeverb
\begin{verbatim}
['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
\end{verbatim}
\afterverb
%
Gợi ý: có thể bạn muốn lập một từ điển để khớp một tập hợp
những chữ cái với một danh sách những từ viết được từ những chữ cái
đó. Câu hỏi là, bạn biểu diễn tập hợp chữ cái đó như thế nào để
chúng có thể làm khóa của từ điển?

\item Sửa chương trình trên để in ra tập hợp các từ đảo lớn nhất trước,
sau đến tập hợp lớn thứ hai, và cứ như vậy.

\index{Scrabble}
\index{bingo}

\item Trong trò chơi Scrabble, ``bingo'' là trường hợp khi bạn dùng hết
toàn bộ bảy mảnh chữ trên khay của mình, cùng với một mảnh chữ sẵn có trên
bảng, để tạo thành một từ gồm tám chữ cái. Tập hợp 8 chữ cái nào có nhiều
khả năng hình thành bingo nhất?
Gợi ý: tập hợp này tạo thành được 7 từ.

% (7, ['angriest', 'astringe', 'ganister', 'gantries', 'granites',
% 'ingrates', 'rangiest'])

\index{metathesis}

\item Hai từ tạo thành một ``cặp hoán đổi'' nếu bạn có thể chuyển từ này
  thành từ kia chỉ bằng cách đổi chỗ hai chữ cái\footnote{Bài tập này
  được hình thành từ một ví dụ tại \url{puzzlers.org}.}; chẳng hạn,
  ``converse'' và ``conserve.''  Hãy viết một chương trình để tìm tất cả
  các cặp hoán đổi trong từ điển. Gợi ý: đừng kiểm tra tất cả những cặp
  hai từ, cũng đừng kiểm tra tất cả các khả năng hoán đổi.

Bạn có thể tải về một lời giải ở \url{thinkpython.com/code/anagram_sets.py}.

\end{enumerate}
\end{ex}



\begin{ex}

\index{Car Talk}
\index{Câu đố}

Sau đây là một câu đố Car Talk khác\footnote{
\url{www.cartalk.com/content/puzzler/transcripts/200651}.}:

\begin{quote}
Từ tiếng Anh nào dài nhất có đặc điểm sau, mỗi khi ta lần lượt bỏ bớt
một chữ cái thì nó vẫn còn có nghĩa?

Cụ thể, chữ cái bỏ đi có thể ở đầu, cuối, hoặc giữa từ, nhưng sau khi bỏ
không được sắp xếp lại vị trí các chữ còn lại. Mỗi khi bỏ đi một chữ,
bạn giữ lại một từ tiếng Anh khác. Cứ tiếp tục như vậy, cuối cùng bạn sẽ 
còn một chữ cái và chữ cái này cũng phải là một từ tiếng Anh có nghĩa---
tức là có trong từ điển. Tôi muốn biết rằng từ dài nhất như vậy là gì và
nó có mấy chữ cái?

Tôi sẽ cho bạn một từ ngắn làm ví dụ: Sprite. Được chứ? Bắt đầu với
\textit{sprite}, bạn bỏ bớt một chữ cái trong từ đó, bỏ chữ r đi, 
và chúng ta còn lại từ \textit{spite}, sau đó ta bỏ chữ cái e ở cuối,
ta còn lại từ \textit{spit}, ta bỏ đi chữ s, ta còn lại từ \textit{pit},
\textit{it}, và \textit{I}.
\end{quote}

\index{lược bớt (từ)}
\index{từ, có thể lược bớt}

Hãy viết một chương trình để tìm tất cả những từ có thể lược đi kiểu này,
và sau đó tìm ra từ dài nhất trong số đó.

Bài tập này khó hơn một chút so với các bài khác trong cuốn sách này, và
tôi có một số gợi ý sau:

\begin{enumerate}

\item Bạn có thể sẽ muốn viết một hàm nhận vào một từ và tìm ra danh sách
  của tất cả các từ có thể hình thành được sau khi bỏ một chữ cái. Đó là
  những ``từ con'' của từ ban đầu.

\index{đệ quy, định nghĩa}
\index{định nghĩa!đệ quy}

\item Theo cách đệ quy, một từ được gọi là lược bớt được nếu như mọi từ con
của nó đều lược bớt được. Ở trường hợp cơ bản, có thể coi rằng một
chuỗi rỗng là lược bớt được.

\item Danh sách từ mà tôi cung cấp, {\tt words.txt}, không
chứa các từ có một chữ cái. Vì vậy bạn có thể muốn thêm vào 
``I'', ``a'', và chuỗi rỗng.

\item Để cải thiện tốc độ của chương trình, bạn có thể sẽ cần phải
ghi nhớ những từ đã xác định là lược bỏ được.

\end{enumerate}

Bạn có thể xem lời giải của tôi ở \url{thinkpython.com/code/reducible.py}.

\end{ex}




%\begin{ex}
%\url{wikipedia.org/wiki/Word_Ladder}
%\end{ex}




\chapter{Nghiên cứu cụ thể: lựa chọn cấu trúc dữ liệu}

\section{Phân tích tần số của từ vựng}
\label{analysis}

Như thường lệ, ít nhất là bạn phải cố gắng làm các bài tập sau đây
trước khi đọc lời giải của tôi.

\begin{ex}
Hãy viết một chương trình đọc vào một file, tách mỗi dòng thành các từ
riêng lẻ, cắt bỏ các dấu trắng và dấu câu, rồi chuyển chúng về
dạng chữ thường.

\index{string (module)}
\index{module!string}

Gợi ý: module {\tt string} cho ta hai chuỗi, {\tt whitespace}
chứa dấu cách, dấu tab, dấu xuống dòng, v.v., và {\tt
  punctuation} chứa các kí tự dấu câu.  Hãy thử làm Python 
chửi thề xem:

\beforeverb
\begin{verbatim}
>>> import string
>>> print string.punctuation
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\end{verbatim}
\afterverb
%
Có thể bạn cũng muốn dùng các phương thức chuỗi {\tt strip},
{\tt replace} và {\tt translate}.

\index{strip (phương thức)}
\index{phương thức!strip}
\index{replace (phương thức)}
\index{phương thức!replace}
\index{translate (phương thức)}
\index{phương thức!translate}

\end{ex}


\begin{ex}

\index{Dự án Gutenberg}

Hãy thăm dự án Gutenberg (\url{gutenberg.net}) và tải về
cuốn sách ưa thích của bạn dưới dạng file chữ.

\index{văn bản!thuần chữ}

Sửa chương trình trong bài tập trước để đọc được quyến sách vừa
tải về, bỏ qua đoạn thông tin ở đầu file, và xử lí phần còn lại
như bài trước.

Sau đó sửa chương trình để đếm số từ trong quyển sách, và số
lần mỗi từ được dùng đến.

\index{tần số!xuất hiện từ vựng}
\index{từ vựng!tần số}

In ra số từ khác nhau được dùng trong cuốn sách. So sánh những
cuốn sách viết bởi các tác giả khác nhau, viết trong những giai đoạn
khác nhau. Tác giả nào dùng lượng từ vựng nhiều nhất?
\end{ex}


\begin{ex}
Hãy sửa chương trình ở bài tập trước để in ra 20 từ được
dùng thường xuyên nhất trong cuốn sách.
\end{ex}


\begin{ex}
Hãy sửa chương trình trước để đọc vào một dánh sách các từ (xem
Mục~\ref{wordlist}) rồi in ra tất cả các từ trong cuốn sách mà không
nằm trong danh sách từ. Trong số đó có bao nhiêu lỗi in? Có bao nhiêu
từ thông dụng mà {\em đáng ra} phải có trong danh sách,
và bao nhiêu từ thực sự ít gặp?
\end{ex}


\section{Số ngẫu nhiên}

\index{số ngẫu nhiên}
\index{ngẫu nhiên, số}
\index{tất định}
\index{giả ngẫu nhiên}

Với cùng dữ liệu đầu vào, phần lớn các chương trình máy tính đều
cho ra kết quả giống hệt sau mỗi lần chạy, vì vậy ta nói chúng có
{\bf tính tất định}.
Tất định là một đặc tính tốt, vì ta thường trông đợi những kết quả
tính toán phải giống nhau. Tuy nhiên, ở một số ứng dụng, ta muốn
việc tính toán phải không định trước được. Các trò chơi trên máy
là ví dụ dễ thấy, ngoài ra còn những chương trình khác.

Để làm chương trình hoàn toàn không định trước hóa ra lại là một việc
không dễ dàng gì, nhưng có những cách làm cho chúng ít nhất là 
dường như không định trước. Một trong số đó là dùng những thuật toán
phát sinh ra số {\bf giả ngẫu nhiên}.
Số giả ngẫu nhiên không phải ngẫu nhiên thực sự vì được phát sinh từ
một phép toán tất định, nhưng chỉ nhìn vào những con số thì chúng ta
không thể phân biệt chúng với những số ngẫu nhiên thực sự.

\index{random (module)}
\index{module!random}

Module {\tt random} có các hàm phát sinh ra những số giả ngẫu nhiên
(để cho tiện, từ đây tôi sẽ gọi là ``ngẫu nhiên'').

\index{random (hàm)}
\index{hàm!random}

Hàm {\tt random} trả lại một số có phần thập phân, nằm giữa
0.0 và 1.0 (tính cả 0.0 nhưng không kể 1.0). Mỗi khi gọi
{\tt random}, bạn thu được số tiếp theo trong một dãy số dài. Để xem
một ví dụ, hãy chạy vòng lặp sau:

\beforeverb
\begin{verbatim}
import random

for i in range(10):
    x = random.random()
    print x
\end{verbatim}
\afterverb
%
Hàm {\tt randint} nhận các tham biến {\tt low} và
{\tt high} rồi trả lại một số nguyên nằm trong khoảng từ {\tt low} đến
{\tt high} (kể cả hai đầu).

\index{randint (hàm)}
\index{hàm!randint}

\beforeverb
\begin{verbatim}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
\end{verbatim}
\afterverb
%
Để chọn ngẫu nhiên một phần tử từ một dãy, bạn có thể dùng
{\tt choice}:

\index{choice (hàm)}
\index{hàm!choice}

\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
\end{verbatim}
\afterverb
%
Module {\tt random} cũng có các hàm để phát sinh những giá trị
ngẫu nhiên từ những dạng phân bố liên tục bao gồm phân bố chuẩn,
lũy thừa, gamma và một số dạng khác.

\begin{ex}

\index{histogram!lựa chọn ngẫu nhiên}

Hãy viết một hàm có tên \verb"choose_from_hist" nhận vào một
histogram như đã đề cập trong Mục~\ref{histogram} và trả lại một
giá trị ngẫu nhiên từ histogram, được chọn với xác suất tỉ lệ
với tần suất xuất hiện. Chẳng hạn, với histogram sau:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'a', 'b']
>>> h = histogram(t)
>>> print h
{'a': 2, 'b': 1}
\end{verbatim}
\afterverb
%
hàm bạn viết cần trả lại {\tt 'a'} với xác suất $2/3$ và \verb"'b'"
với xác suất $1/3$.
\end{ex}


\section{Bảng tần số của từ vựng}

Sau đây là một chương trình để đọc vào một file và lập một bảng
tần số các từ xuất hiện trong file đó:


\index{bảng tần số!tần số của từ vựng}

\beforeverb
\begin{verbatim}
import string

def process_file(filename):
    h = dict()
    fp = open(filename)
    for line in fp:
        process_line(line, h)
    return h

def process_line(line, h):
    line = line.replace('-', ' ')
    
    for word in line.split():
        word = word.strip(string.punctuation + string.whitespace)
        word = word.lower()

        h[word] = h.get(word, 0) + 1

hist = process_file('emma.txt')
\end{verbatim}
\afterverb
%
Chương trình này đọc file {\tt emma.txt}, vốn có nội dung là truyện {\em
  Emma} của Jane Austen.

\index{Austin, Jane}

\verb"process_file" lặp qua các dòng trong file,
lần lượt chuyển từng dòng vào \verb"process_line". Bảng tần số
{\tt h} được dùng như một biến tích lũy.

\index{biến tích lũy!bảng tần số}
\index{duyệt}

\verb"process_line" dùng phương thức chuỗi {\tt replace} để thay thế
dấu gạch nối từ với dấu cách trước khi dùng {\tt split} để tách 
một dòng thành một danh sách các chuỗi. Nó duyệt một dãy các từ và dùng {\tt strip} và {\tt lower} để bỏ các dấu câu và chuyển về dạng chữ thường. (Ở đây
ta chỉ nói tắt là ``chuyển đổi'' chuỗi; hãy nhớ rằng kiểu chuỗi 
không thể thay đổi được, vì vậy các phương thức như {\tt strip} và {\tt lower}
đều trả về chuỗi mới.)

Cuối cùng, \verb"process_line" cập nhật bảng tần số bằng cách tạo ra một
mục mới hoặc tăng thêm 1 cho mục sẵn có.

\index{cập nhật!bảng tần số}

Để đếm tổng số từ trong file, ta cần cộng các tần số trong bảng lại:

\beforeverb
\begin{verbatim}
def total_words(h):
    return sum(h.values())
\end{verbatim}
\afterverb
%
Số các từ khác nhau chính bằng số các mục trong từ điển:

\beforeverb
\begin{verbatim}
def different_words(h):
    return len(h)
\end{verbatim}
\afterverb
%
Sau đây là đoạn mã để in kết quả:

\beforeverb
\begin{verbatim}
print 'Total number of words:', total_words(hist)
print 'Number of different words:', different_words(hist)
\end{verbatim}
\afterverb
%
Và kết quả:

\beforeverb
\begin{verbatim}
Total number of words: 161073
Number of different words: 7212
\end{verbatim}
\afterverb
%

\section{Những từ thông dụng nhất}

\index{DSU (dạng mẫu)}
\index{dạng mẫu!DSU}

Để tìm những từ thông dụng nhất, ta có thể áp dụng dạng mẫu DSU;
\verb"most_common" nhận một bảng tần số và trả lại một danh sách các
bộ từ-tần số, được sắp xếp theo thứ tự tần số giảm dần:

\beforeverb
\begin{verbatim}
def most_common(h):
    t = []
    for key, value in h.items():
        t.append((value, key))

    t.sort(reverse=True)
    return t
\end{verbatim}
\afterverb
%
Sau đây là một vòng lặp in ra mười từ thông dụng nhất:

\beforeverb
\begin{verbatim}
t = most_common(hist)
print 'The most common words are:'
for freq, word in t[0:10]:
    print word, '\t', freq
\end{verbatim}
\afterverb
%
Và đây là kết quả thu được từ truyện {\em Emma}:

\beforeverb
\begin{verbatim}
The most common words are:
to      5242
the     5204
and     4897
of      4293
i       3191
a       3130
it      2529
her     2483
was     2400
she     2364
\end{verbatim}
\afterverb
%

\section{Tham biến tùy chọn}

\index{tham biến!tùy chọn}
\index{tùy chọn!tham biến}

Ta đã thấy các hàm và phương thức có sẵn, chúng nhận vào một số lượng
các đối số thay đổi. Ta còn có thể viết những hàm có đối số tùy chọn.
Chẳng hạn, sau đây là một hàm để in ra những từ thông dụng nhất dựa theo
bảng tần số

\beforeverb
\begin{verbatim}
def print_most_common(hist, num=10)
    t = most_common(hist)
    print 'The most common words are:'
    for freq, word in t[0:num]:
        print word, '\t', freq
\end{verbatim}
\afterverb

Tham biến thứ nhất là bắt buộc; tham biến thứ hai có thể tùy chọn.
{\bf Giá trị mặc định} của {\tt num} là 10.

\index{mặc định (giá trị)}
\index{giá trị!mặc định}

Nếu bạn chỉ cung cấp một đối số:

\beforeverb
\begin{verbatim}
print_most_common(hist)
\end{verbatim}
\afterverb

thì {\tt num} sẽ nhận giá trị mặc định. Nếu bạn cung cấp hai đối số:

\beforeverb
\begin{verbatim}
print_most_common(hist, 20)
\end{verbatim}
\afterverb

thì thay vào đó {\tt num} sẽ lấy giá trị từ đối số. Nói cách khác,
đối số tùy chọn sẽ {\bf chiếm chỗ} giá trị mặc định.

\index{chiếm chỗ (giá trị mặc định)}

Nếu như một hàm có cả tham số bắt buộc và tham số tùy chọn thì
tất cả tham số bắt buộc phải được viết trước, rồi mới đến tham số
tùy chọn.


\section{Phép trừ các từ điển}

\index{từ điển!phép trừ}
\index{phép trừ!từ điển}

Việc tìm những từ trong cuốn sách mà không có trong danh sách từ
{\tt words.txt} là một bài toán có thể bạn nhận ra đó chính là 
phép trừ tập hợp; nghĩa là ta muốn tìm tất cả các từ trong một 
tập hợp (các từ trong cuốn sách) mà không có trong tập hợp kia
(các từ trong từ điển).

{\tt subtract} nhận vào hai từ điển {\tt d1} và {\tt d2} rồi trả về
một tử điển mới bao gồm tất cả các khóa của {\tt d1} mà không có
trong {\tt d2}.  Vì chúng ta không thực sụ quan tâm đến các 
giá trị, ta gán chúng đều bằng None.

\beforeverb
\begin{verbatim}
def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
\end{verbatim}
\afterverb
%
Để tìm những từ trong cuốn sách mà không có trong {\tt words.txt},
ta có thể dùng \verb"process_file" để lập một bảng tần số cho
{\tt words.txt}, rồi sau đó thực hiện phép trừ:

\beforeverb
\begin{verbatim}
words = process_file('words.txt')
diff = subtract(hist, words)

print "The words in the book that aren't in the word list are:"
for word in diff.keys():
    print word,
\end{verbatim}
\afterverb
%
Sau đây là một đoạn kết quả tìm được từ {\em Emma}:

\beforeverb
\begin{verbatim}
The words in the book that aren't in the word list are:
 rencontre jane's blanche woodhouses disingenuousness 
friend's venice apartment ...
\end{verbatim}
\afterverb
%
Một số từ trong đó là các tên riêng và sở hữu cách. Các từ khác,
như ``rencontre,'' hiện tại ít được dùng. Nhưng vẫn có một số ít từ
thông dụng mà đáng ra phải có trong danh sách!

\begin{ex}

\index{tập hợp}
\index{kiểu!tập hợp}

Python có một cấu trúc dữ liệu tên là {\tt set} trong đó có chứa nhiều
phép toán thông dụng với tập hợp. Hãy đọc tài liệu tại
\url{docs.python.org/lib/types-set.html} và viết một chương trình
trong đó dùng phép trừ tập hợp để tìm những từ trong cuốn sách mà
không có trong danh sách từ.
\end{ex}


\section{Những từ ngẫu nhiên}
\label{randomwords}

\index{bảng tần số!lựa chọn ngẫu nhiên}

Để chọn một từ ngẫu nhiên từ bảng tần số, thuật toán đơn giản nhất
là lập một danh sách với mỗi từ lặp lại nhiều lần, dựa theo tần số
quan sát được, và sau đó thì lựa chọn từ danh sách:

\beforeverb
\begin{verbatim}
def random_word(h):
    t = []
    for word, freq in h.items():
        t.extend([word] * freq)

    return random.choice(t)
\end{verbatim}
\afterverb
%
Biểu thức  {\tt [word] * freq} tạo ra một danh sách chứa {\tt freq}
lần lặp lại chuỗi {\tt word}.  Phương thức {\tt extend}
cũng tương tự như {\tt append} ngoại trừ rằng đối số là một dãy.

\begin{ex}
\label{randhist}

\index{thuật toán}

Thuật toán này hoạt động được, nhưng không hiệu quả lắm; mỗi khi
bạn chọn một từ ngẫu nhiên, nó lại lập lại danh sách, mà danh sách 
này lớn bằng cuốn sách ban đầu. Một cách cải thiện dễ thấy là lập
danh sách một lafn và sau đó chọn nhiều lần, nhưng danh sách vẫn
còn lớn.

Một cách làm khác là:

\begin{enumerate}

\item Dùng {\tt keys} để lấy một danh sách các từ trong cuốn sách.

\item Lập một danh sách có chứa tổng lũy tích của các tần số từ 
  (xem Bài tập~\ref{cumulative}).  Mục từ cuối 
  trong danh sách này là số từ trong cuốn sách này, $n$.
  
\item Chọn một số ngẫu nhiên từ 1 đến $n$.  Dùng cách tìm kiếm nhị phân
  (Xem Bài tập~\ref{bisection}) để tìm chỉ số mà tại đó số ngẫu nhiên cần
  được điền vào cho tổng lũy tích.
  
\item Dùng chỉ số để tìm ra từ tương ứng trong danh sách các từ

\end{enumerate}

Hãy viết một chương trình dùng thuật toán này để chọn một từ ngẫu nhiên
từ cuốn sách.
\end{ex}



\section{Phép phân tích Markov}

\index{phân tích Markov}

Nếu bạn chọn các từ trong cuốn sách một cách ngẫu nhiên, bạn chỉ có thể 
có những từ đúng, nhưng không thể có một câu đúng:

\beforeverb
\begin{verbatim}
this the small regard harriet which knightley's it most things
\end{verbatim}
\afterverb
%
Một loạt các từ ngẫu nhiên hiếm khi có nghĩa vì không có mối liên hệ
nào giữa những từ kế tiếp. Chẳng hạn, trong
một câu thực sự bạn sẽ mong đợi một mạo từ như ``the'' đi trước
một tính từ hoặc danh từ, và có lẽ không đi trước một động từ
hoặc trạng từ.

Một cách lượng hóa những mối liên hệ như vậy là phép phân tích
Markov\footnote{Nghiên cứu cụ thể này được dựa vào một ví dụ của 
  Kernighan and Pike trong cuốn {\em The Practice of Programming}, 1999.}, 
trong đó cho trước một dãy các từ, ta phải tìm xác suất của từ 
đi kế tiếp. Chẳng hạn, bài hát {\em Eric, the Half a
  Bee} bắt đầu với:

\begin{quote}
Half a bee, philosophically, \\
Must, ipso facto, half not be. \\
But half the bee has got to be \\
Vis a vis, its entity. D'you see? \\
\\
But can a bee be said to be \\
Or not to be an entire bee \\
When half the bee is not a bee \\
Due to some ancient injury? \\
\end{quote}
%
Trong bài này,
cụm từ ``half the'' luôn được tiếp nối bởi từ ``bee,''
nhưng cụm từ ``the bee'' có thể được nối tiếp bởi 
``has'' hoặc ``is''.

\index{tiền tố}
\index{hậu tố}
\index{khớp}

Kết quả của việc phân tích Markov là một quy tắc khớp giữa mỗi tiền tố
(như ``half the'' và ``the bee'') với tất cả những hậu tố có thể có 
(như ``has'' và ``is'').

\index{ngẫu nhiên, văn bản}
\index{văn bản!ngẫu nhiên}

Cho trước quy tắc khớp này, bạn có thể phát sinh một văn bản ngẫu nhiên
bằng cách bắt đầu với một tiền tố bất kì và chọn một hậu tố khả dĩ một
cách ngẫu nhiên. Sau đó, bạn có thể kết hợp đoạn cuối của tiền tố và 
hậu tố mới tìm được để hình thành một tiền tố mới cho bước tính toán 
tiếp theo.

Chẳng hạn, nếu bạn bắt đầu với tiền tố ``Half a,'' thì từ tiếp theo 
phải là ``bee,'' bởi vì tiền tố này chỉ xuất hiện một lần duy nhất trong văn bản. 
Tiền tố tiếp theo là ``a bee,'' vì vậy hậu tố tiếp theo có thể là ``philosophically,'' 
``be'' hoặc ``due.''

Trong ví dụ này độ dài của tiền tố luôn là hai, nhưng bạn có thể phân tích
Markov với tiền tố dài bất kì. Độ dài của tiền tố được gọi
là ``bậc'' của phân tích.

\begin{ex}
Phép phân tích Markov:

\begin{enumerate}

\item Hãy viết một chương trình đọc một văn bản từ một file và thực hiện
phân tích Markov. Kết quả cần thu được là một từ điển khớp các tiền tố
với một tập hợp các hậu tố có thể có. Tập hợp này có thể là danh sách,
bộ, hoặc từ điển, tùy bạn chọn. Bạn có thể chạy thử chương trình với 
tiền tố có độ dài bằng 2, nhưng bạn nên viết chương trình sao cho 
dễ thử được với những độ dài khác.

\item Hãy thêm một hàm vào chương trình trên để phát sinh một văn bản
ngẫu nhiên dựa trên phép phân tích Markov. Sau đây là một ví dụ từ truyện 
{\em Emma} với độ dài tiền tố bằng 2:

\begin{quote}
He was very clever, be it sweetness or be angry, ashamed or only
amused, at such a stroke. She had never thought of Hannah till you
were never meant for me?" "I cannot make speeches, Emma:" he soon cut
it all himself.
\end{quote}

Ở ví dụ này, tôi để nguyên dấu câu đi liền với các từ. 
Kết quả tương đối đúng về mặt ngữ pháp, nhưng không hoàn toàn.
Về ngữ nghĩa nó dường như có nghĩa, nhưng cũng không hoàn toàn.

Điều gì sẽ xảy ra nếu tôi tăng chiều dài tiền tố? Liệu văn bản ngẫu nhiên
lần này có nghĩa hơn không?

\index{trộn lẫn}

\item Một khi chương trình của bạn chạy được, có thể bạn muốn thử trộn lẫn:
nếu bạn phân tích văn bản từ nhiều cuốn sách khác nhau, văn bản ngẫu nhiên
được phát sinh sẽ hòa trộn từ và cụm từ những cuốn sách ban đầu
theo cách khá thú vị.

\end{enumerate}
\end{ex}


\section{Cấu trúc dữ liệu}

\index{cấu trúc dữ liệu}

Việc dùng phép phân tích Markov để phát sinh văn bản ngẫu nhiên thật thú vị,
nhưng cũng có một mục đích để luyện tập lập trình: kĩ năng chọn cấu trúc dữ liệu.
Trong lời giải của bạn cho các bài tập trước, bạn đã phải chọn:

\begin{itemize}

\item Cách biểu diễn các tiền tố. 

\item Cách biểu diễn tập hợp các hậu tố có thể có. 

\item Cách biểu diễn quy tắc khớp giữa mỗi tiền tố với tập hợp các hậu tố có thể.

\end{itemize}

Được rồi, điều cuối cùng rất dễ dàng; dạng khớp duy nhất mà chúng ta biết
chính là từ điển, và đây là cách lựa chọn rất tự nhiên.

Với các tiền tố, lựa chọn dễ thấy nhất là dùng chuỗi, danh sách các chuỗi,
hoặc bộ các chuỗi. Với các hậu tố, một lựa chọn là danh sách; lựa chọn
khác là bảng tần số (từ điển).

\index{cách thực hiện}

Bạn lựa chọn bằng cách nào đây? Bước đầu tiên là nghĩ về những phép thao tác
cần thực hiện trên từng cấu trúc dữ liệu. Với các tiền tố, ta cần có khả năng
bỏ được những từ ở phía đầu và thêm vào những từ ở phía cuối. Chẳng hạn,
nếu tiền tố hiện tại là ``Half a,'' và từ tiếp theo là ``bee,'' bạn cần có khả năng
tạo thành tiền tố thiếp theo là ``a bee.''

\index{bộ!khóa trong từ điển}

Lựa chọn ban đầu của bạn có thể là danh sách, vì ta dễ dàng thêm và bỏ
các phần tử của nó, nhưng ta cũng cần dùng được các tiền tố như các
khóa trong từ điển; vì vậy mà ta phải loại bỏ khả năng dùng danh sách.
Khi dùng bộ, bạn không thể thêm vào hoặc xóa đi, nhưng có thể dùng
toán tử cộng để hình thành một bộ mới:

\beforeverb
\begin{verbatim}
def shift(prefix, word):
    return prefix[1:] + (word,)
\end{verbatim}
\afterverb
%
{\tt shift} nhận vào một bộ các từ, {\tt prefix}, và một chuỗi, 
{\tt word}, rồi hình thành một bộ mới chứa tất cả những từ trong
{\tt prefix} ngoại trừ từ thứ nhất, và thêm {\tt word} vào cuối.

Với tập hợp các hậu tố, những phép thao tác cần thực hiện gồm có
thêm vào một hậu tố mới (hoặc tăng tần số của một hậu tố sẵn có),
và chọn một hậu tố ngẫu nhiên.

Việc thêm một hậu tố mới cũng dễ thực hiện trên danh sách như
trên bảng tần số. Việc chọn một phần tử ngẫu nhiên từ danh sách 
thì dễ; chọn từ bảng tần số một cách hiệu quả thì khó thực hiện hơn
(xem Bài tập~\ref{randhist}).

Đến đây chúng ta mới chỉ chủ yếu bàn về độ khó dễ khi thực hiện,
nhưng còn những yếu tố khác cần tính đến khi chọn các cấu trúc
dữ liệu. Một trong số đó là thời gian chạy. Đôi khi có một nguyên
nhân về mặt lí thuyết khiến ta mong đợi rằng một cấu trúc dữ liệu
này nhanh hơn cấu trúc khác; chẳng hạn, tôi đã đề cập rằng toán
tử {\tt in} dùng với từ điển thì nhanh hơn dùng với danh sách,
ít nhất là khi có rất nhiều phần tử.

Nhưng thường thì bạn sẽ không biết trước được là cách thực hiện
nào sẽ nhanh hơn. Một lựa chọn là thực hiện cả hai và xem cách
nào tốt hơn. Cách tiếp cận này được gọi là {\bf đánh giá bằng so sánh}.
Một cách làm thực tiễn khác là chọn cấu trúc dữ liệu dễ thực hiện
nhất, vá sau đó xem nó có đủ nhanh khi dùng trong ứng dụng 
được viết hay không. Nếu đủ nhanh thì không cần phải sửa nữa.
Nếu không thì có những công cụ, như module {\tt profile}, có thể
chỉ ra những chỗ trong chương trình mà chạy mất nhiều thời gian nhất.

\index{đánh giá bằng so sánh}
\index{profile (module)}
\index{module!profile}

Yếu tố khác cần tính đến là dung lượng lưu trữ. Chẳng hạn, việc dùng
một bảng tần số để tập hợp các hậu tố có thể sẽ chiếm ít dung lượng
hơn vì bạn chỉ cần lưu mỗi từ một lần, bất kể từ đó được dùng bao nhiêu
lần trong văn bản. Trong một số trường hợp khác, việc tiết kiệm dung lượng
cũng có thể làm chương trình của bạn chạy nhanh hơn, và ngược lại,
có thể làm chương trình của bạn không chạy được do hết bộ nhớ.
Tuy nhiên, với nhiều ứng dụng, dung lượng là vấn đề thứ yếu sau bộ nhớ.

Một suy nghĩ sau cùng: với nội dung thảo luận ở trên, tôi có ngụ ý là
chúng ta nên dùng một cấu trúc dữ liệu chung cho cả việc phân tích
và phát sinh. Nhưng vì đây là hai khâu riêng biệt, ta cũng có thể dùng
một cấu trúc dữ liệu để phân tích sau đó chuyển đổi sang một cấu trúc
khác cho việc phát sinh. Cách này tính ra sẽ có lợi nếu như khoảng thời gian 
tiết kiệm được khi phát sinh lớn hơn thời gian để chuyển đổi.


\section{Gỡ lỗi}
\index{gỡ lỗi}

Khi gỡ lỗi một chương trình, đặc biệt là khi bạn cố gắng gỡ một lỗi
hóc búa, có bốn việc mà bạn nên thử như sau:

\begin{description}

\item[đọc:] Xem xét mã lệnh, tự đọc và diễn giải nó, và kiểm tra xem
nó có thực hiện đúng ý định của bạn không.

\item[chạy:] Thử nghiệm bằng cách thay đổi và chạy các bản mã lệnh
khác nhau. Thường khi bạn hiển thị đúng thứ cần thiết ở một vị trí đúng
trong chương trình thì bài toán đã rõ ràng, nhưng đôi khi bạn phải
dành thời gian để dựng dàn giáo.

\item[tư duy:] Hãy dành thời gian để suy nghĩ! Lỗi xảy ra thuộc loại gì:
cú pháp, thực thi, hay ngữ nghĩa? Bạn rút được thông tin gì từ thông báo lỗi,
từ kết quả đầu ra của chương trình? Loại lỗi gì có thể gây ra vấn đề
mà bạn thấy được? Trước khi có vấn đề xảy ra, bạn đã sửa đổi mã lệnh
ở chỗ nào?

\item[rút lui:] Sẽ có lúc nhất định, cách làm tốt nhất là rút lui, thu lại những
thay đổi gần nhất, đến khi bạn trở về trạng thái của chương trình chạy được
mà bạn cũng hiểu được. Sau đó bạn có thể bắt đầu phát triển lại chương trình.

\end{description}

Các lập trình viên mới đôi khi cũng bị lún sâu vào một trong những cách
làm sau mà quên mất những cách còn lại. Mỗi cách gắn liền với một
kiểu nhược điểm riêng.

\index{lỗi chính tả}

Chẳng hạn, việc đọc mã lệnh có thể giúp bạn nếu như vấn đề xảy ra 
thuộc về lỗi chính tả, nhưng sẽ không ích gì nếu như vấn đề ở chỗ hiểu sai
khái niệm. Nếu bạn không hiểu chương trình làm việc gì, có thể bạn sẽ
phải đọc nó 100 lần mà vẫn không thấy lỗi, vì lỗi nằm ngay trong đầu bạn.

\index{gỡ lỗi thử nghiệm}

Việc chạy các thử nghiệm có thể sẽ giúp bạn, đặc biệt khi bạn chạy
những bài kiểm tra ngắn, đơn giản. Nhưng nếu bạn chạy thử nghiệm mà
không nghĩ hoặc đọc mã lệnh, có thể bạn sẽ rơi vào trường hợp 
mà tôi gọi là ``lập trình theo bước ngẫu nhiên,'' tức là quá trình
tạo ra những thay đổi ngẫu nhiên đến khi chương trình chạy đúng.
Khỏi cần phải nói, việc lập trình theo ngẫu nhiên có thể sẽ rất tốn thời gian.

\index{lập trình theo bước ngẫu nhiên}
\index{kế hoạch phát triển!lập trình theo bước ngẫu nhiên}

Bạn cần phải dành thời gian suy nghĩ. Gỡ lỗi cũng giống như một ngành
khoa học thực nghiệm. Bạn cần phải có ít nhất một giả thiết về vấn đề
cần giải quyết là gì. Nếu có hai hay nhiều khả năng xảy ra, cố gắng nghỉ ra một
phép thử để loại bỏ một khả năng trong số đó.

Việc nghỉ ngơi cũng giúp ích cho suy nghĩ. Việc nói năng cũng vậy.
Nếu bạn giải thích vấn đề cho một người khác (hoặc thậm chí cho chính bạn),
có thể đôi khi bạn sẽ tìm được lời giải ngay trước lúc kết thúc lời nói.

Nhưng ngay cả những kĩ thuật gỡ lỗi tốt nhất cũng thất bại khi có quá nhiều
lỗi, hoặc khi mã lệnh bạn cần sửa quá lớn và phức tạp. Đôi lúc giải pháp
tốt nhất là rút lui, làm đơn giản chương trình cho đến khi bạn có được
phiên bản chương trình hoạt động được và bạn hiểu được nó.

Các lập trình viên mới thường miễn cưỡng trong việc rút lui vì họ
không thể chịu được khi xóa một dòng lệnh (ngay cả khi nó sai).
Nếu bạn cảm thấy tiện thì có thể sao chép chương trình ra một file khác
trước khi bắt tay vào việc lược bỏ nó. Sau đó bạn có thể dán các phần
cũ trở lại, mỗi lúc một ít.

Để tìm ra một lỗi hóc búa đòi hỏi phải đọc, chạy mã lệnh, suy nghĩ,
và đôi khi rút lui. Nếu bạn bị sa lầy vào một trong những việc trên thì
hãy thử các việc còn lại.


\section{Thuật ngữ}

\begin{description}

\item[tất định:] Tính chất của chương trình thực hiện công việc giống nhau
ở mỗi lần chạy và cho ra kết quả như nhau.
\index{tất định}

\item[giả ngẫu nhiên:] Tính chất của dãy số nhìn có vẻ ngẫu nhiên, nhưng được
phát sinh bởi một chương trình tất định.
\index{giả ngẫu nhiên}

\item[giá trị mặc định:] Giá trị được gán cho tham biến tùy chọn nếu 
không nhập vào đối số.
\index{giá trị mặc định}

\item[chiếm chỗ:] Sự thay thế giá trị mặc định bởi một đối số.
\index{chiếm chỗ}

\item[đánh giá bằng so sánh:] Quá trình chọn lựa giữa các cấu trúc dữ liệu
bằng cách thực hiện các phương án rồi kiểm thử chúng theo một mẫu 
số liệu có thể.  
\index{đánh giá bằng so sánh}

\end{description}


\section{Bài tập}

\begin{ex}

\index{từ, tần số}
\index{tần số!từ}
\index{định luật Zipf}

``Hạng'' của một từ là vị trí của nó trong một danh sách các từ
xếp theo tần số: từ thường gặp nhất có hạng 1, từ thường gặp thứ nhì
có hạng 2, v.v.

Định luật Zipf mô tả mối liện hệ giữa hạng và tần số của từ trong
ngôn ngữ tự nhiên\footnote{Xem
  \url{wikipedia.org/wiki/Zipf's_law}.}. Đặc biệt hơn, nó còn 
dự đoán  rằng tần số $f$ của từ có hạng $r$ là:

\[ f = c r^{-s} \]
%
trong đó $s$ và $c$ là các tham số phụ thuộc vào ngôn ngữ và
văn bản. Nếu lấy logarit hai vế của phương trình trên, bạn sẽ
thu được:

\index{logarithm}

\[ \log f = \log c - s \log r \]
%
Vì vậy khi vẽ đồ thị $\log f$ theo $\log r$, bạn sẽ được một
đường thẳng với độ dốc $-s$ và giao điểm $\log c$ với trục tung.

Hãy viết một chương trình để đọc văn bản vào từ một file, đếm 
tần số các từ, và in ra mỗi từ trên một dòng, theo thứ tự giảm dần
của tần số, cùng với
$\log f$ và $\log r$. Hãy dùng chương trình vẽ biểu đồ mà bạn chọn
để vẽ đồ thị kết quả và kiểm tra xem liệu nó có hình thành một
đường thẳng không. Bạn có thể ước tính giá trị của $s$ không?
\end{ex}


\chapter{File}

\index{file}
\index{kiểu!file}


\section{Sự duy trì dữ liệu}

\index{duy trì dữ liệu}

Phần lớn các chương trình ta đã thấy đến giờ đều có tính nhất
thời về khía cạnh dữ liệu; theo nghĩa chúng chạy trong một
thời gian ngắn, tạo ra kết quả nhưng khi kết thúc thì dữ liệu
cũng biến mất. Nếu bạn chạy lại, chương trình sẽ bắt đầu
với một trạng thái trống rỗng.

Các chương trình khác có tính {\bf duy trì dữ liệu}: chúng chạy
trong thời gian dài (hoặc luôn luôn chạy); và giữ lại ít nhất một
phần dữ liệu trong một thiết bị lưu dữ liệu vĩnh viễn (ví dụ như ổ đĩa);
và sau khi được kết thúc và khởi động lại, chương trình
sẽ bắt đầu từ điểm mà chúng tạm dừng trước đây.

Các ví dụ về chương trình duy trì bao gồm các hệ điều hành,
luôn được chạy mỗi khi máy tính được bật lên, và trình phục vụ
web, vốn được chạy mọi lúc, đợi các yêu cầu gửi đến từ
mạng máy tính.

Một trong những cách đơn giản nhất để chương trình có thể
duy trì dữ liệu của chúng là bằng cách đọc và ghi các file chữ.
Ta đã thấy các chương trình đọc được file chữ; ở chương này
ta sẽ thấy chương trình ghi file.

Một cách khác là lưu trạng thái của chương trình vào trong một
cơ sở dữ liệu. Ở chương này tôi sẽ trình bày một cơ sở dữ liệu
đơn giản và một module, {\tt pickle}, giúp cho việc lưu trữ dữ liệu
của chương trình được dễ dàng.

\index{pickle (module)}
\index{module!pickle}


\section{Đọc và ghi}

\index{file!đọc và ghi}

Một file chữ là một dãy các kí tự được lưu trên một thiết bị
vĩnh viễn như một ổ đĩa cứng, bộ nhớ flash, hoặc đĩa CD-ROM. 
Ta đã thấy cách mở và đọc file ở Mục~\ref{wordlist}.

\index{open (hàm)}
\index{hàm!open}

Để ghi một file, bạn cần mở nó theo chế độ
\verb"'w'" đặt như tham biến thứ hai:

\beforeverb
\begin{verbatim}
>>> fout = open('output.txt', 'w')
>>> print fout
<open file 'output.txt', mode 'w' at 0xb7eb2410>
\end{verbatim}
\afterverb
%
Nếu file đã tồn tại, việc mở nó với chế độ w (ghi) sẽ xóa sạch
dữ liệu cũ và bắt đầu với file trống, nên hãy cẩn thận!
Nếu file chưa tồn tại, sẽ có một file mới được tạo ra.

Phương thức {\tt write} đưa dữ liệu vào trong file.

\beforeverb
\begin{verbatim}
>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
\end{verbatim}
\afterverb
%
Một lần nữa, đối tượng file theo dõi vị trí hiện thời, vì vậy
nếu bạn gọi lại {\tt write} lần nữa, nó sẽ ghi dữ liệu mới
vào cuối file.

\beforeverb
\begin{verbatim}
>>> line2 = "the emblem of our land.\n"
>>> fout.write(line2)
\end{verbatim}
\afterverb
%
Khi ghi xong, bạn phải đóng file lại.

\beforeverb
\begin{verbatim}
>>> fout.close()
\end{verbatim}
\afterverb
%

\index{close (phương thức)}
\index{phương thức!close}


\section{Toán tử định dạng}

\index{định dạng, toán tử}
\index{toán tử!định dạng}

Đối số của {\tt write} phải là một chuỗi, vì vậy nếu muốn
đưa các giá trị khác vào một file, ta cần phải chuyển đổi
chúng thành chuỗi. Cách dễ nhất để làm điều đó là dùng {\tt str}:

\beforeverb
\begin{verbatim}
>>> x = 52
>>> f.write(str(x))
\end{verbatim}
\afterverb
%
Một cách khác là dùng {\bf toán tử định dạng}, {\tt \%}.  Khi
áp dụng nó cho các số nguyên, {\tt \%} là toán tử chia lấy dư. Nhưng
khi hạng tử thứ nhất là một chuỗi, {\tt \%} là toán tử định dạng.

\index{chuỗi định dạng}

Hạng tử thứ nhất là {\bf chuỗi định dạng}, bao gồm một
hoặc nhiều {\bf dãy định dạng}, để chỉ định cách định dạng
cho toán hạng thứ hai. Kết quả sẽ là một chuỗi.

\index{dãy định dạng}

Chẳng hạn, dãy định dạng \verb"'%d'" có nghĩa là hạng tử
thứ hai cần được định dạng như một số nguyên 
 ({\tt d} là viết tắt của ``decimal''):

\beforeverb
\begin{verbatim}
>>> camels = 42
>>> '%d' % camels
'42'
\end{verbatim}
\afterverb
%
Kết quả là chuỗi \verb"'42'", mà ta không nên nhầm nó với 
giá trị nguyên {\tt 42}.

Một dãy định dạng có thể xuất hiện bất cứ đâu trong chuỗi,
vì vậy bạn có thể gài một giá trị vào trong một câu:

\beforeverb
\begin{verbatim}
>>> camels = 42
>>> 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
\end{verbatim}
\afterverb
%
Nếu có nhiều dãy định dạng trong chuỗi thì hạng tử thứ hai
phải là một bộ. Mỗi dãy định dạng được cặp với một phần tử
của bộ theo đúng thứ tự.

Ví dụ sau sử dụng \verb"'%d'" để định dạng một số nguyên
\verb"'%g'" để định dạng một số có phần thập phân (đừng hỏi 
lí do dùng kí hiệu này), và \verb"'%s'" để định dạng một chuỗi:

\beforeverb
\begin{verbatim}
>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
\end{verbatim}
\afterverb
%
Số phần tử của bộ cần phải bằng số dãy định dạng có trong
chuỗi. Ngoài ra, kiểu của các phần tử cũng phải hợp với kiểu
của chuỗi định dạng:

\index{biệt lệ!TypeError}
\index{TypeError}

\beforeverb
\begin{verbatim}
>>> '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> '%d' % 'dollars'
TypeError: illegal argument type for built-in operation
\end{verbatim}
\afterverb
%
Ở ví dụ thứ nhất, không có đủ các phần tử; ở ví dụ thứ hai,
phần tử có kiểu sai.

Toán tử định dạng rất đa năng, như có thể khó sử dụng. Bạn hãy
tham khảo thêm thông tin ở
\url{docs.python.org/lib/typesseq-strings.html}.

% You can specify the number of digits as part of the format sequence.
% For example, the sequence \verb"'%8.2f'"
% formats a floating-point number to be 8 characters long, with
% 2 digits after the decimal point:

% \beforeverb
% \begin{verbatim}
% >>> '%8.2f' % 3.14159
% '    3.14'
% \end{verbatim}
% \afterverb
% %
% The result takes up eight spaces with two
% digits after the decimal point.  


\section{Tên file và đường dẫn}
\label{paths}

\index{tên file}
\index{đường dẫn}
\index{thư mục}

File được tổ chức trong các {\bf thư mục}. Mỗi chương trình chạy
có một ``thư mục hiện thời,'' đó là thư mục mặc định cho hầu hết
các thao tác. Chẳng hạn, khi bạn mở một file để đọc, Python tìm
nó trong thư mục hiện thời.

\index{os (module)}
\index{module!os}

Module {\tt os} có các hàm làm việc với file và thư mục
(``os'' là viết tắt của ``operating system'').  {\tt os.getcwd}
trả lại tên của thư mục hiện thời:

\index{getcwd (hàm)}
\index{hàm!getcwd}

\beforeverb
\begin{verbatim}
>>> import os
>>> cwd = os.getcwd()
>>> print cwd
/home/dinsdale
\end{verbatim}
\afterverb
%
{\tt cwd} là viết tắt của ``current working directory.''  Kết quả của 
ví dụ này là {\tt /home/dinsdale}, chính là thư mục chủ của
một người dùng có tên {\tt dinsdale}.

\index{thư mục làm việc}

Một chuỗi như {\tt cwd} để nhận diện một file được gọi là {\bf đường dẫn}.
Một {\bf đường dẫn tương đối} bắt đầu từ thư mục hiện thời;
một {\bf đường dẫn tuyệt đối} bắt đầu từ thư mục gốc của 
hệ thống file.

\index{đường dẫn!tương đối}
\index{đường dẫn!tuyệt đối}

Các đường dẫn ta đã thấy đến giờ chỉ là tên file đơn giản, vì vậy
chúng là đường dẫn tương đối đến thư mục hiện thời. Để tìm
đường dẫn tuyệt đối đến một file, bạn có thể dùng {\tt os.path.abspath}:

\beforeverb
\begin{verbatim}
>>> os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
\end{verbatim}
\afterverb
%
{\tt os.path.exists} kiểm tra xem một file hoặc thư mục có tồn tại không:

\index{exists (hàm)}
\index{hàm!exists}

\beforeverb
\begin{verbatim}
>>> os.path.exists('memo.txt')
True
\end{verbatim}
\afterverb
%
Nếu tồn tại, {\tt os.path.isdir} sẽ kiểm tra xem nó có phải là thư mục không:

\beforeverb
\begin{verbatim}
>>> os.path.isdir('memo.txt')
False
>>> os.path.isdir('music')
True
\end{verbatim}
\afterverb
%
Tương tự, {\tt os.path.isfile} kiểm tra xem nó có phải là file không.

{\tt os.listdir} trả lại một danh sách các file (và những thư mục khác)
trong thư mục đã cho:

\beforeverb
\begin{verbatim}
>>> os.listdir(cwd)
['music', 'photos', 'memo.txt']
\end{verbatim}
\afterverb
%
Để giới thiệu các hàm này, ví dụ sau có nhiệm vụ ``dò'' một
thư mục, in ra tên của tất cả các file, và gọi bản thân nó một cách
đệ quy với tất cả các thư mục.

\index{dò thư mục}
\index{thư mục!dò}

\beforeverb
\begin{verbatim}
def walk(dir):
    for name in os.listdir(dir):
        path = os.path.join(dir, name)

        if os.path.isfile(path):
            print path
        else:
            walk(path)
\end{verbatim}
\afterverb
%
{\tt os.path.join} nhận vào một thư mục và một tên file
rồi nối chúng lại thành một đường dẫn hoàn chỉnh.

\begin{ex}
Hãy sửa lại {\tt walk} để nó thay vì in ra các tên file thì trả lại
một danh sách các tên.
\end{ex}

\begin{ex}
Module {\tt os} có một hàm tên là {\tt walk} cũng giống như
hàm trên nhưng linh hoạt hơn. Hãy đọc tài liệu và dùng hàm đó
để in ra tên của các file trong thư mục đã cho và các thư mục con.
\end{ex}


\section{Bắt các biệt lệ}
\label{catch}

Khi bạn đọc và ghi file, một loạt những lỗi có thể xảy ra. Nếu
bạn mở một file hiện không tồn tại, bạn sẽ nhận lỗi 
{\tt IOError}:

\index{open (hàm)}
\index{hàm!open}
\index{biệt lệ!IOError}
\index{IOError}

\beforeverb
\begin{verbatim}
>>> fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad_file'
\end{verbatim}
\afterverb
%
Nếu bạn không có quyền truy cập một file:

\index{file!quyền}
\index{quyền, file}

\beforeverb
\begin{verbatim}
>>> fout = open('/etc/passwd', 'w')
IOError: [Errno 13] Permission denied: '/etc/passwd'
\end{verbatim}
\afterverb
%
Và nếu bạn mở một thư mục để đọc, bạn sẽ nhận được lỗi:

\beforeverb
\begin{verbatim}
>>> fin = open('/home')
IOError: [Errno 21] Is a directory
\end{verbatim}
\afterverb
%
Để tránh các lỗi này, bạn có thể dùng các hàm như {\tt os.path.exists}
và {\tt os.path.isfile}, nhưng sẽ mất nhiều thời gian và câu lệnh để
kiểm tra hết tất cả các trường hợp có thể (nếu coi ``{\tt Errno 21}'' là 
chỉ thị báo lỗi, thì ít nhất có 21 điều khác nhau có thể gây ra lỗi).

\index{biệt lệ!bắt}
\index{try (câu lệnh)}
\index{câu lệnh!try}

Tốt hơn là bạn bắt tay trực tiếp thử, và giải quyết các vấn đề nảy sinh,
giống như cách mà câu lệnh {\tt try} thực hiện. Cú pháp lệnh này cũng
giống như lệnh {\tt if}:

\beforeverb
\begin{verbatim}
try:    
    fin = open('bad_file')
    for line in fin:
        print line
    fin.close()
except:
    print 'Something went wrong.'
\end{verbatim}
\afterverb
%
Python bắt đầu bằng việc thực hiện nhánh {\tt try}. Nếu tất cả
chạy tốt, nó sẽ bỏ qua nhánh {\tt except} và tiếp tục. Nếu có
biệt lệ xảy ra, nó sẽ nhảy khỏi nhánh {\tt try} và thực hiện
nhánh {\tt except}.

Việc xử lý một biệt lệ bằng cách dùng lệnh {\tt try} được gọi là {\bf
bắt} một biệt lệ. Ở ví dụ này, nhánh {\tt except} 
in ra một thông báo lỗi không có ích lắm. Nói chung, việc bắt biệt lệ
cho bạn một cơ hội sửa lỗi, hoặc thử lại, hoặc ít nhất là kết thúc
chương trình một cách tốt đẹp.


\section{Cơ sở dữ liệu}

\index{cơ sở dữ liệu}

{\bf Cơ sở dữ liệu} là một file được tổ chức để lưu dữ liệu.
Đa số các cơ sở dữ liệu được tổ chức như một từ điển ở chỗ
chúng khớp các khóa với giá trị. Điểm khác biệt lớn nhất là
cơ sở dữ liệu ở trên đĩa (hoặc một thiết bị lưu trữ vĩnh viễn khác),
vì vậy nó còn tồn tại sau khi chương trình kết thúc.

\index{anydbm (module)}
\index{module!anydbm}

Module {\tt anydbm} cung cấp một giao diện phục vụ việc tạo lập
và cập nhật file cơ sở dữ liệu. Tôi sẽ lấy một ví dụ cho việc tạo lập
cơ sở dữ liệu chứa tiêu đề của các file hình ảnh.

\index{open (hàm)}
\index{hàm!open}

Việc mở một cơ sở dữ liệu cũng giống như mở các file khác:

\beforeverb
\begin{verbatim}
>>> import anydbm
>>> db = anydbm.open('captions.db', 'c')
\end{verbatim}
\afterverb
%
Chế độ \verb"'c'" có nghĩa là cơ sở dữ liệu sẽ được tạo mới
nếu như nó chưa tồn tại. Kết quả là một đối tượng cơ sở dữ liệu
có thể được dùng giống như một từ điển (ở hầu hết các thao tác).
Nếu bạn tạo một mục mới, {\tt anydbm} sẽ cập nhật file cơ sở dữ liệu.

\index{cập nhật!cơ sở dữ liệu}


\beforeverb
\begin{verbatim}
>>> db['cleese.png'] = 'Photo of John Cleese.'
\end{verbatim}
\afterverb
%
Khi bạn truy cập đến một mục, {\tt anydbm} sẽ đọc file:

\beforeverb
\begin{verbatim}
>>> print db['cleese.png']
Photo of John Cleese.
\end{verbatim}
\afterverb
%
Nếu bạn lại gán cho một khóa đã tồn tại, {\tt anydbm} sẽ thay thế
giá trị cũ:

\beforeverb
\begin{verbatim}
>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
>>> print db['cleese.png']
Photo of John Cleese doing a silly walk.
\end{verbatim}
\afterverb
%
Nhiều phương thức của từ điển, như {\tt keys} và {\tt items}, cũng
có tác dụng với các đối tượng cơ sở dữ liệu. Việc lặp với lệnh {\tt for}
cũng như vậy.

\index{phương thức của từ điển!module anydbm}

\beforeverb
\begin{verbatim}
for key in db:
    print key
\end{verbatim}
\afterverb
%
Cũng như các file khác, bạn nên đóng cơ sở dữ liệu khi xong việc:

\beforeverb
\begin{verbatim}
>>> db.close()
\end{verbatim}
\afterverb
%

\index{close (phương thức)}
\index{phương thức!close}


\section{Bảo lưu dữ liệu}

\index{bảo lưu}

Hạn chế của {\tt anydbm} là ở chỗ các khóa và trị phải là các chuỗi.
Nếu bạn thử dùng bất cứ kiểu nào khác, bạn sẽ nhận được lỗi.

\index{pickle (module)}
\index{module!pickle}

Module {\tt pickle}\footnote{Pickle = ngâm muối, ướp muối để bảo quản (nghĩa gốc tiếng Anh)} có thể khắc phục điều trên. Nó dịch hầu hết các
kiểu đối tượng ra kiểu chuỗi phù hợp cho việc lưu trong cơ sở 
dữ liệu, và sau đó lại dịch các chuỗi trở lại thành đối tượng.

{\tt pickle.dumps} nhận vào một đối tượng như một tham biến và
trả về dạng chuỗi biểu diễn cho nó ({\tt dumps} và viết tắt của ``dump string''):

\beforeverb
\begin{verbatim}
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
'(lp0\nI1\naI2\naI3\na.'
\end{verbatim}
\afterverb
%
Dạng này không dễ đọc; nó phù hợp để {\tt pickle} diễn giải.
{\tt pickle.loads} (``load string'') lại khôi phục đối tượng:

\beforeverb
\begin{verbatim}
>>> t1 = [1, 2, 3]
>>> s = pickle.dumps(t1)
>>> t2 = pickle.loads(s)
>>> print t2
[1, 2, 3]
\end{verbatim}
\afterverb
%
Mặc dù đối tượng mới có cùng giá trị với đối tượng cũ, nói chung
là chúng không đồng nhất với nhau:

\beforeverb
\begin{verbatim}
>>> t1 == t2
True
>>> t1 is t2
False
\end{verbatim}
\afterverb
%
Nói cách khác, việc bảo quản và phục hồi sử dụng có cùng tác dụng
như sao chép đối tượng.

Bạn có thể dùng {\tt pickle} để lưu các kiểu dữ liệu không phải chuỗi
trong cơ sở dữ liệu. Thực ra, sự kết hợp này thông dụng đến nỗi
nó được gói trong một module tên là {\tt shelve}.  

\index{shelve (module)}
\index{module!shelve}


\begin{ex}

\index{tập hợp!các từ đảo}

Nếu bạn đã làm Bài tập~\ref{anagrams}, hãy sửa lại lời giải sao cho
nó tạo ra một cơ sở dữ liệu khớp mỗi từ trong danh sách với một
danh sách các từ cũng được lập bởi các chữ cái của từ đầu.

Hãy viết một chương trình khác để mở cơ sở dữ liệu và in nội dung
ra dưới dạng mà chúng ta có thể đọc được.
\end{ex}


\section{Ống dẫn dữ liệu}

\index{lớp vỏ}
\index{ống dẫn}

Hầu hết các hệ điều hành đều cung cấp một giao diện dòng lệnh,
cũng được gọi là {\bf lớp vỏ}. Lớp vỏ hệ điều hành thường có các câu lệnh
để di chuyển trong hệ thống file và khởi động các ứng dụng. Chẳng hạn,
trong Unix, bạn có thể thay đổi thưu mục bằng {\tt cd},
hiển thị nội dung thư mục bằng {\tt ls}, và khởi động một
trình duyệt web bằng cách gõ vào một lệnh như {\tt firefox}.

\index{ls (lệnh Unix)}
\index{lệnh Unix!ls}

Bất kì chương trình nào bạn khởi động từ lớp vỏ cũng có thể được
khởi động từ Python bằng cách dùng một {\bf ống dẫn}. Ống dẫn là
đối tượng để biểu thị một quá trình đang chạy.

Chẳng hạn, lệnh Unix {\tt ls -l} thường để hiển thị 
nội dung của thư mục hiện thời (theo dạng đầy đủ). Bạn có thể
khởi động {\tt ls} bằng {\tt os.popen}:

\index{popen (hàm)}
\index{hàm!popen}

\beforeverb
\begin{verbatim}
>>> cmd = 'ls -l'
>>> fp = os.popen(cmd)
\end{verbatim}
\afterverb
%
Tham biến là một chuỗi trong đó có chứa một lệnh của lớp vỏ.
Giá trị được trả lại là một đối tượng có biểu hiện giống như
một file đang mở. Bạn có thể đọc kết quả đầu ra từ quá trình {\tt ls}
theo từng dòng một bằng {\tt readline} hoặc đọc tất cả một lượt
bằng {\tt read}:

\index{readline (phương thức)}
\index{phương thức!readline}
\index{read (phương thức)}
\index{phương thức!read}

\beforeverb
\begin{verbatim}
>>> res = fp.read()
\end{verbatim}
\afterverb
%
Khi đã xong việc, bạn đóng ống dẫn như làm với file:

\index{close (phương thức)}
\index{phương thức!close}

\beforeverb
\begin{verbatim}
>>> stat = fp.close()
>>> print stat
None
\end{verbatim}
\afterverb
%
Giá trị được trả về là trạng thái cuối cùng của quá trình {\tt ls};
{\tt None} có nghĩa là nó kết thúc bình thường (không có lỗi).

\index{file!nén}
\index{nén!file}
\index{lệnh Unix!gunzip}
\index{gunzip (lệnh Unix)}

Một cách sử dụng ống dẫn là đọc vào dần dần một file được nén;
nghĩa là không giải nén toàn bộ file cùng một lúc. Hàm sau đây 
nhận vào tên của file nén như một tham biến và trả về một 
ống dẫn có dùng {\tt gunzip} để giải nén nội dung:

\beforeverb
\begin{verbatim}
def open_gunzip(filename):
    cmd = 'gunzip -c ' + filename
    fp = os.popen(cmd)
    return fp
\end{verbatim}
\afterverb
%
Nếu đọc từng dòng một từ {\tt fp}, bạn không bao giờ phải lưu 
file được giải nén trên bộ nhớ hoặc đĩa.


\section{Viết các module}
\label{modules}

\index{module, viết}
\index{đếm từ}

Mọi file chứa mã lệnh Python đều có thể được nhập vào như một module.
Chẳng hạn, nếu bạn có một file tên là {\tt wc.py} với mã lệnh sau:

\beforeverb
\begin{verbatim}
def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print linecount('wc.py')
\end{verbatim}
\afterverb
%
Nếu bạn chạy chương trình này, nó sẽ đọc chính nó và in ra số
dòng trong file, tức là 7.
Bạn cũng có thể nhập nó vào như sau:

\beforeverb
\begin{verbatim}
>>> import wc
7
\end{verbatim}
\afterverb
%
Bây giờ bạn có một đối tượng module tên là {\tt wc}:

\index{module (đối tượng)}
\index{đối tượng!module}

\beforeverb
\begin{verbatim}
>>> print wc
<module 'wc' from 'wc.py'>
\end{verbatim}
\afterverb
%
Module này có một hàm tên là \verb"linecount":

\beforeverb
\begin{verbatim}
>>> wc.linecount('wc.py')
7
\end{verbatim}
\afterverb
%
Như vậy đó là cách bạn viết các module trong Python:

Vấn đề duy nhất ở ví dụ này là khi bạn nhập vào module nó
chạy đoạn mã lệnh ở dưới cùng. Thông thường khi bạn nhập
vào một module, nó định nghĩa các hàm mới như không
thực hiện chúng.

\index{import (câu lệnh)}
\index{câu lệnh!import}

Những chương trình được nhập như là module thường có
cách viết sau đây:

\beforeverb
\begin{verbatim}
if __name__ == '__main__':
    print linecount('wc.py')
\end{verbatim}
\afterverb
%
\verb"__name__" là một biến có sẵn, nó được đặt mỗi khi 
chương trình bắt đầu. Nếu chương trình chạy dưới dạng
một văn lệnh, \verb"__name__" sẽ có giá trị \verb"__main__"; 
trong trường hợp đó, đoạn mã lệnh kiểm tra sẽ được thực hiện.
Ngược lại, nếu module được nhập vào, mã lệnh kiểm tra 
sẽ được bỏ qua.

\begin{ex}

Hãy gõ ví dụ sau đây vào trong một file tên là {\tt wc.py} và chạy
nó như một văn lệnh. Sau đó khởi động trình thông dịch Python
và gõ vào {\tt import wc}.  Giá trị của \verb"__name__" sẽ là gì
khi module được nhập vào?

Lưu ý: Nếu bạn nhập vào một module mà đã được nhập từ trước,
Python sẽ không làm gì cả. Nó không đọc lại file nữa, ngay cả
khi file này bị thay đổi.

\index{module!reload}
\index{reload (hàm)}
\index{hàm!reload}

Nếu bạn muốn tải lại một module, bạn có thể dùng hàm có sẵn
{\tt reload}, nhưng khi dùng phải cẩn thận, và an toàn nhất là
khởi động lại trình thông dịch và nhập lại module một lần nữa.
\end{ex}



\section{Gỡ lỗi}

\index{gỡ lỗi}
\index{dấu trắng}

Trong quá trình đọc và ghi file, bạn có thể gặp vấn đề liên quan đến
dấu trắng. Những lỗi kiểu đó có thể khó gỡ vì các dấu cách, dấu tab
và dấu xuống dòng thông thường đều không hiện rõ trên màn hình:

\beforeverb
\begin{verbatim}
>>> s = '1 2\t 3\n 4'
>>> print s
1 2	 3
 4
\end{verbatim}
\afterverb

\index{repr (hàm)}
\index{hàm!repr}
\index{biểu diễn chuỗi}

Hàm có sẵn {\tt repr} có thể giúp ích. Nó nhận vào bất kì đối tượng nào
như một đối số và trả về một chuỗi biểu diễn đối tượng đó. Với các
chuỗi, nó biểu diễn dấu trắng bởi các dãy có dấu gạch chéo ngược:

\beforeverb
\begin{verbatim}
>>> print repr(s)
'1 2\t 3\n 4'
\end{verbatim}
\afterverb

Điều này có thể giúp ích cho việc gỡ lỗi.

Một vấn đề khác mà bạn có thể gặp phải là các hệ thống khác nhau
dùng những kí tự khác nhau để biểu thị chỗ kết thúc dòng. Một số
hệ thống dùng kí tự dòng mới, biểu thị bởi \verb"\n".  Một số khác
dùng kí tự trở về, kí hiệu \verb"\r".  Một số khác lại dùng cả hai.
Nếu bạn chuyển file giữa các hệ thống khác nhau, sự không thống
nhất này có thể làm nảy sinh vấn đề.

\index{kí tự cuối dòng}

Với phần lớn các hệ thống, có những trình ứng dụng để chuyển
giữa các dạng. Bạn có thể tìm chúng (hoặc đọc thêm về điều này)
ở \url{wikipedia.org/wiki/Newline}.  Hoặc tất nhiên là bạn có thể
tự viết một chương trình.


\section{Thuật ngữ}

\begin{description}

\item[duy trì:] Tính chất của một chương trình chạy lâu dài và
giữ lại ít nhất là một phần dữ liệu của nó trong thiết bị lưu trữ
vĩnh viễn.
\index{duy trì}

\item[toán tử định dạng:] Toán tử {\tt \%}, nhận vào một chuỗi
định dạng và một bộ rồi phát sinh ra một chuỗi trong đó bao gồm
các phần tử của bộ được định dạng như chỉ định trong chuỗi
định dạng.
\index{định dạng, toán tử}
\index{toán tử!định dạng}

\item[chuỗi định dạng:] Chuỗi được dùng với toán tử định dạng,
gồm các dãy định dạng.
\index{chuỗi định dạng}

\item[dãy định dạng:] Dãy kí tự trong một  chuỗi định dạng,
như {\tt \%d}, nhằm chỉ rõ cách định dạng cho một giá trị.
\index{dãy định dạng}

\item[file chữ:] Dãy các kí tự được lưu trong một thiết bị lưu trữ vĩnh viễn, 
như một ổ cứng.
\index{file chữ}

\item[thư mục:] Tập hợp được đặt tên chứa các file.
\index{thư mục}

\item[chuỗi:] Chuỗi để chỉ định một file.
\index{đường dẫn}

\item[đường dẫn gián tiếp:] Đường dẫn bắt nguồn từ thư mục hiện thời.
\index{đường dẫn gián tiếp}

\item[đường dẫn trực tiếp:] Đường dẫn bắt nguồn từ thư mục gốc 
trong hệ thống file.
\index{đường dẫn trực tiếp}

\item[bắt:] Thao tác ngăn ngừa việc biệt lệ xảy ra làm kết thúc chương trình,
được thực hiện bằng các lệnh {\tt try} và {\tt except}.
\index{bắt}

\item[cơ sở dữ liệu:] Một file mà nội dung được tổ chức như một từ điển
với các khóa tương ứng với các giá trị.
\index{cơ sở dữ liệu}

\end{description}


\section{Bài tập}

\begin{ex}
\label{urllib}

\index{urllib (module)}
\index{module!urllib}
\index{URL}

Module {\tt urllib} có các phương thức thao tác với các URL
và tải về thông tin từ mạng. Ví dụ sau tải về và in ra một
thông điệp bí mật từ {\tt thinkpython.com}:

\beforeverb
\begin{verbatim}
import urllib

conn = urllib.urlopen('http://thinkpython.com/secret.html')
for line in conn.fp:
    print line.strip()
\end{verbatim}
\afterverb

Hãy chạy đoạn mã lệnh này và thực hiện các chỉ dẫn được
hiện ra.

\index{bài tập bí mật}
\index{bí mật, bài tập}

\end{ex}

\begin{ex}
\label{checksum}

\index{MP3}

Trong một tập hợp gồm rất nhiều file MP3, có thể có nhiều bản sao
của cùng một bài hát lưu trong nhiều thư mục hoặc lưu dưới
nhiều tên khác nhau. Mục đích của bài tập này là tìm những
bản trùng tên đó.

\begin{enumerate}

\item Hãy viết một chương trình để tìm một thư mục và tất cả
các thư mục con của nó theo cách đệ quy, và trả về một danh sách
các đường dẫn đầy đủ tới tất cả các file có phần đuôi cho trước
(như {\tt .mp3}).
Gợi ý: {\tt os.path} có một số hàm giúp ích cho việc xử lí file và
tên đường dẫn.

\index{trùng lặp}
\index{MD5, thuật toán}
\index{thuật toán!MD5}
\index{checksum}

\item Để nhận biết được sự trùng lặp, bạn có thể dùng một
hàm băm đọc vào file và phát sinh một đoạn tóm tắt cho nội dung file.
Chẳng hạn, MD5 (Message-Digest algorithm 5) nhận vào một 
``thông điệp'' dài tùy ý và trả lại một ``checksum'' 128 bit. Xác suất
để hai nội dung khác nhau có thể trả về cùng checksum là rất nhỏ.

Bạn có thể tìm hiểu về MD5 tại \url{wikipedia.org/wiki/Md5}.  Trong
hệ thống Unix, bạn có thể dùng chương trình {\tt md5sum} và một ống dẫn
để tính checksum từ Python.

\index{ống dẫn}

\end{enumerate}

\end{ex}


\begin{ex}

\index{Internet Movie Database (IMDb)}
\index{IMDb (Internet Movie Database)}
\index{database}

Cơ sở dữ liệu Phim ảnh trên Internet, Internet Movie Database (IMDb)
là một tuyển tập trực tuyến lưu giữ các thông tin về 
những cuốn phim. Cơ sở dữ liệu này cũng sẵn có dưới
hình thức văn bản chữ, vì vậy sẽ khá dễ đọc từ Python. 
Trong bài tập này, các file bạn cần là {\tt actors.list.gz}
và {\tt actresses.list.gz}; bạn có thể tải chúng về từ 
\url{www.imdb.com/interfaces#plain}.

\index{văn bản!thuần chữ}
\index{tách}

Tôi đã viết một chương trình để tách các file này và 
phân nội dung riêng thành tên diễn viên, tựa đề phim, v.v. Bạn có thể
tải chúng về từ \url{thinkpython.com/code/imdb.py}.

Nếu bạn chạy {\tt imdb.py} như một văn lệnh, nó sẽ đọc {\tt actors.list.gz}
và in ra mỗi dòng một cặp diễn viên-bộ phim. Hoặc, nếu {\tt import
imdb} bạn có thể dùng hàm \verb"process_file" để 
xử lí file. Các đối số gồm có tên file, một đối tượng hàm và 
tùy chọn là số các dòng cần xử lí. Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
import imdb

def print_info(actor, date, title, role):
    print actor, date, title, role

imdb.process_file('actors.list.gz', print_info)
\end{verbatim}
\afterverb

Khi bạn gọi \verb"process_file", nó sẽ mở {\tt filename}, đọc 
nội dung, và gọi \verb"print_info" một lần cho mỗi dòng trong file.
\verb"print_info" nhận các đối số gồm có một tên diễn viên, 
ngày tháng, tựa đề phim và vai diễn rồi in chúng ra.

\begin{enumerate}

\item Hãy viết một chương trình để đọc vào {\tt actors.list.gz} và {\tt
  actresses.list.gz} rồi dùng {\tt shelve} để lập một cơ sở dữ liệu
  trong đó khớp tên từng diễn viên với một danh sách các bộ phim
  của diễn viên đó.
  
\index{shelve (module)}
\index{module!shelve}

\item Hai diễn viên là ``đồng minh tinh'' nếu họ diễn cùng trong ít nhất
  là một bộ phim. Hãy xử lí cơ sở dữ liệu vừa lập ra ở bước trên, và
  lập một cơ sở dữ liệu thứ hai trong đó khớp tên từng diễn viên với
  một danh sách các đồng minh tinh của diễn viên đó.

\index{Bacon, Kevin}
\index{Trò chơi Kevin Bacon}

\item Hãy viết một chương trình để chơi trò ``Six Degrees of Kevin
  Bacon,'' mà bạn có thể tìm hiểu tại
  \url{wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon}.  Vấn đề này
  rất khó vì nó đòi hỏi phải tìm đường đi ngắn nhất trong một đồ thị.
  Bạn có thể tìm hiểu về các thuật toán đường đi ngắn nhất tại 
  \url{wikipedia.org/wiki/Shortest_path_problem}.

\end{enumerate}

\end{ex}


\chapter{Lớp và đối tượng}


\section{Các kiểu dữ liệu do người dùng định nghĩa}
\label{point}

\index{kiểu!người dùng định nghĩa}

Ta đã dùng nhiều kiểu dữ liệu có sẵn trong Python; bây giờ ta sẽ 
định nghĩa một kiểu mới. Lấy ví dụ, ta sẽ tạo ra một kiểu gọi 
là {\tt Point} để biểu diễn một điểm trong không gian hai chiều.

\index{điểm, toán học}

Theo ngôn ngữ toán học, điểm thường được viết trong một cặp
ngoặc đơn với dấu phẩy ngăn cách giữa các tọa độ. Chẳng hạn,
$(0, 0)$ biểu diễn gốc tọa độ, và $(x, y)$ biểu diễn
điểm $x$ đơn vị về bên tay phải và $y$ đơn vị độ dài lên phía trên
so với điểm gốc.

Có một số cách để diễn tả một điểm bằng Python:

\begin{itemize}

\item Ta có thể lưu giữ các tọa độ một cách riêng rẽ trong hai
biến, {\tt x} và {\tt y}.

\item Ta có thẻ lưu giữ các tọa độ như những phần tử trong một danh sách
hoặc một bộ.

\item Ta có thể tạo ra một kiểu mới để diễn tả điểm như những đối tượng.

\end{itemize}

\index{biểu diễn}

Việc tạo ra một kiểu mới sẽ phức tạp hơn (một chút) so với những cách còn lại,
nhưng những ưu điểm của nó sẽ sớm trở nên rõ ràng sau này.

Một kiểu dữ liệu do người dùng định nghĩa được gọi là lớp {\bf lớp}.
Một định nghĩa lớp sẽ có dạng như sau:

\index{lớp}
\index{đối tượng}
\index{đinh nghĩa!lớp}
\index{lớp!định nghĩa}

\beforeverb
\begin{verbatim}
class Point(object):
    """represents a point in 2-D space"""
\end{verbatim}
\afterverb
%
Đoạn đầu này cho thấy lớp mới này là một {\tt Point},
vốn là một kiểu {\tt đối tượng}, và là một kiểu có sẵn.

\index{Point, lớp}
\index{lớp!Point}

Phần thân là một chuỗi ghi chú để giải thích mục đích của lớp này.
Bạn có thể định nghĩa các biến và hàm bên trong một định nghĩa lớp,
nhưng ta sẽ trở lại điều này sau.

\index{chuỗi ghi chú}

Việc định nghĩa một lớp tên là {\tt Point} sẽ tạo ra một đối tượng lớp.

\beforeverb
\begin{verbatim}
>>> print Point
<class '__main__.Point'>
\end{verbatim}
\afterverb
%
Vì {\tt Point} được định nghĩa ở cấp cao nhất, ``tên đầy đủ'' của nó
là \verb"__main__.Point".

\index{đối tượng!lớp}
\index{lớp, đối tượng}

Đối tượng lớp giống như một xưởng chế tạo ra các đối tượng. Để tạo ra
một Point, bạn gọi {\tt Point} như thể nó là một hàm.

\beforeverb
\begin{verbatim}
>>> blank = Point()
>>> print blank
<__main__.Point instance at 0xb7e9d3ac>
\end{verbatim}
\afterverb
%
Giá trị trả về là một tham chiếu tới một đối tượng Point, mà ta 
gán bằng {\tt blank}.  
Việc tạo ra đối tượng mới được gọi là
{\bf tạo cá thể}, và đối tượng là một {\bf cá thể} của
lớp này.

\index{cá thể}
\index{tạo cá thể}

Khi bạn in ra một cá thể, Python sẽ nói cho bạn biết cá thể này thuộc lớp nào
và nó được lưu vào đâu trong bộ nhớ (đoạn đầu
{\tt 0x} nghĩa là số tiếp sau sẽ tính theo hệ thập lục phân).

\index{thập lục phân}


\section{Thuộc tính}

\index{cá thể, thuộc tính}
\index{thuộc tính!cá thể}
\index{kí hiệu dấu chấm}

Bạn có thể gán các giá trị cho một cá thể bằng cách dùng kí hiệu dấu chấm:

\beforeverb
\begin{verbatim}
>>> blank.x = 3.0
>>> blank.y = 4.0
\end{verbatim}
\afterverb
%
Cú pháp này cũng giống như khi ta viết lệnh chọn một biến từ một 
module, như {\tt math.pi} hoặc {\tt string.whitespace}.  Tuy vậy, ở trường hợp
này, ta đang gán các giá trị cho các phần tử được đặt tên của một đối tượng.
Những phần tử này được gọi là {\bf thuộc tính}.

Trong tiếng Anh, thuộc tính là danh từ, được phát âm ``AT-trib-ute'' với trọng âm
đặt vào âm tiết đầu, khác với từ ``a-TRIB-ute,'' là một động từ.

Sơ đồ sau cho thấy kết quả của các phép gán này. Một sơ đồ trạng thái
chỉ ra đối tượng và các thuộc tính của nó được gọi là  {\bf sơ đồ đối tượng}:

\index{sơ đồ!trạng thái}
\index{sơ đồ!đối tượng}
\index{trạng thái, sơ đồ}
\index{đối tượng, sơ đồ}

\beforefig
\centerline{\includegraphics{figs/point.eps}}
\afterfig

Biến {\tt blank} chỉ đến một đối tượng Point, vốn
chứa hai thuộc tính. Mỗi thuộc tính lại chỉ đến một
số có phần thập phân.

Bạn có thể đọc giá trị của thuộc tính bằng cú pháp tương tự:

\beforeverb
\begin{verbatim}
>>> print blank.y
4.0
>>> x = blank.x
>>> print x
3.0
\end{verbatim}
\afterverb
%
Biểu thức {\tt blank.x} nghĩa là, ``Đến đối tượng mà {\tt blank}
chỉ tới và lấy giá trị của {\tt x}.'' Trong trường hợp này, ta gán
giá trị cho một biến tên là {\tt x}.  Không hề có sự xung đột giữa 
biến {\tt x} và thuộc tính {\tt x}.

Bạn có thể dùng kí hiệu dấu chấm như một phần của biểu thức bất kì. Chẳng hạn:

\beforeverb
\begin{verbatim}
>>> print '(%g, %g)' % (blank.x, blank.y)
(3.0, 4.0)
>>> distance = math.sqrt(blank.x**2 + blank.y**2)
>>> print distance
5.0
\end{verbatim}
\afterverb
%
Bạn có thể truyền một cá thể với vai trò của đối số theo cách thông thường.
Chẳng hạn:

\index{cá thể!vai trò đối số}

\beforeverb
\begin{verbatim}
def print_point(p):
    print '(%g, %g)' % (p.x, p.y)
\end{verbatim}
\afterverb
%
\verb"print_point" nhận vào đối số là một điểm và hiển thị nó theo kiểu kí hiệu toán học.
Để sử dụng hàm này, bạn có thể truyền {\tt blank} như một đối số:

\beforeverb
\begin{verbatim}
>>> print_point(blank)
(3.0, 4.0)
\end{verbatim}
\afterverb
%
Bên trong hàm, {\tt p} là một tên khác của {\tt blank}, vì vậy nếu
hàm làm thay đổi {\tt p} thì {\tt blank} cũng thay đổi theo.

\index{tham chiếu bội}


\begin{ex}
Hãy viết một hàm tên là {\tt distance} nhận vào hai điểm làm đối số
và và trả lại khoảng cách giữa hai điểm đó.
\end{ex}



\section{Hình chữ nhật}

Đôi khi có thể dễ thấy rằng các thuộc tính của một đối tượng phải là gì,
nhưng có những trường hợp bạn phải quyết định. Chẳng hạn, hãy hình dung
rằng bạn cần thiết kế một lớp để biểu diễn hình chữ nhật. Bạn sẽ sử dụng
những yếu tố gì để đặc trưng cho vị trí và kích thước của một hình chữ nhật.
Để đơn giản, ta không xét đến góc quay của hình chữ nhật và coi rằng
nó được đặt thẳng đứng hay nằm ngang.

\index{biểu diễn}

Có ít nhất là hai khả năng sau đây: 

\begin{itemize}

\item Bạn có thể chỉ định một đỉnh (điểm góc) của hình chữ nhật (hoặc tâm điểm),
bề rộng, và chiều cao.

\item Bạn có thể chỉ định hai đỉnh đối diện.

\end{itemize}

Đến đây ta khó nói trước rằng cách nào tốt hơn, vì vậy để làm ví dụ
ta sẽ làm theo cách thứ nhất.

\index{Rectangle, lớp}
\index{lớp!Rectangle}

Sau đây là định nghĩa lớp:

\beforeverb
\begin{verbatim}
class Rectangle(object):
    """represent a rectangle. 
       attributes: width, height, corner.
    """
\end{verbatim}
\afterverb
%
Chuỗi chú thích liệt kê các thuộc tính: {\tt width} và
{\tt height} là các số; {\tt corner} là một đối tượng điểm
chỉ định đỉnh góc trái phía dưới.

Để biểu diễn một hình chữ nhật, bạn phải tạo cá thể thuộc đối tượng Rectangle
và gán giá trị cho thuộc tính:

\beforeverb
\begin{verbatim}
box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
\end{verbatim}
\afterverb
%
Biểu thức {\tt box.corner.x} có nghĩa là,
``Đến đối tượng mà {\tt box} chỉ đến và chọn lấy thuộc tính có tên là
{\tt corner}; sau đó đến đối tượng đó và chọn lấy thuộc tính có tên là 
{\tt x}.''

Hình vẽ sau cho thấy trạng thái của đối tượng này:

\index{trạng thái, sơ đồ}
\index{sơ đồ!trạng thái}
\index{đối tượng, sơ đồ}
\index{sơ đồ!đối tượng}

\beforefig
\centerline{\includegraphics{figs/rectangle.eps}}
\afterfig

Một đối tượng được gọi là được {\bf nhúng} nếu nó là thuộc tính của một đối tượng khác.

\index{nhúng, đối tượng}
\index{đối tượng!được nhúng}


\section{Cá thể với vai trò là giá trị trả về}

\index{cá thể!giá trị trả về}
\index{giá trị trả về}

Các hàm có thể trả về các cá thể. Chẳng hạn, \verb"find_center"
nhận vào đối số là một {\tt Rectangle} và trả lại một {\tt Point}
trong đó chứa tọa độ của tâm điểm {\tt Rectangle}:

\beforeverb
\begin{verbatim}
def find_center(box):
    p = Point()
    p.x = box.corner.x + box.width/2.0
    p.y = box.corner.y + box.height/2.0
    return p
\end{verbatim}
\afterverb
%
Sau đây là một ví dụ trong đó truyền {\tt box} như một đối số và gán 
Point thu được cho {\tt center}:

\beforeverb
\begin{verbatim}
>>> center = find_center(box)
>>> print_point(center)
(50.0, 100.0)
\end{verbatim}
\afterverb
%

\section{Đối tượng là kiểu dữ liệu thay đổi được}

\index{đối tượng!thay đổi được}
\index{thay đổi được}

Bạn có thể thay đổi trạng thái của một đối tượng bằng cách thực hiện phép gán 
với một thuộc tính của nó. Chẳng hạn, để điều chỉnh kích thước của hình chữ nhật
mà không làm dịch chuyển nó, bạn có thể thay đổi các giá trị của {\tt
width} và {\tt height}:

\beforeverb
\begin{verbatim}
box.width = box.width + 50
box.height = box.width + 100
\end{verbatim}
\afterverb
%
Bạn cũng có thể viết các hàm để thay đổi đối tượng. Chẳng hạn,
\verb"grow_rectangle" nhận vào một đối tượng Rectangle và hai số,
{\tt dwidth} và {\tt dheight}, rồi cộng các số này với bề rộng và chiều cao 
của hình chữ nhật:

\beforeverb
\begin{verbatim}
def grow_rectangle(rect, dwidth, dheight) :
    rect.width += dwidth
    rect.height += dheight
\end{verbatim}
\afterverb
%
Sau đây là một ví dụ minh họa tác dụng của hàm này:

\beforeverb
\begin{verbatim}
>>> print box.width
100.0
>>> print box.height
200.0
>>> grow_rectangle(box, 50, 100)
>>> print box.width
150.0
>>> print box.height
300.0
\end{verbatim}
\afterverb
%
Ở trong hàm, {\tt rect} là một tên khác
của {\tt box}, vì vậy nếu hàm làm thay đổi {\tt rect}, 
{\tt box} cũng thay đổi theo.

\begin{ex}
Hãy viết một hàm có tên \verb"move_rectangle" nhận vào một
Rectangle và hai số tên là {\tt dx} và {\tt dy}.  Hàm này
cần thay đổi vị trí của hình chữ nhật bằng cách cộng {\tt dx}
với tọa độ {\tt x} của {\tt corner} và cộng {\tt dy}
với tọa độ {\tt y} của {\tt corner}.
\end{ex}


\section{Sao chép}

\index{tham chiếu bội}

Việc dùng tham chiếu bội có thể làm chương trình khó đọc vì sự
thay đổi ở một chỗ có thể gây ảnh hưởng không ngờ được ở chỗ khác.
Thật khó có thể theo dõi được tất cả các biến có khả năng chỉ đến
cùng một đối tượng.

\index{sao chép, đối tượng}
\index{đối tượng!sao chép}
\index{copy (module)}
\index{module!copy}

Sao chép một đối tượng thường là cách làm thay thế cho tham chiếu bội.
Module {\tt copy} có một hàm tên là {\tt copy} có thể
sao chép bất kì đối tượng nào:

\beforeverb
\begin{verbatim}
>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0

>>> import copy
>>> p2 = copy.copy(p1)
\end{verbatim}
\afterverb
%
{\tt p1} và {\tt p2} chứa dữ liệu giống nhau, nhưng chúng không cùng là 
một điểm (Point).

\beforeverb
\begin{verbatim}
>>> print_point(p1)
(3.0, 4.0)
>>> print_point(p2)
(3.0, 4.0)
>>> p1 is p2
False
>>> p1 == p2
False
\end{verbatim}
\afterverb
%
Toán tử {\tt is} cho thấy rằng {\tt p1} và {\tt p2} là các đối tượng khác nhau,
như chúng ta mong đợi. Nhưng có lẽ bạn cũng mong đợi rằng 
{\tt ==} sẽ cho kết quả {\tt True} vì những điểm này có số liệu như nhau.
Nếu vậy, bạn sẽ thất vọng khi biết rằng đối với các thể,
toán tử {\tt ==} sẽ hoạt động mặc định như toán tử
{\tt is}; nó kiểm tra sự đồng nhất của hai đối tượng, chứ không phải sự 
tương đương giữa chúng. Tính năng này vẫn có thể thay đổi được---sau này
ta sẽ biết cách thay đổi.

\index{is (toán tử)}
\index{toán tử!is}

Nếu dùng {\tt copy.copy} để tạo bản sao cho một Rectangle, bạn sẽ thấy rằng
nó sao chép đối tượng Rectangle nhưng không sao chép đối tượng Point được
nhúng trong đó.

\index{đối tượng nhúng!sao chép}

\beforeverb
\begin{verbatim}
>>> box2 = copy.copy(box)
>>> box2 is box
False
>>> box2.corner is box.corner
True
\end{verbatim}
\afterverb
%
Sơ đồ đối tượng sẽ có dạng sau:

\index{trạng thái, sơ đồ}
\index{sơ đồ!trạng thái}
\index{đối tượng, sơ đồ}
\index{sơ đồ!đối tượng}

\vspace{0.1in}
\beforefig
\centerline{\includegraphics{figs/rectangle2.eps}}
\afterfig
\vspace{0.1in}

Thao tác trên được gọi là {\bf sao chép nông} bởi vì nó chỉ sao chép 
đối tượng và các tham chiếu trong đó, mà không sao chép các đối tượng nhúng.

\index{sao chép nông}

Trong phần lớn các trường hợp, đây không phải là điều bạn muốn. Ở ví dụ này,
việc gọi \verb"grow_rectangle" từ một trong hai Rectangle sẽ không làm
ảnh hưởng đến đối tượng kia, nhưng \verb"move_rectangle" từ một đối tượng
sẽ làm ảnh hưởng đến cả hai! Hiện tượng này có thể làm ta bối rối và dễ gây lỗi.

\index{sao chép sâu}

Thật may là module {\tt copy} có một phương thức tên là {\tt
deepcopy} để sao chép không chỉ bản thân đối tượng mà còn cả 
những đối tượng mà nó chỉ đến, rồi cả những đối tượng mà 
{\em chúng} chỉ đến, và cứ như vậy.
Không ngạc nhiên khi người ta gọi thao tác này là {\bf sao chép sâu}.

\index{deepcopy (hàm)}
\index{hàm!deepcopy}

\beforeverb
\begin{verbatim}
>>> box3 = copy.deepcopy(box)
>>> box3 is box
False
>>> box3.corner is box.corner
False
\end{verbatim}
\afterverb
%
{\tt box3} và {\tt box} là các đối tượng hoàn toàn riêng biệt.


\begin{ex}
Hãy viết một dạng của \verb"move_rectangle" để tạo ra và
trả về một Rectangle mới thay vì sửa lại cá thể cũ.
\end{ex}


\section{Gỡ lỗi}
\label{hasattr}

\index{gỡ lỗi}

Khi bắt tay làm việc với các đối tượng, bạn có thể sẽ gặp 
một số biệt lệ mới. Nếu bạn thử truy cập một thuộc tính
không có sẵn, bạn sẽ nhận {\tt AttributeError}:

\index{biệt lệ!AttributeError}
\index{AttributeError}

\beforeverb
\begin{verbatim}
>>> p = Point()
>>> print p.z
AttributeError: Point instance has no attribute 'z'
\end{verbatim}
\afterverb
%
Nếu không biết rõ kiểu của một đối tượng nào đó, bạn có thể hỏi:
If you are not sure what type an object is, you can ask:

\index{type (hàm)}
\index{hàm!type}

\beforeverb
\begin{verbatim}
>>> type(p)
<type '__main__.Point'>
\end{verbatim}
\afterverb
%
Nếu không biết rõ liệu một đối tượng có một thuộc tính nào đó,
bạn có thể dùng hàm có sẵn {\tt hasattr}:

\index{hasattr (hàm)}
\index{hàm!hasattr}

\beforeverb
\begin{verbatim}
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
\end{verbatim}
\afterverb
%
Đối số thứ nhất có thể là một đối tượng bất kì; đối số thứ hai là một {\em
chuỗi} bao gồm tên của thuộc tính.


\section{Thuật ngữ}

\begin{description}

\item[lớp:] Kiểu dữ liệu do người dùng định nghĩa. Lời định nghĩa lớp sẽ tạo ra
một đối tượng lớp mới.
\index{lớp}

\item[đối tượng lớp:] Đối tượng trong đó bao gồm thông tin về một kiểu
do người dùng định nghĩa. Đối tượng lớp có thể được dùng để tạo ra các
cá thể của kiểu này.
\index{đối tượng}

\item[cá thể:] Đối tượng thuộc về một lớp.
\index{cá thể}

\item[thuộc tính:] Một trong các giá trị được đặt tên gắn với một đối tượng.
\index{thuộc tính, cá thể}
\index{cá thể!thuộc tính}

\item[nhúng (đối tượng):] Đối tượng được lưu trữ như một thuộc tính của một 
đối tượng khác.
\index{nhúng!đối tượng}
\index{đối tượng nhúng}

\item[sao chép nông:] Việc sao chép nội dung của một đối tượng, bao gồm cả
những tham chiếu đến các đối tượng nhúng;
được thực hiện bởi hàm {\tt copy} trong module {\tt copy}.
\index{sao chép nông}

\item[sao chép sâu:] Việc sao chép nội dung của một đối tượng cùng tất cả
đối tượng nhúng nếu có, và các đối tượng nhúng bên trong chúng, và cứ 
như vậy; được thực hiện bởi hàm {\tt deepcopy} trong module {\tt copy}.
\index{sao chép sâu}

\item[sơ đồ đối tượng:] Sơ đồ biểu diễn các đối tượng, thuộc tính của chúng
và các giá trị của thuộc tính.
\index{đối tượng!sơ đồ}
\index{sơ đồ đối tượng}

\end{description}


\section{Bài tập}

\begin{ex}
\label{canvas}

\index{Swampy}
\index{World (module)}
\index{module!World}

{\tt World.py} trong Swampy (see Chapter~\ref{turtlechap})
có chứa định nghĩa lớp cho một kiểu người dùng định nghĩa tên là
{\tt World}.  Bạn có thể nhập nó như sau:

\beforeverb
\begin{verbatim}
from World import World
\end{verbatim}
\afterverb

Phiên bản này của lệnh {\tt import} nhập vào lớp {\tt World}
từ module {\tt World}.
Đoạn mã lệnh sau tạo ra một đối tượng World và gọi
phương thức {\tt mainloop}, để đợi hoạt động từ phía người dùng.

\beforeverb
\begin{verbatim}
world = World()
world.mainloop()
\end{verbatim}
\afterverb

Một cửa sổ sẽ xuất hiện với thanh tiêu đề và một hình vuông trống không.
Ta sẽ dùng cửa sổ này để vẽ các điểm, hình chữ nhật, và các hình khác.
Hãy thêm các dòng lệnh sau đây trước khi gọi 
\verb"mainloop" và chạy lại chương trình.

\index{Canvas (đối tượng)}
\index{đối tượng!Canvas}

\beforeverb
\begin{verbatim}
canvas = world.ca(width=500, height=500, background='white')
bbox = [[-150,-100], [150, 100]]
canvas.rectangle(bbox, outline='black', width=2, fill='green4')
\end{verbatim}
\afterverb

Bạn sẽ thấy một hình chữ nhật màu xanh lá cây với viền đen.
Dòng lệnh thứ nhất tạo ra Canvas, vốn xuất hiện như một hình vuông
màu trắng trên cửa sổ. Đối tượng Canvas có các phương thức như
{\tt rectangle} để vẽ nhiều hình dạng khác nhau.

\index{hình bao}

{\tt bbox} là một danh sách chứa các danh sách biểu diễn ``hình bao''
của hình chữ nhất. Cặp tọa độ thứ nhất là của đỉnh góc dưới  bên trái;
cặp thứ hai của đỉnh góc phía trên bên phải.

Bạn có thể vẽ một đường tròn như sau:

\beforeverb
\begin{verbatim}
canvas.circle([-25,0], 70, outline=None, fill='red')
\end{verbatim}
\afterverb

\index{Bangladesh, quốc kì}

Tham số thứ nhất là cặp tọa độ tâm của đường tròn;
tham số thứ hai là bán kính.

Nếu bạn thêm dòng này vào chương trình, kết quả thu được sẽ giống
như quốc kì của Bangladesh
(xem \url{wikipedia.org/wiki/Gallery_of_sovereign-state_flags}).

\begin{enumerate}

\item Hãy viết một hàm tên là \verb"draw_rectangle" nhận vào một
  Canvas và Rectangle làm các đối số và vẽ hình biểu diễn
  Rectangle trên Canvas.

\item Hãy bổ sung một thuộc tính tên là {\tt color} cho các đối tượng Rectangle và
  sửa đổi \verb"draw_rectangle" sao cho nó dùng thuộc tính màu này làm màu tô.

\item Hãy viết một hàm tên là \verb"draw_point" nhận vào một 
  Canvas và một Point làm các đối số và vẽ hình biểu diễn
  Point trên Canvas.

\item Hãy định nghĩa một lớp mới có tên là Circle với các thuộc tính phù hợp rồi
  tạo ra một số cá thể thuộc đối tượng Circle. Hãy viết một hàm tên là
  \verb"draw_circle" để vẽ các Circle trên Canvas.

\index{Cộng hòa Séc, quốc kì}

\item Hãy viết một chương trình để vẽ hình quốc kì của nước Cộng hòa Séc.
  Gợi ý: bạn có thể vẽ một hình đa giác như sau:

\beforeverb
\begin{verbatim}
points = [[-150,-100], [150, 100], [150, -100]]
canvas.polygon(points, fill='blue')
\end{verbatim}
\afterverb

\end{enumerate}

\index{danh sách màu}
\index{các màu sẵn có}

Tôi đã viết một chương trình ngắn nhằm liệt kê các màu sẵn có; 
bạn có thể tải nó về từ \url{thinkpython.com/code/color_list.py}.

\end{ex}



\chapter{Lớp và hàm}
\label{time}


\section{Time}

Để lấy một ví dụ khác về kiểu người dùng định nghĩa, ta sẽ định nghĩa
một lớp tên là {\tt Time} để ghi lại thời gian trong ngày. Lời định nghĩa của
lớp này như sau:

\index{người dùng định nghĩa, kiểu}
\index{kiểu!người dùng định nghĩa}
\index{Time (lớp)}
\index{lớp!Time}

\beforeverb
\begin{verbatim}
class Time(object):
    """represents the time of day.
       attributes: hour, minute, second"""
\end{verbatim}
\afterverb
%
Ta có thể tạo ra một đối tượng {\tt Time} mới và gán các 
thuộc tính cho số giờ, phút, và giây:

\beforeverb
\begin{verbatim}
time = Time()
time.hour = 11
time.minute = 59
time.second = 30
\end{verbatim}
\afterverb
%
Sơ đồ trạng thái cho đối tượng {\tt Time} trông như sau:

\index{trạng thái, sơ đồ}
\index{sơ đồ!trạng thái}
\index{đối tượng, sơ đồ}
\index{sơ đồ!đối tượng}

\beforefig
\centerline{\includegraphics{figs/time.eps}}
\afterfig

\begin{ex}
\label{printtime}
Hãy viết một hàm có tên \verb"print_time" nhận vào một đối tượng
Time và in nội dung ra dưới dạng {\tt hour:minute:second}.
Gợi ý: dãy định dạng \verb"'%.2d'" dùng để in ra một số nguyên
với ít nhất là hai chữ số, trong đó có một chữ số 0 đứng đầu nếu cần.
\end{ex}

\begin{ex}
\label{is_after}

\index{hàm boole}

Hãy viết một hàm boole có tên \verb"is_after" nhận vào
hai đối tượng Time, {\tt t1} và {\tt t2}, rồi trả lại
{\tt True} nếu {\tt t1} xếp sau {\tt t2} về mặt thời gian và
{\tt False} nếu ngược lại.  Đố bạn thực hiện mà không cần lệnh {\tt if} ?
\end{ex}


\section{Hàm thuần túy}

\index{prototype and patch}
\index{kế hoạch phát triển!prototype and patch}

Ở các mục tiếp theo, ta sẽ viết hai hàm để cộng các giá trị thời gian.
Chúng sẽ đại diện cho hai loại hàm: hàm thuần túy và 
hàm sửa đổi. Đây cũng là minh họa cho một kế hoạch phát triển mà tôi gọi là {\bf
 hình mẫu và sửa chữa}, một cách xử lí vấn đề khó bằng cách 
bắt đầu bằng một hình mẫu đơn giản và dần xử lí những điểm phức tạp.

Sau đây là một hình mẫu đơn giản của \verb"add_time":

\beforeverb
\begin{verbatim}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    return sum
\end{verbatim}
\afterverb
%
Hàm này tạo ra một đối tượng {\tt Time} mới, khởi tạo các thuộc tính
của nó, và trả lại một tham chiếu đến đối tượng mới. Nó được gọi là
một {\bf hàm thuần túy} vì không làm thay đổi gì đến đối tượng được
truyền đến như đối số; và nó cũng không có hiệu ứng như hiển thị
một giá trị hay thu kết quả do người nhập vào, ngoại trừ việc trả lại
một giá trị.

\index{hàm thuần túy}
\index{kiểu hàm!thuần túy}

Để kiểm tra hàm này, tôi sẽ tạo ra hai đối tượng Time: {\tt start}
chứa thời điểm bắt đầu chiếu một bộ phim, như {\em Monty Python and the
Holy Grail}, cùng với {\tt duration} chứa thời lượng của phim,
bằng 1 giờ 35 phút.

\index{Monty Python and the Holy Grail}

\verb"add_time" sẽ tính ra khi nào bộ phim kết thúc.

\beforeverb
\begin{verbatim}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second =  0

>>> duration = Time()
>>> duration.hour = 1
>>> duration.minute = 35
>>> duration.second = 0

>>> done = add_time(start, duration)
>>> print_time(done)
10:80:00
\end{verbatim}
\afterverb
%
Kết quả, {\tt 10:80:00} có thể không được như bạn mong đợi.
Vấn đề là ở chỗ hàm này không tính được các trường hợp mà số phút
hoặc số giây cộng lại lớn hơn 60. Khi đó, ta cần phải ``nhớ'' đưa số giây còn dư
vào trong cột số phút, hoặc số phút còn dư vào trong cột số giờ.

\index{phép cộng có nhớ}

Sau đây là một phiên bản được sửa chữa:

\beforeverb
\begin{verbatim}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second

    if sum.second >= 60:
        sum.second -= 60
        sum.minute += 1

    if sum.minute >= 60:
        sum.minute -= 60
        sum.hour += 1

    return sum
\end{verbatim}
\afterverb
%
Mặc dù hàm này đã đúng, nó bắt đầu phình to lên. 
Chúng ta sẽ xét đến một cách khác ngay sau đây.


\section{Hàm sửa đổi}
\label{increment}

\index{hàm sửa đổi}
\index{loại hàm!sửa đổi}

Đôi sẽ hữu ích hơn khi một hàm có thể thay đổi các đối tượng khi chúng 
được truyền vào như tham biến. Trong trường hợp này, hàm gọi sẽ
nhận thấy được các thay đổi đó. Những hàm kiểu này được gọi là {\bf hàm thay đổi}.

\index{tăng}

Có thể viết {\tt increment}, một hàm để cộng một số giây cho trước vào
đối tượng {\tt Time}, dưới dạng một hàm thay đổi theo cách tự nhiên.
Sau đây là một bản phác thảo:

\beforeverb
\begin{verbatim}
def increment(time, seconds):
    time.second += seconds

    if time.second >= 60:
        time.second -= 60
        time.minute += 1

    if time.minute >= 60:
        time.minute -= 60
        time.hour += 1
\end{verbatim}
\afterverb
%
Dòng đầu tiên thực hiện phép tính cơ bản; phần còn lại xử lí các
trường hợp đặc biệt như ta đã thấy trước đây.

\index{trường hợp đặc biệt}

Hàm này có đúng không? Điều gì sẽ xảy ra khi tham biến {\tt seconds}
lớn hơn nhiều so với 60?

Trong trường hợp như vậy, việc cộng nhớ một lần là chưa đủ;
ta còn phải tiếp tục làm đến khi {\tt time.second} dưới 60.
Một cách giải quyết là thay các lệnh {\tt if} bằng các lệnh {\tt while}.
Việc này sẽ giúp ta có một hàm đúng, nhưng không hiệu quả lắm.

\begin{ex}
Hãy viết một dạng đúng của {\tt increment} mà 
không chứa vòng lặp nào.
\end{ex}

Hàm thuần túy có thể làm được bất cứ công việc nào thực hiện bởi
hàm thay đổi. Thật ra, một số ngôn ngữ lập trình chỉ cho phép dùng
hàm thuần túy. Đã có một số bằng chứng cho thấy những chương trình 
chỉ dùng hàm thuần túy thì được phát triển nhanh hơn và ít gây lỗi hơn
so với chương trình dùng hàm thay đổi. Nhưng có những lúc dùng hàm
thay đổi lại thuận tiện, và chương trình dùng hàm thuần túy lại kém hiệu quả.

Nói chung, tôi khuyên bạn dùng hàm thuần túy mỗi khi có thể, và chỉ
dùng hàm thay đổi khi có một ưu điểm rõ rệt. Cách tiếp cận này
có thể được gọi là {\bf phong cách lập trình hàm}.

\index{phong cách lập trình hàm}


\begin{ex}
Hãy viết một hàm thuần túy cho {\tt increment} để tạo ra và trả về
một đối tượng Time mới thay vì thay đổi tham biến.
\end{ex}


\section{So sánh việc tạo nguyên mẫu với lập kế hoạch}
\label{prototype}

\index{nguyên mẫu và sửa chữa}
\index{kế hoạch phát triển!nguyên mẫu và sửa chữa}
\index{phát triển theo kế hoạch}
\index{kế hoạch phát triển!lập kế hoạch}

Kế hoạch phát triển mà tôi sẽ trình bày sau đây được gọi là ``nguyên mẫu
và sửa chữa\footnote{thuật ngữ gốc có nghĩa là ``chắp vá''.}''. Với mỗi hàm, tôi viết một nguyên mẫu để thực hiện những
phép tính cơ bản và sau đó chạy thử nó, đồng thời sửa chữa những lỗi
phát sinh.

Cách làm này có thể hiệu quả, đặc biệt nếu bạn chưa có hiểu biết sâu sắc
về bài toán. Nhưng các sửa chữa dần có thể hình thành mã lệnh phức tạp
quá mức cần thiết---vì nó giải quyết nhiều trường hợp đặc biệt---và 
không đáng tin cậy---vì bạn khó có thể biết được rằng liệu đã tìm được
tất cả lỗi hay chưa.

Một cách làm khác là {\bf phát triển theo kế hoạch}, trong đó những
nhận định sâu sắc ở cấp độ cao về bài toán trước mắt có thể làm việc
lập trình đơn giản hơn nhiều. Trong trường hợp này, nhận định đó là
việc một đối tượng Time thật ra là số có 3 chữ số trong hệ cơ số 60
(xem \url{wikipedia.org/wiki/Sexagesimal}.)!  Thuộc tính
{\tt second} là ``cột 1,'' thuộc tính {\tt minute}
là ``cột 60,'' còn thuộc tính {\tt hour} là
``cột 3600.''

\index{sexagesimal}

Khi viết \verb"add_time" và {\tt increment}, ta đã thực hiện rất hiệu quả
phép cộng trên hệ 60, đó là lí do tại sao ta đã phải cộng có nhớ
khi chuyển sang cột tiếp theo.

\index{cộng có nhớ}

Kết quả quan sát này gợi ý cho ta một cách tiếp cận khác đến tổng thể
bài toán---ta có thể chuyển đối tượng Time ra các số nguyên và lợi dụng
khả năng làm tính cộng của máy tính.

Sau đây là một hàm để chuyển Time ra số nguyên:

\beforeverb
\begin{verbatim}
def time_to_int(time):
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
    return seconds
\end{verbatim}
\afterverb
%
Và sau đây là hàm để chuyển số nguyên thành Time
(nhớ lại rằng {\tt divmod} chia đối số thứ nhất cho
đối số thứ hai và trả về một bộ gồm có thương và số dư).

\index{divmod}

\beforeverb
\begin{verbatim}
def int_to_time(seconds):
    time = Time()
    minutes, time.second = divmod(seconds, 60)
    time.hour, time.minute = divmod(minutes, 60)
    return time
\end{verbatim}
\afterverb
%
Có thể bạn phải suy nghĩ thêm một chút, chạy thử một vài lần,
để tin rằng các hàm đó đều đúng. Một cách chạy thử là 
kiểm tra rằng \verb"time_to_int(int_to_time(x)) == x" cho nhiều giá trị
của {\tt x}. Đây là ví dụ về một phép kiểm tra sự nhất quán.

\index{kiểm tra sự nhất quán}

Một khi đã tin rằng các hàm  đều đúng, bạn có thể dùng chúng
để viết lại \verb"add_time":

\beforeverb
\begin{verbatim}
def add_time(t1, t2):
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
\afterverb
%
Bản này ngắn hơn so với bản đầu tiên, và dễ kiểm tra tính đúng đắn hơn.

\begin{ex}
Hãy viết lại {\tt increment} dùng \verb"time_to_int" và \verb"int_to_time".
\end{ex}

Bằng cách nào đó, các việc đổi từ hệ cơ số 60 sang hệ cơ số 10 và ngược lại
khó hơn so với chỉ thao tác với thời gian. Chuyển đổi giữa các hệ cơ số thì
trừu tượng hơn; trực giác của chúng ta hợp với việc tính toán các giá trị
thời gian hơn.

Nhưng nếu chúng ta hiểu sâu rằng có thể coi thời gian như số trong hệ 60
và dành thời gian để viết các hàm chuyển đổi (\verb"time_to_int"
và \verb"int_to_time"), ta sẽ thu được chương trình ngắn hơn, dễ đọc và
sửa lỗi, và đáng tin cậy hơn.

Ngoài ra, sau này ta cũng dễ thêm vào các tính năng khác. Chẳng hạn,
hãy hình dung việc trừ hai Time để tìm ra khoảng thời gian giữa chúng.
Cách làm tự nhiên là thực hiện phép trừ có nhớ. Nhưng việc dùng các
hàm chuyển đổi sẽ dễ hơn và có nhiều khả năng sẽ chính xác hơn.

\index{trừ có nhớ}
\index{khái quát hóa}

Điều nghịch lý là, đôi khi việc làm bài toán trở nên khó hơn (hoặc tổng 
quát hơn) hóa ra lại làm nó dễ hơn  (vì còn ít trường hợp đặc biệt và
ít khả năng gây lỗi).


\section{Gỡ lỗi}
\index{gỡ lỗi}

Một đối tượng Time sẽ hợp lệ nếu các giá trị của {\tt minutes} và {\tt
seconds} đề nằm giữa 0 và 60 (có thể bằng 0 nhưng không bằng 60) và
nếu {\tt hours} là số dương.  {\tt hours} và {\tt minutes} phải là các số
nguyên, nhưng {\tt seconds} được phép có phần thập phân.

\index{bất biến}

Những yêu cầu kiểu như vậy được gọi là các {\bf bất biến} vì chúng
cần phải luôn đúng. Nói cách khác, nếu chúng không đúng thì chương
trình sẽ có lỗi ở đâu đó.

Việc viết mã lệnh để kiểm tra các bất biến có thể giúp bạn phát hiện
các lỗi và tìm ra nguyên nhân gây lỗi. Chẳng hạn, giả sử bạn có một hàm
như \verb"valid_time" nhận vào một đối tượng Time và trả lại 
{\tt False} nếu một bất biến bị vi phạm:

\beforeverb
\begin{verbatim}
def valid_time(time):
    if time.hours < 0 or time.minutes < 0 or time.seconds < 0:
        return False
    if time.minutes >= 60 or time.seconds >= 60:
        return False
    return True
\end{verbatim}
\afterverb
%

Tiếp theo, ở đoạn đầu mỗi hàm, bạn có thể kiểm tra các đối số
để chắc rằng chúng đều hợp lệ:

\index{raise (lệnh)}
\index{lệnh!raise}

\beforeverb
\begin{verbatim}
def add_time(t1, t2):
    if not valid_time(t1) or not valid_time(t2):
        raise ValueError, 'invalid Time object in add_time'
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
\afterverb
%
hoặc có thể dùng lệnh {\tt assert}, vốn để kiểm tra một bất biến và
báo biệt lệ nếu có sự vi phạm:

\index{assert (lệnh)}
\index{lệnh!assert}

\beforeverb
\begin{verbatim}
def add_time(t1, t2):
    assert valid_time(t1) and valid_time(t2)
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{verbatim}
\afterverb
%
Lệnh {\tt assert} có ích vì chúng phân biệt rạch ròi giữa đoạn mã
giải quyết trường hợp bình thường và mã lệnh để kiểm tra lỗi.


\section{Thuật ngữ}

\begin{description}

\item[nguyên mẫu và sửa chữa:] Kế hoạch phát triển trong đó bao gồm
việc viết một bản nháp của chương trình, chạy thử, và sửa những lỗi
phát sinh.
\index{nguyên mẫu và sửa chữa}

\item[phát triển theo kế hoạch:] Kế hoạch phát triển trong đó bao gồm
nhận định sâu sắc về bài toán, đồng thời kế hoạch được xác lập kĩ hơn
so với các cách phát triển tăng dần và phát triển nguyên mẫu.
\index{phát triển theo kế hoạch}

\item[hàm thuần túy:] Hàm không thay đổi bất kì đối tượng nào được nhận
làm đối số. Hầu hết các hàm thuần túy đều cho kết quả.
\index{hàm thuần túy}

\item[hàm thay đổi:] Hàm có làm thay đổi (các) đối tượng được nhận làm
đối số. Hầu hết các hàm thay đổi đều không cho kết quả.
\index{hàm thay đổi}

\item[phong cách lập trình hàm:] Phong cách thiết kế chương trình trong đó
đa số các hàm đều là thuần túy.
\index{phong cách lập trình hàm}

\item[bất biến:] Điều kiện cần luôn được đảm bảo đúng trong quá trình
chạy chương trình.
\index{bất biến}

\end{description}


\section{Bài tập}

\begin{ex}
Hãy viết một hàm có tên \verb"mul_time" nhận vào một đối tượng Time
và một số, rồi trả về một đối tượng Time mới có chứa tích của Time
ban đầu với số đó.

Tiếp theo, dùng \verb"mul_time" để viết một hàm nhận vào đối tượng Time
biểu thị thời gian về đích trong một cuộc đua, và một số biểu thị
khoảng cách, rồi trả về một đối tượng Time biểu thị thời gian trung bình
để đi hết một dặm đường.

% \index{running pace}

\end{ex}

\begin{ex}

\index{Date (lớp)}
\index{lớp!Date}

Hãy viết một định nghĩa lớp cho đối tượng Date gồm các thuộc tính  {\tt
  day}, {\tt month} and {\tt year}.  Viết một hàm 
\verb"increment_date" nhận vào một đối tượng Date, {\tt date} và một
số nguyên, {\tt n}, rồi trả về một đối tượng Date mới biểu thị
ngày tháng xuất hiện vào {\tt n} ngày sau {\tt date}.  Gợi ý: Dùng khớp xương
bàn tay để nhớ số ngày trong tháng. Đố bạn dùng hàm này để tính
với năm nhuận? Xem \url{wikipedia.org/wiki/Leap_year}.

\end{ex}


\begin{ex}

\index{datetime (module)}
\index{module!datetime}

Module {\tt datetime} có các đối tượng {\tt date} và {\tt time}; chúng cũng
gần giống các đối tượng Date và Time trong chương này, nhưng có
tập hợp các phương thức và toán tử rất phong phú. Hãy tìm hiểu 
tài liệu ở \url{docs.python.org/lib/datetime-date.html}.

\begin{enumerate}

\item Hãy dùng module {\tt datetime} để viết một chương trình nhận vào
ngày hôm nay và in ra thứ của ngày trong tuần.

\index{sinh nhật}

\item Hãy viết một chương trình nhận vào ngày sinh của bạn rồi in ra tuổi 
bạn cùng số ngày, giờ, phút, giây cho đến sinh nhật tiếp theo.
\end{enumerate}

\end{ex}


\chapter{Lớp và phương thức}


\section{Những đặc điểm của lập trình hướng đối tượng}

\index{lập trình hướng đối tượng}

Python là một {\bf ngôn ngữ lập trình hướng đối tượng}, theo nghĩa là nó
có những đặc điểm hỗ trợ lập trình hướng đối tượng.

Thật không dễ định nghĩa lập trình hướng đối tượng là gì, nhưng ta đã
thấy một số đặc điểm của nó:

\begin{itemize}

\item Các chương trình được cấu thành từ các định nghĩa đối tượng và
định nghĩa hàm, và phần lớn việc tính toán đều được diễn đạt trên
những thao tác với đối tượng.

\item Mỗi định nghĩa đối tượng đều tương ứng với một đối tượng hoặc
khái niệm nào đó trong thực tại, và các hàm thao tác trên đối tượng đó
tương ứng với cách mà những đối tượng thực tại này tương tác với nhau.

\end{itemize}

Chẳng hạn, lớp {\tt Time} định nghĩa trong Chương~\ref{time}
tương ứng với cách mà con người ghi chép thời gian trong ngày, và
các hàm ta đã định nghĩa tương ứng với những thao tác mà con người
thường tính với thời gian. Tương tự, các lớp {\tt Point} và {\tt Rectangle} 
tương ứng với những khái niệm toán học là điểm và hình chữ nhật.

Cho đến giờ, ta vẫn chưa lợi dụng những đặc tính sẵn có của Python
để phục vụ cho lập trình hướng đối tượng. Những đặc tính này đều không
nhất thiết  phải có, chúng hầu hết chỉ là dạng cú pháp thay thế cho những
câu lệnh ta đã viết. Tuy nhiên trong nhiều trường hợp, dạng thay thế này
gọn hơn và chuyển tại ý tưởng về cấu trúc chương trình một cách
chính xác hơn.

Chẳng hạn, trong chương trình {\tt Time}, không có mối liên hệ rõ nét
nào giữa lời định nghĩa lớp và các định nghĩa hàm theo sau nó. Song khi
xem xét kĩ hơn, ta thấy được mỗi hàm đều nhận ít nhất là một đối tượng
{\tt Time} làm đối số.

\index{phương thức}
\index{hàm}

Nhận định trên là cơ sở cho việc hình thành các {\bf phương thức}; một
phương thức là một hàm được gắn liền với một lớp cụ thể. Ta đã gặp
những phương thức dành cho chuỗi, danh sách, từ điển, và bộ. Trong
chương này, ta sẽ định nghĩa các phương thức cho kiểu dữ liệu
do người dùng định nghĩa.

\index{cú pháp}
\index{ngữ nghĩa}

Các phương thức về mặt ngữ nghĩa thì cũng giống như hàm, nhưng về
cú pháp thì có hai điểm khác biệt:

\begin{itemize}

\item Các phương thức được định nghĩa trong lời định nghĩa lớp nhằm
biểu thị rõ mối quan hệ giữa lớp và phương thức đó.

\item Cú pháp để gọi một phương thức khác với cú pháp để gọi hàm.

\end{itemize}

Trong một vài mục tiếp theo, ta sẽ lấy các hàm từ hai chương trước
và chuyển đổi chúng thành các phương thức. Việc chuyển đổi này 
chỉ là máy móc; bạn có thể thực hiện được theo một số bước. 
Khi đã thạo việc chuyển đổi giữa các dạng, bạn có thể chọn được
dạng phù hợp nhất với công việc đang làm.


\section{Các đối tượng thực hiện việc in}
\label{print_time}

\index{đối tượng!in}

Ở Chương~\ref{time}, ta đã định nghĩa một lớp tên là
{\tt Time} và trong Bài tập~\ref{printtime}, bạn đã viết
một hàm có tên \verb"print_time":

\beforeverb
\begin{verbatim}
class Time(object):
    """represents the time of day.
       attributes: hour, minute, second"""

def print_time(time):
    print '%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)
\end{verbatim}
\afterverb
%
Để gọi hàm này, bạn cần phải truyền một đối tượng {\tt Time} như 
là đối số:

\beforeverb
\begin{verbatim}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second = 00
>>> print_time(start)
09:45:00
\end{verbatim}
\afterverb
%
Để biến \verb"print_time" thành một phương thức, toàn bộ những
gì ta phải làm chỉ là chuyển lời định nghĩa hàm vào trong định nghĩa lớp.
Chú ý rằng khoảng thụt đầu dòng được thay đổi.

\index{thụt đầu dòng}

\beforeverb
\begin{verbatim}
class Time(object):
    def print_time(time):
        print '%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)
\end{verbatim}
\afterverb
%
Bây giờ có hai cách gọi \verb"print_time".  Cách thứ nhất (ít thông dụng)
là dùng cú pháp của hàm:

\index{cú pháp hàm}
\index{kí hiệu dấu chấm}

\beforeverb
\begin{verbatim}
>>> Time.print_time(start)
09:45:00
\end{verbatim}
\afterverb
%
Trong cách dùng kí hiệu dấu chấm này, {\tt Time} là tên của lớp, còn
\verb"print_time" là tên của phương thức.  {\tt start} được truyền vào
làm tham biến.

Cách thứ hai (gọn gàng hơn) là dùng cú pháp của phương thức:

\index{cú pháp phương thức}

\beforeverb
\begin{verbatim}
>>> start.print_time()
09:45:00
\end{verbatim}
\afterverb
%
Trong cách dùng kí hiệu dấu chấm này,  \verb"print_time" (một lần nữa)
là tên của phương thức, còn {\tt start} là tên của đối tượng
mà phương phức đó được gọi, còn có tên là {\bf chủ thể}.  Vai trò của 
chủ thể trong một lời gọi phương thức cũng như vai trò của chủ ngữ 
trong một câu văn.

\index{chủ thể}

Bên trong phương thức, chủ thể được gán là tham biến thứ nhất. VÌ vậy
trong trường hợp này,  {\tt start} được gán cho {\tt time}.

\index{self (tên tham biến)}
\index{tham biến!self}

Theo quy ước, tham biến thứ nhất của một phương thức được gọi là
{\tt self}, vì vậy cách viết \verb"print_time" như sau là thông dụng hơn:

\beforeverb
\begin{verbatim}
class Time(object):
    def print_time(self):
        print '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
\end{verbatim}
\afterverb
%
Lí do có quy ước này là từ phép ẩn dụ:

\index{ẩn dụ, gọi phương thức}

\begin{itemize}

\item Cú pháp của một lời gọi hàm, \verb"print_time(start)",
  hàm ý rằng hàm đó là chủ thể. Nó kiểu như lời yêu cầu 
  ``Này \verb"print_time"!  Đây là một đối tượng mà cậu cần in ra.''

\item Trong lập trình hướng đối tượng, các đối tượng là chủ thể.
  Một lời gọi phương thức như \verb"start.print_time()" giống câu nói
  ``Này {\tt start}!  Hãy tự in bản thân cậu đi.''

\end{itemize}

Sự thay đổi về góc nhìn này có vẻ khiêm tốn, nhưng thật không dễ thấy
lợi ích mà nó mang lại. Ở những ví dụ ta đã thảo luận, có thể là chưa.
Nhưng đôi khi việc chuyển trách nhiệm từ hàm sang đối tượng
có thể giúp ta dễ dàng viết được các hàm linh động hơn, cũng dễ bảo trì
và sử dụng lại mã lệnh hơn.

\begin{ex}
\label{convert}
Hãy viết lại \verb"time_to_int"
(ở Mục~\ref{prototype}) dưới dạng phương thức. Có thể sẽ không phù hợp
khi viết lại \verb"int_to_time" như vậy; thật không rõ ràng là bạn muốn
gọi phương thức đó từ đối tượng nào!
\end{ex}


\section{Một ví dụ khác}

\index{tăng}

Sau đây là một dạng của {\tt increment} (trong Mục~\ref{increment})
được viết lại như một phương thức:

\beforeverb
\begin{verbatim}
# inside class Time:

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
\afterverb
%
Dạng này có giả sử rằng \verb"time_to_int" được viết như một
phương thức, như trong Bài tập~\ref{convert}.  Đồng thời, cần thấy
rằng đó là một hàm thuần túy, không phải một hàm sửa đổi.

Sau đây là cách gọi {\tt increment}:

\beforeverb
\begin{verbatim}
>>> start.print_time()
09:45:00
>>> end = start.increment(1337)
>>> end.print_time()
10:07:17
\end{verbatim}
\afterverb
%
Chủ thể, {\tt start}, được gán cho tham biến thứ nhất,
{\tt self}.  Đối số, {\tt 1337}, được gán cho
tham biến thứ hai, {\tt seconds}.

Cơ chế làm việc này có thể gây nhầm lẫn, đặc biệt khi bạn mắc
phải lỗi. Chẳng hạn, nếu gọi {\tt increment} với hai đối số, bạn sẽ
nhận được:

\index{biệt lệ!TypeError}
\index{TypeError}

\beforeverb
\begin{verbatim}
>>> end = start.increment(1337, 460)
TypeError: increment() takes exactly 2 arguments (3 given)
\end{verbatim}
\afterverb
%
Thông báo lỗi thoạt đầu nhìn rất khó hiểu, vì chỉ có hai đối số
trong ngoặc kép. Nhưng chủ thể cũng được coi là một đối số,
nên tổng cộng có ba đối số.

\section{Một ví dụ phức tạp hơn}

\verb"is_after" (trong Bài tập~\ref{is_after}) khó hơn một chút vì
nó nhận vào hai đối tượng Time làm tham biến. Ở trường hợp này
theo quy ước thì tham biến thứ nhất được gọi là {\tt self} và tham biến
thứ hai là {\tt other}:

\index{other (tên tham biến)}
\index{tham biến!other}

\beforeverb
\begin{verbatim}
# inside class Time:

    def is_after(self, other):
        return self.time_to_int() > other.time_to_int()
\end{verbatim}
\afterverb
%
Để dùng phương thức này, bạn phải gọi nó từ một đối tượng và
truyền đối tượng kia như một đối số:

\beforeverb
\begin{verbatim}
>>> end.is_after(start)
True
\end{verbatim}
\afterverb
%
Một điều hay ở dạng cú pháp này là cách đọc nó giống với
tiếng Anh: ``end xảy ra sau start?''


\section{Phương thức init}

\index{init (phương thức)}
\index{phương thức!init}

Phương thức init (gọi tắt của ``initialization'') là một phương thức
đặc biệt được gọi khi một đối tượng được khởi tạo (cá thể hóa).
Tên đầy đủ của nó là \verb"__init__" (hai dấu gạch thấp,
tiếp theo là {\tt init}, rồi hai dấu gạch thấp khác). Một phương thức
init cho lớp {\tt Time} có thể trông như sau:

\beforeverb
\begin{verbatim}
# inside class Time:

    def __init__(self, hour=0, minute=0, second=0):
        self.hour = hour
        self.minute = minute
        self.second = second
\end{verbatim}
\afterverb
%
Thường thì các tham biến của  \verb"__init__" cũng có
tên giống như các thuộc tính. Câu lệnh

\beforeverb
\begin{verbatim}
        self.hour = hour
\end{verbatim}
\afterverb
%
lưu lại giá trị của tham biến {\tt hour} như một thuộc tính
của {\tt self}.

\index{tùy chọn, tham biến}
\index{tham biến!tùy chọn}
\index{giá trị mặc định}
\index{thay thế mặc định}

Các tham biến đều là tùy chọn, vì vậy nếu gọi {\tt Time} mà
không có đối số nào, bạn sẽ thu được các giá trị mặc định.

\beforeverb
\begin{verbatim}
>>> time = Time()
>>> time.print_time()
00:00:00
\end{verbatim}
\afterverb
%
Nếu bạn cấp cho một đối số, nó sẽ thay cho giá trị mặc định
của {\tt hour}:

\beforeverb
\begin{verbatim}
>>> time = Time (9)
>>> time.print_time()
09:00:00
\end{verbatim}
\afterverb
%
Nếu bạn cấp hai đối số, chúng sẽ thay cho các giá trị mặc định
của {\tt hour} và {\tt minute}.

\beforeverb
\begin{verbatim}
>>> time = Time(9, 45)
>>> time.print_time()
09:45:00
\end{verbatim}
\afterverb
%
Và nếu bạn cấp ba đối số, chúng sẽ thay thế tất cả ba giá trị
mặc định.


\begin{ex}
\index{Point (lớp)}
\index{lớp!Point}

Hãy viết một phương thức init cho lớp {\tt Point} nhận vào các
tham biến tùy chọn {\tt x} và {\tt y} rồi gán chúng cho các 
thuộc tính tương ứng.
\end{ex}


\section{Phương thức {\tt \_\_str\_\_}}

\index{str (phương thức)@\_\_str\_\_ (phương thức)}
\index{phương thức!\_\_str\_\_}

\verb"__str__" là một phương thức đặc biệt, cũng như \verb"__init__".
Nó được dùng để trả lại một chuỗi biểu diễn cho một đối tượng.

\index{chuỗi biểu diễn}

Chẳng hạn, sau đây là một phương thức {\tt str} cho đối tượng Time:

\beforeverb
\begin{verbatim}
# ben trong lop Time:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
\end{verbatim}
\afterverb
%
Khi bạn {\tt print} một đối tượng, Python sẽ gọi phương thức {\tt str}:

\index{print (lệnh)}
\index{lệnh!print}

\beforeverb
\begin{verbatim}
>>> time = Time(9, 45)
>>> print time
09:45:00
\end{verbatim}
\afterverb
%
Khi viết một lớp mới, tôi luôn bắt đầu bằng việc viết 
\verb"__init__", để làm cho việc cá thể hóa đối tượng dễ dàng hơn, và
\verb"__str__", để cho việc gỡ lỗi được dễ dàng hơn.


\begin{ex}
Hãy viết một phương thức {\tt str} cho lớp {\tt Point}. Sau đó tạo một
đối tượng Point và in nó ra.
\end{ex}


\section{Toán tử đa năng}
\label{operator overloading}

Bằng việc định nghĩa các phương thức đặc biệt, bạn có thể chỉ định
tính năng của các toán tử hoạt động trên kiểu dữ liệu do người dùng
định nghĩa. Chẳng hạn, nếu bạn định nghĩa một phương thức có tên
\verb"__add__" cho lớp {\tt Time}, bạn có thể dùng toán tử
{\tt +} với các đối tượng Time.

Sau đây là một ví dụ về cách định nghĩa nêu trên:

\index{add method}
\index{method!add}

\beforeverb
\begin{verbatim}
# ben trong lop Time:

    def __add__(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
\afterverb
%
Và sau đây là cách sử dụng nó:

\beforeverb
\begin{verbatim}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print start + duration
11:20:00
\end{verbatim}
\afterverb
%
Khi áp dụng toán tử {\tt +} với các đối tượng Time, Python sẽ gọi
\verb"__add__".  Khi bạn in ra kết quả, Python gọi 
\verb"__str__".  Như vậy là có khá nhiều điều đang diễn ra nơi ``hậu trường''!

\index{đa năng, toán tử}

Việc thay đổi tính năng của một toán tử sao cho nó có thể làm việc
được với các kiểu do người dùng định nghĩa được gọi là làm cho 
{\bf toán tử} trở nên {\bf đa năng}.  Mỗi toán tử
trong Python có một phương thức đặc biệt tương ứng, như 
\verb"__add__".  Để biết thêm thông tin, hãy xem 
\url{docs.python.org/ref/specialnames.html}.

\begin{ex}
Hãy viết một phương thức {\tt add} cho lớp Point.  
\end{ex}


\section{Cắt cử dựa theo kiểu dữ liệu}

Ở mục trước, ta đã cộng hai đối tượng Time, nhưng bạn có lẽ
cũng muốn cộng một số nguyên với đối tượng Time. Sau đây
là một dạng của  \verb"__add__"
để kiểm tra kiểu của {\tt other} và gọi 
\verb"add_time" hoặc {\tt increment}:

\beforeverb
\begin{verbatim}
# ben trong lop Time:

    def __add__(self, other):
        if isinstance(other, Time):
            return self.add_time(other)
        else:
            return self.increment(other)

    def add_time(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{verbatim}
\afterverb
%
Hàm có sẵn {\tt isinstance} nhận một giá trị và một 
đối tượng lớp rồi trả về  {\tt True} nếu giá trị là một cá thể thuộc
lớp đó.

\index{isinstance (hàm)}
\index{hàm!isinstance}

Nếu {\tt other} là một đối tượng Time thì \verb"__add__" sẽ gọi
\verb"add_time".  Trái lại, nó sẽ giả sử rằng tham biến là một số 
và gọi {\tt increment}.  Thao tác này được 
gọi là {\bf cắt cử dựa theo kiểu dữ liệu} vì nó cắt cử 
các phương thức khác nhau để thực hiện phép tính, tuỳ theo
kiểu của đối số.

\index{cắt cử dựa theo kiểu dữ liệu}

Sau đây là các ví dụ trong đó dùng toán tử {\tt +} với các kiểu
dữ liệu khác nhau:

\beforeverb
\begin{verbatim}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print start + duration
11:20:00
>>> print start + 1337
10:07:17
\end{verbatim}
\afterverb
%
Thật không may là kiểu thực hiện phép cộng này không có tính giao hoán.
Nếu số nguyên đứng bên trái toán tử, bạn sẽ nhận được

\index{giao hoán}

\beforeverb
\begin{verbatim}
>>> print 1337 + start
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
\end{verbatim}
\afterverb
%
Vấn đề là ở chỗ, thay vì yêu cầu đối tượng  Time cộng với một số nguyên,
Python lại yêu cầu số nguyên cộng với đối tượng Time, và nó không biết 
thực hiện điều đó. Nhưng có một giải pháp khéo léo: 
phương thức đặc biệt \verb"__radd__", viết tắt của ``right-side add.''
Phương thức này được gọi mỗi khi đối tượng Time xuất hiện bên phải
của toán tử {\tt +}. Sau đây là lời định nghĩa:

\index{radd (phương thức)}
\index{phương thức!radd}

\beforeverb
\begin{verbatim}
# ben trong lop Time:

    def __radd__(self, other):
        return self.__add__(other)
\end{verbatim}
\afterverb
%
Và sau đây là cách dùng nó:

\beforeverb
\begin{verbatim}
>>> print 1337 + start
10:07:17
\end{verbatim}
\afterverb
%

\begin{ex}
Hãy viết một phương thức {\tt add} cho các Point sao cho nó có thể làm
việc với từng đối tượng Point hoặc một bộ:  

\begin{itemize}

\item Nếu toán hạng thứ hai là một Point, phương thức cần trả lại một
Point mới với toạ độ $x$ bằng tổng các toạ độ $x$ của các toán hạng,
và tương tự như vậy với các toạ độ $y$.

\item Nếu toán hạng thứ hai là một bộ, phương thức cần cộng 
phần tử thứ nhất của bộ vào toạ độ $x$ và phần tử
thứ hai vào toạ độ $y$, rồi trả lại kết quả là một Point mới.

\end{itemize}

\end{ex}

\section{Đa hình}

Việc cắt cử theo kiểu dữ liệu có thể hữu dụng khi cần thiết, nhưng (thật may là) 
nó không phải luôn cần đến. Thường bạn có thể tránh được cách đó bằng cách
viết các hàm làm việc được với các đối số có kiểu khác nhau.

\index{cắt cử theo kiểu dữ liệu}

Nhiều hàm ta viết cho chuỗi thực ra cũng phát huy tác dụng
với bất kì kiểu dãy nào.
Chẳng hạn, trong Mục~\ref{histogram}
ta đã dùng {\tt histogram} để đếm số lần mỗi chữ cái
xuất hiện trong một từ.

\beforeverb
\begin{verbatim}
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
\end{verbatim}
\afterverb
%
Hàm này cũng dùng được với các danh sách, bộ, và thậm chí cả từ điển,
miễn là các phần tử của {\tt s} phải băm được, để chúng có thể dùng như 
các khoá trong {\tt d}.

\beforeverb
\begin{verbatim}
>>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']
>>> histogram(t)
{'bacon': 1, 'egg': 1, 'spam': 4}
\end{verbatim}
\afterverb
%
Các hàm có khả năng làm việc được với vài kiểu dữ liệu được gọi là có tính {\bf đa hình}.
Tính đa hình giúp cho việc tái sử dụng mã lệnh. Chẳng hạn, hàm có sẵn 
{\tt sum}, để cộng các phần tử trong một dãy, luôn có tác dụng chỉ cần
các phần tử trong dãy cộng được với nhau.

\index{đa hình}

Vì các đối tượng Time có phương thức {\tt add}, chúng sẽ dùng được
với {\tt sum}:

\beforeverb
\begin{verbatim}
>>> t1 = Time(7, 43)
>>> t2 = Time(7, 41)
>>> t3 = Time(7, 37)
>>> total = sum([t1, t2, t3])
>>> print total
23:01:00
\end{verbatim}
\afterverb
%
Nói chung, nếu tất cả các thao tác bên trong một hàm hoạt động
được với một kiểu dữ liệu cho trước, thì hàm đó cũng hoạt động
được với kiểu nói trên.

Tính đa hình sẽ tốt nhất là lúc không định trước, khi 
bạn phát hiện thấy một hàm mình đã viết có thể được
áp dụng cho một kiểu dữ liệu mà bạn chưa từng có ý định xử lý đến.


\section{Gỡ lỗi}
\index{gỡ lỗi}

Sẽ hoàn toàn hợp lệ khi thêm các thuộc tính vào đối tượng bất kì
chỗ nào trong quá trình thực hiện chương trình; nhưng nếu bạn gắt gao
về lý thuyết kiểu dữ liệu thì để cho các đối tượng cùng kiểu có những
thuộc tính khác nhau sẽ là cách làm không đáng tin cậy. Tốt hơn
là khởi tạo tất cả thuộc tính của đối tượng trong phương thức init.

\index{init (phương thức)}
\index{thuộc tính!khởi tạo}

Nếu không chắc rằng một đối tượng có chứa một thuộc tính cụ thể
hay không, bạn có thể dùng hàm có sẵn {\tt hasattr} (xem Mục~\ref{hasattr}).

\index{hasattr (hàm)}
\index{hàm!hasattr}
\index{dict (thuộc tính)@\_\_dict\_\_ (thuộc tính)}
\index{thuộc tính!\_\_dict\_\_}

Một cách khác để truy cập các thuộc tính của đối tượng là thông qua
thuộc tính đặc biệt \verb"__dict__", vốn là từ điển khớp các tên
thuộc tính (kiểu chuỗi) với giá trị:

\beforeverb
\begin{verbatim}
>>> p = Point(3, 4)
>>> print p.__dict__
{'y': 4, 'x': 3}
\end{verbatim}
\afterverb
%
Bạn có thể ghi nhớ hàm sau để tiện cho việc gỡ lỗi:

\beforeverb
\begin{verbatim}
def print_attributes(obj):
    for attr in obj.__dict__:
        print attr, getattr(obj, attr)
\end{verbatim}
\afterverb
%
\verb"print_attributes" duyệt các mục trong từ điển của đối tượng
và in ra mỗi tên thuộc tính kèm theo giá trị tương ứng.

\index{duyệt!từ điển}
\index{từ điển!duyệt}

Hàm có sẵn {\tt getattr} nhận vào một đối tượng cùng tên của một
thuộc tính (kiểu chuỗi) rồi trả lại giá trị của thuộc tính đó.

\index{getattr (hàm)}
\index{hàm!getattr}


\section{Thuật ngữ}

\begin{description}

\item[ngôn ngữ hướng đối tượng:] Ngôn ngữ cung cấp những đặc điểm,
  như lớp do người dùng định nghĩa và cú pháp dành cho phương thức,
  nhằm giúp cho việc lập trình hướng đối tượng.
\index{ngôn ngữ hướng đối tượng}

\item[lập trình hướng đối tượng:] Phong cách lập trình trong đó
dữ liệu và các thao tác trên dữ liệu được tổ chức thành các lớp và
phương thức.
\index{lập trình hướng đối tượng}

\item[phương thức:] Hàm được định nghĩa bên trong lời định nghĩa lớp
và được gọi với các cá thể của lớp đó.
\index{phương thức}

\item[chủ thể:] Đối tượng mà phương thức được kích hoạt trên đó.
\index{chủ thể}

\item[toán tử đa năng:] Một toán tử trở thành đa năng như 
{\tt +} khi nó thay đổi tính năng để làm việc với kiểu dữ liệu do người dùng
định nghĩa.
\index{đa năng}
\index{toán tử!đa năng}

\item[cắt cử dựa theo kiểu:] Dạng mẫu lập trình trong đó kiểm tra kiểu của
toán hạng và gọi các hàm khác nhau tùy theo kiểu dữ liệu của toán hạng đó.
\index{cắt cử dựa theo kiểu}

\item[đa hình:] Tính chất của một hàm có thể làm việc với vài kiểu dữ liệu khác nhau.

\index{đa hình}

\end{description}

\section{Bài tập}

\begin{ex}

\index{giá trị mặc định!tránh sự thay đổi}
\index{đối tượng thay đổi, mặc định}
\index{lỗi!hóc búa nhất}

Bài tập này cũng là câu chuyện cảnh tỉnh về một lỗi phổ biến nhưng
khó phát hiện của Python.

\begin{enumerate}

\index{Kangaroo, lớp}
\index{lớp!Kangaroo}

\item Hãy viết định nghĩa cho một lớp có tên  {\tt Kangaroo} gồm những
phương thức sau:

\begin{enumerate}

\item Một phương thức \verb"__init__" để khởi tạo một thuộc tính có tên là 
\verb"pouch_contents" (``túi'' của Kangaroo)  bằng một danh sách rỗng.

\item Một phương thức có tên \verb"put_in_pouch" nhận một đối tượng có kiểu
tùy ý và bổ sung nó vào  \verb"pouch_contents".

\item Một phương thức \verb"__str__" để trả về chuỗi biểu diễn
cho đối tượng Kangaroo và nội dung của \verb"pouch_contents".

\end{enumerate}
%
Hãy kiểm tra mã lệnh vừa viết bằng cách 
tạo ra hai đối tượng {\tt Kangaroo}, gán chúng cho các biến
có tên {\tt kanga} và {\tt roo}, sau đó thêm {\tt roo} vào 
trong ``túi'' của {\tt kanga}.

\item Hãy tải về file \url{thinkpython.com/code/BadKangaroo.py}.  Nó chứa 
lời giải của bài tập nhưng có một lỗi rất nghiêm trọng. Hãy tìm và sửa lỗi này.

Nếu bị vướng mắc, bạn có thể tải về 
\url{thinkpython.com/code/GoodKangaroo.py}, trong đó giải thích bài toán
và chỉ ra một cách giải.

\index{tham biến bội}
\index{nhúng, đối tượng}
\index{đối tượng!nhúng}

\end{enumerate}


\end{ex}




\begin{ex}

\index{Visual (module)}
\index{module!Visual}
\index{vpython (module)}
\index{module!vpython}

Visual là một module Python cho phép thao tác với đồ thị ba chiều. Nó 
thường không đi kèm theo bản cài đặt Python, vì vậy bạn có thể sẽ
phải cài đặt nó từ kho phần mềm của hệ điều hành, hoặc nếu 
không có, thì ở  \url{vpython.org}.

Ví dụ sau đây tạo ra một không gian 3 chiều có bề rộng, chiều dài,
chiều cao đều bằng 256 đơn vị, sau đặt điểm gốc (``center'') tại
vị trí  $(128, 128, 128)$. Tiếp theo một hình cầu màu xanh lam được vẽ ra.

\beforeverb
\begin{verbatim}
from visual import *

scene.range = (256, 256, 256)
scene.center = (128, 128, 128)

color = (0.1, 0.1, 0.9)          # mau gan giong xanh lam
sphere(pos=scene.center, radius=128, color=color)
\end{verbatim}
\afterverb

{\tt color} là một bộ màu RGB; trong đó các thành tố màu Đỏ-Lục-Lam
có mức từ 0.0 đến 1.0 (xem
\url{wikipedia.org/wiki/RGB_color_model}).

Nếu chạy đoạn mã này, bạn sẽ thấy một cửa sổ có nền màu đen và
một hình cầu màu xanh lam. Nếu lăn nút chuột giữa lên hoặc xuống,
bạn sẽ phóng to hoặc thu nhỏ hình. Bạn còn có thể xoay hình bằng
cách di nút chuột phải, nhưng chỉ với một quả cầu trên hình thì
khó quan sát được sự khác biệt nào. 

Vòng lặp tiếp theo tạo ra một khối lập phương gồm các quả cầu:

\beforeverb
\begin{verbatim}
t = range(0, 256, 51)
for x in t:
    for y in t:
        for z in t:
            pos = x, y, z
            sphere(pos=pos, radius=10, color=color)
\end{verbatim}
\afterverb

\begin{enumerate}

\item Hãy đưa đoạn mã này vào trong một file lệnh và đảm bảo rằng
nó chạy đúng.

\item Hãy sửa lại chương trình sao cho mỗi hình cầu trong khối lập
phương có màu tương ứng với vị trí của nó trong không gian màu RGB.
Chú ý rằng các tọa độ nằm trong khoảng  0--255, còn
bộ RGB thì lại nằm trong khoảng 0.0--1.0.

\index{màu, danh sách}
\index{màu, hiện có}

\item Tải về \url{thinkpython.com/code/color_list.py}
và dùng hàm \verb"read_colors" để phát sinh một danh sách
các màu hiện có trên hệ thống máy của bạn, tên của chúng và
các giá trị RGB. Với mỗi màu có tên trên, hãy vẽ một quả cầu ở
vị trí tương ứng với giá trị RGB của nó.



\end{enumerate}

Bạn có thể tham khảo lời giải của tôi tại \url{thinkpython.com/code/color_space.py}.

\end{ex}


\chapter{Thừa kế}

Trong chương này ta sẽ xây dựng các lớp để biểu diễn cho quân bài tây,
bộ bài, và phần bài của người chơi trong trò {\em poker}. Nếu không biết
 chơi {\em poker}, bạn có thể xem ở \url{wikipedia.org/wiki/Poker}, dù điều này
không cần thiết vì tôi sẽ nói những điều cần để làm bài tập.

\index{card, playing}
\index{poker}

Thông tin về bộ bài tây thông dụng có ở \url{wikipedia.org/wiki/Playing_cards}.


\section{Đối tượng lá bài (Card)}

Có 52 lá bài trong một bộ, mỗi lá bài thuộc về một trong bốn chất
và một trong 13 bậc. Các chất gồm Pích, Cơ, Rô, và Nhép (theo thứ
tự giảm dần trong trò {\em bridge}). Các bậc gồm có 
A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, và K. Tùy theo trò chơi mà bạn
quân A có thể cao hơn K hoặc thấp hơn 2.

\index{bậc}
\index{chất}

Nếu bạn muốn định nghĩa một đối tượng mới để biểu diễn cho lá bài,
rõ ràng các thuộc tính phải là: {\tt rank} (bậc) và
{\tt suit} (chất). Còn việc chọn kiểu dữ liệu cho các thuộc tính lại không
hiển nhiên. Một khả năng là dùng các chuỗi gồm những từ như 
\verb"'Spade'" (Pích) cho chất và \verb"'Queen'" cho bậc. Một vấn đề đặt ra
với cách làm này là sẽ không dễ so sánh xem lá bài nào có bậc hoặc chất
cao hơn.

\index{đánh số}
\index{mã hóa}
\index{khớp}
\index{thể hiện}

Một cách khác là dùng số nguyên để {\bf đánh số} cho các bậc và chất.
Ở đây, ``đánh số'' có nghĩa là lập một phép khớp giữa số và chất, cũng như
giữa số và bậc. Kiểu đánh số này khác với mã hóa (với hàm ý bí mật).

Chẳng hạn, bảng dưới đây cho thấy các chất và mã số tương ứng:

\beforefig
\begin{tabular}{l c l}
Spades & $\mapsto$ & 3 \\
Hearts & $\mapsto$ & 2 \\
Diamonds & $\mapsto$ & 1 \\
Clubs & $\mapsto$ & 0
\end{tabular}
\afterfig

Mã số này giúp so sánh các lá bài dễ hơn; vì chất cao hơn được khớp với
số lớn hơn, và ta có thể so sánh chất bằng cách so các mã số của chúng.

Việc khớp đối với bậc thì khá dễ thấy; mỗi bậc số thì khớp với chính số
nguyên tương ứng, còn với các bậc chữ:

\beforefig
\begin{tabular}{l c l}
Jack & $\mapsto$ & 11 \\
Queen & $\mapsto$ & 12 \\
King & $\mapsto$ & 13 \\
\end{tabular}
\afterfig

Ở đây tôi dùng kí hiệu $\mapsto$ để làm rõ rằng phép khớp này không phải là
một phần của chương trình Python. Đó là một phần của khâu thiết kế chương trình,
nhưng không xuất hiện một cách cụ thể trên mã lệnh.

\index{Card (lớp)}
\index{lớp!Card}

Lời định nghĩa lớp cho {\tt Card} sẽ như sau:

\beforeverb
\begin{verbatim}
class Card(object):
    """bieu thi cho mot la bai tay."""

    def __init__(self, suit=0, rank=2):
        self.suit = suit
        self.rank = rank
\end{verbatim}
\afterverb
%
Như thường lệ, phương thức init nhận vào một 
tham biến tùy chọn cho mỗi thuộc tính. Lá bài mặc định
là 2 Nhép.

\index{init (phương thức)}
\index{phương thức!init}

Để tạo ra một Card, bạn gọi {\tt Card} cùng với
chất và bậc của lá bài mà bạn muốn.

\beforeverb
\begin{verbatim}
queen_of_diamonds = Card(1, 12)
\end{verbatim}
\afterverb
%


\section{Các thuộc tính của lớp}

\index{lớp, thuộc tính}
\index{thuộc tính!lớp}

Để in ra đối tượng Card theo cách mà mọi người dễ đọc, ta cần khớp từ 
mã số đến các bậc và chất tương ứng. Một cách làm tự nhiên là dùng
danh sách các chuỗi. Ta gán những danh sách này cho các  {\bf thuộc tính
lớp}:

\beforeverb
\begin{verbatim}
# ben trong lop Card:

    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', 
              '8', '9', '10', 'Jack', 'Queen', 'King']

    def __str__(self):
        return '%s of %s' % (Card.rank_names[self.rank],
                             Card.suit_names[self.suit])
\end{verbatim}
\afterverb
%
Các biến như \verb"suit_names" và \verb"rank_names", vốn được
định nghĩa bên trong một lớp nhưng bên ngoài bất kì một phương thức nào,
được gọi là thuộc tính lớp và chúng gắn liền với đối tượng lớp 
{\tt Card}.

\index{cá thể, thuộc tính}
\index{thuộc tính!cá thể}

Chúng khác với những biến như {\tt suit} và {\tt
  rank}, vốn được gọi là {\bf thuộc tính cá thể} vì gắn với một
cá thể nhất định.

\index{kí hiệu dấu chấm}

Cả hai loại thuộc tính đều được truy cập bằng kí hiệu đấu chấm. 
Chẳng hạn, trong \verb"__str__", {\tt self} là một đối tượng Card,
còn {\tt self.rank} là bậc của nó.  Tương tự, {\tt Card}
là một đối tượng lớp, còn \verb"Card.rank_names" là một danh sách
các chuỗi gắn với lớp này.

Mỗi lá bài đều có {\tt suit} và {\tt rank} riêng của nó, nhưng 
chung quy chỉ có \verb"suit_names" và một \verb"rank_names".

Tóm lại, biểu thức
\verb"Card.rank_names[self.rank]" có nghĩa là ``dùng thuộc tính {\tt rank}
của đối tượng {\tt self} làm chỉ số cho danh sách \verb"rank_names"
thuộc lớp {\tt Card}, và chọn lấy chuỗi tương ứng.''

Phần tử đầu tiên của \verb"rank_names" là {\tt None} vì không có lá bài
nào với bậc bằng 0. Với việc thêm {\tt None} vào để giữ chỗ,
ta thu được một cách khớp rất hay trong đó chỉ số 2 khớp trực tiếp với
chuỗi \verb"'2'", và cứ như vậy. Để tránh cách sửa chữa này, ta cũng
có thể dùng một từ điển thay vì danh sách.

Với những phương thức được xét đến giờ, ta có thể tạo và in ra những lá bài:

\beforeverb
\begin{verbatim}
>>> card1 = Card(2, 11)
>>> print card1
Jack of Hearts
\end{verbatim}
\afterverb
%
Sau đây là một sơ đồ cho thấy đối tượng lớp {\tt Card} và một cá thể
Card:

\index{state diagram}
\index{diagram!state}
\index{object diagram}
\index{diagram!object}

\beforefig
\centerline{\includegraphics{figs/card1.eps}}
\afterfig

{\tt Card} là một đối tượng lớp, vì vậy nó có kiểu là {\tt type}.  {\tt
card1} có kiểu là {\tt Card}.  (Để tiết kiệm chỗ, tôi đã không vẽ
nội dung của \verb"suit_names" và \verb"rank_names").


\section{So sánh các lá bài}
\label{comparecard}

\index{toán tử!quan hệ}
\index{quan hệ, toán tử}

Với những kiểu dữ liệu có sẵn, các toán tử quan hệ 
({\tt <}, {\tt >}, {\tt ==}, v.v.)
giúp so sánh và xác định xem một giá trị lớn hơn, nhỏ hơn hoặc bằng 
giá trị kia. Với các kiểu dữ liệu do người dùng định nghĩa, ta có thể thay thế
tính năng mặc định của những toán tử có sẵn bằng cách cung cấp một
phương thức có tên 
\verb"__cmp__".  

\verb"__cmp__" nhận vào hai tham số, {\tt self} và {\tt other},
rồi trả về một số dương nếu như đối tượng thứ nhất lớn hơn, một
số âm nếu như đối tượng thứ hai lớn hơn, và 0 nếu chúng bằng nhau.

\index{thay thế mặc định}
\index{toán tử đa năng}

Thứ tự đúng đắn của các quân bài thật không rõ ràng. Chẳng hạn, lá bài nào
tốt hơn, 3 Nhép hay 2 Rô? Một lá thì có bậc cao hơn, nhưng lá kia lại có chất
cao hơn. Để so sánh các quân bài, bạn cần phải quyết định xem giữa bậc
và chất, cái nào quan trọng hơn.

Câu trả lời có thể tùy vào trò chơi đang xét, nhưng để giữ cho mọi thứ
đơn giản, ta sẽ tạm quy ước là chất quan trọng hơn, như vậy tất cả các
quân bài chất Pích sẽ cao hơn các quân chất Rô, và cứ như vậy.

\index{cmp (phương thức)@\_\_cmp\_\_ (phương thức)}
\index{phương thức!\_\_cmp\_\_}

Khi đã xác định như vậy, ta có thể viết \verb"__cmp__":

\beforeverb
\begin{verbatim}
# ben trong lop Card:

    def __cmp__(self, other):
        # kiem tra chat
        if self.suit > other.suit: return 1
        if self.suit < other.suit: return -1

        # chat giong nhau... kiem tra bac
        if self.rank > other.rank: return 1
        if self.rank < other.rank: return -1

        # bac giong nhau... hai quan bang nhau
        return 0    
\end{verbatim}
\afterverb
%
Bạn có thể viết gọn đoạn mã trên bằng cách so sánh các bộ:

\index{bộ!so sánh}
\index{so sánh!bộ}

\beforeverb
\begin{verbatim}
# ben trong lop Card:

    def __cmp__(self, other):
        t1 = self.suit, self.rank
        t2 = other.suit, other.rank
        return cmp(t1, t2)
\end{verbatim}
\afterverb
%
Hàm có sẵn {\tt cmp} cũng có giao diện giống như
của phương thức \verb"__cmp__": nó nhận hai giá trị và trả về
một số dương nếu giá trị thứ nhất lớn hơn, một số âm
nếu giá trị thứ hai lớn hơn, và 0 nếu chúng bằng nhau.

\index{cmp (hàm)}
\index{hàm!cmp}


\begin{ex}
Hãy viết một phương thức \verb"__cmp__" cho đối tượng Time.  Gợi ý: bạn
có thể dùng so sánh bộ, nhưng cũng nên cân nhắc dùng phép trừ
số nguyên.

%    def __cmp__(self, other):
%        return time_to_int(self) - time_to_int(other)

%If {\tt self} is later than {\tt other}, the result is
%a positive number.  If {\tt other} is later, the result
%is negative.  And if {\tt self} and {\tt other} are equal
%(but not necessarily identical)
%the result is zero.

\end{ex}


\section{Bộ bài}
\index{danh sách!các đối tượng}
\index{bộ bài}

Bây giờ, khi đã có các đối tượng Card, ở bước tiếp theo ta sẽ định nghĩa Deck (bộ bài). 
Vì một bộ bài được tạo thành từ những quân bài, nên cách làm tự nhiên sẽ là 
cho mỗi Deck chứa một danh sách các quân bài làm thuộc tính.

\index{init (phương thức)}
\index{phương thức!init}

Sau đây là đoạn mã định nghĩa {\tt Deck}. Phương thức init
tạo ra thuộc tính {\tt cards} và phát sinh một bộ bài tiêu chuẩn
gồm 52 lá:

\index{phức hợp}
\index{vòng lặp!lồng ghép}

\index{Deck (lớp)}
\index{lớp!Deck}

\beforeverb
\begin{verbatim}
class Deck(object):

    def __init__(self):
        self.cards = []
        for suit in range(4):
            for rank in range(1, 14):
                card = Card(suit, rank)
                self.cards.append(card)
\end{verbatim}
\afterverb
%
Cách dễ nhất để tạo ra bộ bài là dùng một vòng lặp lồng ghép. Vòng lặp
ngoài đếm số chất từ 0 đến 3. Vòng lặp trong đếm số bậc từ 1 đến 13.
Mỗi lần lặp sẽ tạo ra một Card mới theo chất và bậc hiện có, rồi bổ sung
nó vào  {\tt self.cards}.

\index{append (phương thức)}
\index{phương thức!append}


\section{In bộ bài}
\label{printdeck}

\index{str (phương thức)@\_\_str\_\_ (phương thức)}
\index{phương thức!\_\_str\_\_}

Sau đây là phương thức \verb"__str__" của {\tt Deck}:

\beforeverb
\begin{verbatim}
#ben trong lop Deck:

    def __str__(self):
        res = []
        for card in self.cards:
            res.append(str(card))
        return '\n'.join(res)
\end{verbatim}
\afterverb
%
Phương thức này cho thấy một cách hiệu quả để tích lũy thành
một chuỗi lớn: tạo ra một danh sách các chuỗi rồi dùng {\tt join}.
Hàm có sẵn {\tt str} gọi phương thức \verb"__str__"
với mỗi lá bài và trả về chuỗi biểu diễn của nó.

\index{biến lũy tích!chuỗi}
\index{chuỗi!biến lũy tích}
\index{join (phương thức)}
\index{phương thức!join}
\index{xuống dòng}

Vì ta gọi {\tt join} từ một kí tự xuống dòng, nên các quân bài
được phân tách bởi theo dòng. Kết quả sẽ trông như sau:

\beforeverb
\begin{verbatim}
>>> deck = Deck()
>>> print deck
Ace of Clubs
2 of Clubs
3 of Clubs
...
10 of Spades
Jack of Spades
Queen of Spades
King of Spades
\end{verbatim}
\afterverb
%
Mặc dù kết quả hiện ra trên 52 dòng, nhưng thật ra
nó là một chuỗi dài trong đó có các kí tự xuống dòng.


\section{Thêm, bớt, trộn bài và sắp xếp}

Để chia bài, ta cần có một phương thức nhằm
lấy một lá từ bộ bài và trả lại nó. 
Phương thức {\tt pop} của danh sách cho ta một cách làm tiện lợi:

\index{pop (phương thức)}
\index{phương thức!pop}

\beforeverb
\begin{verbatim}
#ben trong lop Deck:

    def pop_card(self):
        return self.cards.pop()
\end{verbatim}
\afterverb
%
Vì {\tt pop} lấy ra lá bài {\em cuối cùng} trong danh sách, nên ta
chia từ phía dưới của bộ bài. Ngoài đời, người ta sẽ nhướn lông mày
khi thấy cách chia bài như vậy\footnote{Xem \url{wikipedia.org/wiki/Bottom_dealing}},
nhưng để phục vụ mục đích lập trình thì không sao.

\index{append (phương thức)}
\index{phương thức!append}

Để thêm một lá bài, ta có thể dùng phương thức {\tt append} của danh sách:

\beforeverb
\begin{verbatim}
#ben trong lop Deck:

    def add_card(self, card):
        self.cards.append(card)
\end{verbatim}
\afterverb
%
Một phương thức như thế này, vốn dùng một hàm khác mà không
tính toán gì đáng kể, còn được gọi là {\bf véc-ni}.  Từ này là hình ảnh 
ẩn dụ xuất phát từ nghề mộc, ở đó người ta thường dùng keo dán một lớp
gỗ tốt lên trên bề mặt đồ gỗ rẻ tiền hơn.

\index{véc-ni}

Trong trường hợp này ta định nghĩa một phương thức ``mỏng'' để biểu thị
một toán tử thao tác với danh sách, vốn rất phù hợp với đối tượng bộ bài.

Lấy một ví dụ khác, ta có thể viết một phương thức của Deck tên là {\tt shuffle} (trộn)
dùng hàm {\tt shuffle} từ module {\tt random}:

\index{random (module)}
\index{module!random}
\index{shuffle (hàm)}
\index{hàm!shuffle}

\beforeverb
\begin{verbatim}
# ben trong lop Deck:
            
    def shuffle(self):
        random.shuffle(self.cards)
\end{verbatim}
\afterverb
%
Đừng quên việc nhập {\tt random}.

\begin{ex}
\index{sort (phương thức)}
\index{phương thức!sort}

Hãy viết một phương thức của Deck có tên là {\tt sort} trong đó dùng
phương thức {\tt sort} của danh sách để sắp xếp các lá bài trong {\tt Deck}.  {\tt sort} sử dụng
phương thức \verb"__cmp__" mà ta đã định nghĩa để xác định thứ tụ sắp xếp.
\end{ex}



\section{Thừa kế}

\index{thừa kế}
\index{lập trình hướng đối tượng}

Đặc điểm của ngôn ngữ mà thường gắn liền nhất với lập trình 
hướng đối tượng là {\bf thừa kế}.  Thừa kế là khả năng 
định nghĩa một lớp mới dưới dạng một phiên bản được sửa đổi
từ một lớp sẵn có.

\index{lớp!cha mẹ}
\index{lớp!con}

Sở dĩ gọi là ``thừa kế'' vì lớp mới sẽ hưởng lại toàn bộ các phương thức
từ lớp sẵn có. Bằng việc mở rộng phép ẩn dụ này, lớp sẵn có được gọi
là {\bf lớp cha mẹ} và lớp mới được gọi là 
{\bf lớp con}.

Lấy ví dụ, giả sử ta muốn có một lớp biểu diễn phần bài thuộc về
một người chơi.  Phần bài này cũng giống bộ bài ở chỗ: chúng đều là
tập hợp từ những lá bài, và chúng đều cần các thao tác như
thêm và bớt các lá bài.

Một phần bài khác với một bộ bài ở chỗ có những thao tác chúng ta 
muốn áp dụng cho phần bài nhưng lại không dùng cho bộ bài. Chẳng hạn,
trong trò chơi {\em poker} ta có thể so sánh hai phần bài xem ai thắng.
Trong trò chơi {\em bridge} ta muốn tính điểm cho một phần bài để 
đặt cược.

Mối liên hệ này giữa các lớp---giống mà khác---dẫn đến sự hình thành
tính thừa kế.

Việc định nghĩa của một lớp con cũng giống như các định nghĩa lớp khác,
nhưng tên của lớp cha mẹ phải được đặt trong cặp ngoặc đơn:

\index{cặp ngoặc đơn!tên lớp cha mẹ}
\index{lớp!cha mẹ}
\index{Hand (lớp)}
\index{lớp!Hand}

\beforeverb
\begin{verbatim}
class Hand(Deck):
    """bieu thi phan bai cua moi nguoi choi"""
\end{verbatim}
\afterverb
%
Định nghĩa này chỉ ra rằng {\tt Hand} kế thừa từ {\tt Deck};
nghĩa là ta có thể dùng những phương thức như \verb"pop_card" và \verb"add_card"
cho cả Hand lẫn Deck.

{\tt Hand} cũng thừa kế \verb"__init__" từ {\tt Deck}, nhưng
đây sẽ không phải là điều ta muốn: thay vì phát sinh toàn bộ 
52 quân bài cho một phần, phương thức init của Hands cần khởi tạo
{\tt cards} là một danh sách rỗng.

\index{thay thế mặc định}
\index{init (phương thức)}
\index{phương thức!init}

Nếu ta viết một phương thức init bên trong lớp {\tt Hand}, nó sẽ thay thế
cho init của lớp {\tt Deck}:

\beforeverb
\begin{verbatim}
# ben trong lop Hand:

    def __init__(self, label=''):
        self.cards = []
        self.label = label
\end{verbatim}
\afterverb
%
Như vậy khi bạn tạo một Hand, Python sẽ gọi phương thức init này:

\beforeverb
\begin{verbatim}
>>> hand = Hand('new hand')
>>> print hand.cards
[]
>>> print hand.label
new hand
\end{verbatim}
\afterverb
%
Nhưng các phương thức khác vẫn được thừa kế từ {\tt Deck}, vì vậy ta có thể dùng
\verb"pop_card" và \verb"add_card" để chia bài:

\beforeverb
\begin{verbatim}
>>> deck = Deck()
>>> card = deck.pop_card()
>>> hand.add_card(card)
>>> print hand
King of Spades
\end{verbatim}
\afterverb
%
Một cách tự nhiên, bước tiếp theo sẽ là gói đoạn mã trên vào một
phương thức có tên  \verb"move_cards":

\index{gói}

\beforeverb
\begin{verbatim}
#ben trong lop Deck:

    def move_cards(self, hand, num):
        for i in range(num):
            hand.add_card(self.pop_card())
\end{verbatim}
\afterverb
%
\verb"move_cards" nhận hai đối số, một đối tượng Hand và số lá bài
cần chia. Nó làm thay đổi cả  {\tt self} và {\tt hand}, rồi
trả về {\tt None}.

Trong một số trò chơi, các lá bài được chuyển từ phần này sang
phần kia, hoặc từ một phần trở về bộ bài. Bạn có thể dùng \verb"move_cards"
để thực hiện bất cứ thao tác nào kể trên:  {\tt self} có thể là Deck
hoặc Hand, và {\tt hand}, dù tên nó là vậy, cũng có thể là {\tt Deck}.

\begin{ex}
Hãy viết một phương thức của Deck có tên là \verb"deal_hands" nhận vào hai
tham biến là số phần bài và số lá bài trong mỗi phần, rồi tạo ra
các đối tượng Hand mới, chia đủ số lá bài cho mỗi phần, và trả về
một danh sách các đối tượng Hand.
\end{ex}

Thừa kế là một tính năng có ích. Có những chương trình sẽ trở nên
tự lặp lại nếu không dùng thừa kế, và sẽ đẹp hơn khi dùng nó. 
Thừa kế có ghể giúp sử dụng lại mã lệnh, vì bạn có thể tự sửa 
tính chất có ở lớp cha mẹ mà không cần phải sửa lớp đó. 
Trong một số trường hợp, cấu trúc thừa kế phản ánh đúng cấu trúc
tự nhiên của vấn đề, từ đó làm cho chương trình trở nên dễ hiểu hơn.

Mặt khác, thừa kế có thể làm cho chương trình khó đọc hơn. Khi một
phương thức được kích hoạt, đôi khi không dễ tìm được đoạn định nghĩa
của nó. Phần mã lệnh có liên quan đến có thể nằm rải rác trong một số
module. Hơn nữa, nhiều việc làm bằng cách thừa kế cũng có thể làm
tốt bằng, chưa kể là tốt hơn, khi không thừa kế.


\section{Sơ đồ lớp}

Cho đến giờ ta đã thấy sơ đồ ngăn xếp để chỉ ra trạng thái của 
một chương trình, và sơ đồ đối tượng để chỉ ra các thuộc tính của
một đối tượng cùng những giá trị của chúng. Các sơ đồ kể trên đều
biểu diễn một khoảnh khắc trong quá trình thực thi chương trình. Vì
vậy khi chương trình chạy cũng thay đổi đi.

Những sơ đồ đó cũng rất chi tiết; và ở khía cạnh nào đó, quá chi tiết.
Một sơ đồ lớp, trái lại, biểu diễn một cách trừu tượng cấu trúc
chương trình. Thay vì cho thấy các đối tượng riêng biệt, nó cho thấy
các lớp và mối liên hệ giữa các lớp đó.

Có một số mối liên hệ giữa các lớp như sau:

\begin{itemize}

\item Đối tượng trong một lớp có thể chứa những tham chiếu đến những
đối tượng thuộc lớp khác. Chẳng hạn, mỗi Rectangle chứa một tham chiếu
đến một Point, và mỗi Deck chứa nhiều tham chiếu đến nhiều Card.
Dạng liên hệ này được gọi là {\bf HAS-A} (``có một''), như câu nói, ``một Rectangle
có một Point.''

\item Một lớp có thể thừa kế từ lớp khác. Mối liên hệ này
được gọi là {\bf IS-A} (``là một''), như cách nói, ``một Hand là một kiểu Deck.''

\item Một lớp có thể phụ thuộc vào lớp khác theo nghĩa sự thay đổi của lớp này
sẽ yêu cầu những thay đổi ở lớp kia.
\end{itemize}

\index{IS-A, liên hệ}
\index{HAS-A, liên hệ}
\index{lớp, sơ đồ}
\index{sơ đồ!lớp}
\index{UML}

Một {\bf sơ đồ lớp} là một cách biểu diễn bằng hình vẽ cho những mối liên hệ
như vậy.\footnote{Sơ đồ mà tôi dùng ở đây cũng giống như UML
  (xem \url{wikipedia.org/wiki/Unified_Modeling_Language}), với một số
  lược bớt.} Chẳng hạn, sơ đồ này cho thấy mối liên hệ
  giữa {\tt Card}, {\tt Deck} và {\tt Hand}.

\beforefig
\centerline{\includegraphics{figs/class1.eps}}
\afterfig

Mũi tên với đầu hình tam giác trắng biểu thị một liên hệ IS-A; 
ở đây nó cho thấy Hand thừa kế từ Deck.

Mũi tên bình thường biểu thị một liên hệ HAS-A; 
ở đây Deck có những tham chiếu đến các đối tượng Cards.

\index{phép nhân (trong sơ đồ lớp)}

Dấu sao ({\tt *}) gần đầu mũi tên biểu thị một
{\bf phép nhân}; nó cho biết có bao nhiêu Card trong mỗi Deck. 
Một phép nhân có thể đi kèm với con số, như {\tt 52}, một khoảng số,
như {\tt 5..7} hoặc chỉ một dấu sao đơn lẻ, ngụ ý rằng Deck có thể
có số lá bài bất kì.

Một sơ đồ chi tiết hơn có thể chỉ ra rằng Deck thực chất
bao gồm một {\em danh sách} các Card, nhưng các kiểu dữ liệu có sẵn
như danh sách và từ điển thường không được ghi trong sơ đồ lớp.

\begin{ex}
Hãy đọc {\tt TurtleWorld.py}, {\tt World.py} và {\tt Gui.py}
rồi vẽ một sơ đồ lớp để chỉ ra những mối liên hệ giữa 
các lớp được định nghĩa trong đó.
\end{ex}


\section{Gỡ lỗi}
\index{gỡ lỗi}

Thừa kế có thể làm cho việc gỡ lỗi khó khăn vì khi bạn gọi
một phương thức từ một đối tượng, bạn có thể không biết rằng 
phương thức nào sẽ được kích hoạt.

\index{đa hình}

Giả sử rằng bạn đang viết một hàm để thao tác với các đối tượng Hand.
Bạn muốn nó dùng được với mọi loại Hand, như 
PokerHand, BridgeHand, (các phần bài trong những loại trò chơi
khác nhau), v.v. Nếu gọi một phương thức như
{\tt shuffle}, bạn có thể sẽ được phương thức định nghĩa trong {\tt Deck},
nhưng chỉ cần một lớp con có phương thức thay thế thì bạn
sẽ gọi vào phương thức đó.
\index{luồng thực hiện chương trình}

Bất cứ lúc nào bạn không chắc chắn về luồng thực hiện chương trình,
cách làm đơn giản nhất là thêm lệnh print vào đầu những
phương thức có liên quan. Nếu {\tt Deck.shuffle} in ra một
thông báo chẳng hạn như {\tt Running Deck.shuffle}, thì khi
chương trình chạy nó sẽ theo dõi luôn luồng thực hiện.

Một cách làm khác là dùng hàm sau đây, vốn nhận vào một 
đối tượng và một tên phương thức (dạng chuỗi) và trả về một lớp
trong đó có định nghĩa của phương thức:

\beforeverb
\begin{verbatim}
def find_defining_class(obj, meth_name):
    for ty in type(obj).mro():
        if meth_name in ty.__dict__:
            return ty
\end{verbatim}
\afterverb
%
Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
>>> hand = Hand()
>>> print find_defining_class(hand, 'shuffle')
<class 'Card.Deck'>
\end{verbatim}
\afterverb
%
Như vậy phương thức {\tt shuffle} của Hand này chính là phương thức trong {\tt Deck}.

\index{mro (phương thức)}
\index{phương thức!mro}
\index{thứ tự phân định phương thức}

\verb"find_defining_class" dùng phương thức {\tt mro} để thu được danh sách
các đối tượng lớp (kiểu) sẽ được dùng để tìm kiếm phương thức.  ``MRO''
là viết tắt của ``method resolution order'' (thứ tự phân định phương thức).

\index{thay thế}
\index{giao diện}
\index{điều kiện trước}
\index{điều kiện sau}

Sau đây là một gợi ý về việc thiết kế chương trình: mỗi khi lập
một phương thức thay thế, giao diện của phương thức mới cần phải giống
như của phương thức cũ. Nó cần phải nhận cùng các tham biến, trả về
cùng kiểu, và tuân theo cùng loại điều kiện trước và điều kiện sau.
Nếu tuân theo quy tắc này, bạn sẽ thấy hàm nào được lập ra cho cá thể
của một lớp cha mẹ, như Deck, cũng sẽ hoạt động được với các cá thể
của những lớp con như Hand hoặc PokerHand.

Nếu vi phạm quy tắc này, chương trình của bạn (rất tiếc) sẽ 
sụp đổ như một đống bài.


\section{Thuật ngữ}

\begin{description}

\item[đánh số:] Biểu thị một tập hợp các giá trị bằng một
tập hợp giá trị khác bằng cách thiết lập quy tắc khớp giữa chúng.
\index{đánh số}

\item[thuộc tính lớp:] Thuộc tính gắn với một đối tượng lớp.
Thuộc tính lớp được định nghĩa bên trong
lời định nghĩa hàm nhưng ở ngoài các phương thức.
\index{lớp, thuộc tính}
\index{thuộc tính!lớp}

\item[thuộc tính cá thể:] Thuộc tính gắn với một cá thể của
một lớp.
\index{cá thể, thuộc tính}
\index{thuộc tính!cá thể}

\item[véc-ni:] Phương thức hoặc hàm cung cấp giao diện khác 
tới một hàm khác mà không thực hiện tính toán gì đáng kể.
\index{véc-ni}

\item[thừa kế:] Khả năng định nghĩa một lớp mới là 
một dạng sửa đổi từ một lớp đã định nghĩa từ trước.
\index{thừa kế}

\item[lớp cha mẹ:] Lớp mà từ đó các lớp con kế thừa.
\index{lớp cha mẹ}

\item[lớp con:] Lớp mới được tạo ra bằng cách kế thừa từ
một lớp sẵn có.
\index{lớp con}

\item[liên hệ IS-A:] Mối liên hệ giữa một lớp con và
lớp cha mẹ của nó.
\index{liên hệ IS-A}

\item[liên hệ HAS-A:] Mối liên hệ giữa hai lớp trong đó
các cá thể của một lớp chứa tham chiếu đến các cá thể của lớp kia.
\index{liên hệ HAS-A}

\item[sơ đồ lớp:] Sơ đồ thể hiện các lớp trong một chương trình
và mối liên hệ giữa chúng.
\index{lớp, sơ dồ}
\index{sơ đồ!lớp}

\item[phép nhân:] Cách viết trong sơ đồ lớp dành cho mối liên hệ HAS-A,
để chỉ ra có bao nhiêu tham chiếu đến các cá thể của lớp khác.
\index{phép nhân (ở sơ đồ lớp)}

\end{description}


\section{Bài tập}

\begin{ex}
\index{poker}


Sau đây là các khả năng xảy ra đối với một phần bài poker, xếp theo
thứ tự tăng dần về giá trị (và giảm dần về xác suất):

\begin{description}

\item[đôi:] hai lá bài có cùng bậc
\vspace{-0.05in}

\item[hai đôi:] hai đôi cùng bậc với nhau
\vspace{-0.05in}

\item[ba:] ba lá bài có cùng bậc
\vspace{-0.05in}

\item[straight:] năm lá bài với bậc tăng dần (quân Át có thể tính là
cao hoặc thấp, vì vậy cả {\tt A-2-3-4-5} lẫn {\tt
10-Jack-Queen-King-Ace} đều hợp lệ, nhưng {\tt Queen-King-Ace-2-3} thì không.)
\vspace{-0.05in}

\item[flush:] năm lá bài có cùng chất
\vspace{-0.05in}

\item[full house:] ba lá bài có cùng bậc, hai lá còn lại có bậc khác
\vspace{-0.05in}

\item[tứ quý:] bốn lá bài có cùng bậc
\vspace{-0.05in}

\item[dây:] năm lá bafi có bậc tăng dần (đã giải thích ở trên) và có
cùng chất
\vspace{-0.05in}

\end{description}
%
Mục đích của bài tập này là ước tính 
xác suất rút được những lá bài như vậy trong một phần bài.

\begin{enumerate}

\item Tải các file sau từ \url{thinkpython.com/code}:

\begin{description}

\item[{\tt Card.py}]: Một bản đầy đủ của các lớp {\tt Card},
{\tt Deck} và {\tt Hand} trong chương này.

\item[{\tt PokerHand.py}]: Một bản chưa đầy đủ gồm một lớp
biểu diễn phần bài poker, mà mã lệnh để chạy thử nó.

\end{description}
%
\item Khi bạn chạy {\tt PokerHand.py}, nó sẽ chia 7 phần bài, mỗi phần
có 7 lá, và kiểm tra xem liệu có phần nào chứa một flush hay không. 
Hãy đọc mã lệnh cẩn thận trước khi tiếp tục.

\item Bổ sung vào {\tt PokerHand.py} các phương thức có tên \verb"has_pair",
\verb"has_twopair", v.v. để trả về True hoặc False tùy theo 
phần bài có đạt yêu cầu (có 1 đôi, 2 đôi) hay không. Mã lệnh bạn viết
cần chạy được với những ``phần bài'' chứa số lá bài bất kì
(mặc dù số lượng thông dụng nhất là 5 và 7).

\item Viết một phương thức có tên {\tt classify} để phân loại bằng cách tìm ra
trường hợp có giá trị cao nhất cho một phần bài và đặt
thuộc tính {\tt label} tương ứng cho nó. Chẳng hạn, một phần bài 7 lá
có thể chứa cả một flush và một đôi; nó cần được xếp loại ``flush''.

\item Khi bạn đã chắc rằng các phương thức phân loại viết ra đều đúng,
bước tiếp theo là ước tính xác suất của các trường hợp khác nhau.
Hãy viết một hàm trong {\tt PokerHand.py} để trộn bộ bài, chia thành
các phần, phân loại từng phần, và đêm số lần mà mỗi loại khác nhau
đã xuất hiện.

\item In ra một bảng phân loại cùng các xác suất tương ứng.
Chạy chương trình với số lần chia bài tăng dần đến khi kết quả hội tụ
về một giá trị có độ chính xác chấp nhận được. So sánh kết quả của bạn
với những giá trị liệt kê tại \url{wikipedia.org/wiki/Hand_rankings}.

\end{enumerate}
\end{ex}


\begin{ex}

\index{Swampy}
\index{TurtleWorld}

Bài tập này sử dụng TurtleWorld từ Chương~\ref{turtlechap}.
Bạn sẽ viết mã để điều khiển Turtle (con rùa) chơi {\em tag} (một trò chơi
đuổi bắt). Nếu bạn chưa biết luật chơi, hãy xem 
\url{wikipedia.org/wiki/Tag_(game)}.

\begin{enumerate}

\item Tải về file \url{thinkpython.com/code/Wobbler.py} và chạy nó. Bạn sẽ
thấy một TurtleWorld với ba Turtle. Nếu bạn ấn nút
{\sf Run}, các Turtle sẽ chạy một cách ngẫu nhiên.

\item Hãy đọc mã lệnh và nắm vững cách hoạt động của nó.
Lớp {\tt Wobbler} thừa kế từ {\tt Turtle}, có nghĩa là các
phương thức của {\tt Turtle} gồm có {\tt lt}, {\tt rt}, {\tt fd}
và {\tt bk} đều có tác dụng với Wobblers.

Phương thức {\tt step} được gọi bởi TurtleWorld.  Nó gọi 
{\tt steer}, để rẽ Turtle theo hướng mong muốn,
{\tt wobble}, để rẽ theo hướng ngẫu nhiên tùy theo  mức độ mất trật tự của Turtle
và {\tt move}, để đi tiến vài pixel về phía trước,
tùy theo tốc độ của Turtle.

\index{Tagger}

\item Hãy tạo một file {\tt Tagger.py}. Nhập tất cả mọi thứ từ 
  {\tt Wobbler}, rồi định nghĩa một lớp tên là {\tt Tagger} để thừa kế
  từ {\tt Wobbler}.  Gọi \verb"make_world" có chuyển đối tượng lớp {\tt
    Tagger} làm đối số.

\item Thêm phương thức có tên {\tt steer} và {\tt Tagger} để thay thế cho phương thức ở
  {\tt Wobbler}.  Hãy bắt đầu bằng việc viết một bản chương trình để luôn luôn 
  hướng Turtle về gốc tọa độ. Gợi ý: dùng hàm toán học 
  {\tt atan2} và các thuộc tính của Turtle bao gồm {\tt x}, {\tt y} và
  {\tt heading}.

\item Sửa lại {\tt steer} sao cho các Turtle hoạt động trong phạm vi cho phép.
  Để gỡ lỗi, có thể bạn sẽ cần dùng đến nút {\sf Step},
  có tác dụng gọi {\tt step} mỗi lần cho từng Turtle.

\item Sửa lại {\tt steer} sao cho các Turtle hướng về phía con gần nó nhất.
  Gợi ý: Turtle có một thuộc tính, {\tt world}, vốn là một tham chiếu đến
  TurtleWorld mà chúng sống trong đó; còn TurtleWorld lại có một
  thuộc tính, {\tt animals}, là danh sách tất cả những Turtles có trong
  vùng.

\item Sửa lại {\tt steer} để các Turtle chơi {\em tag}. Bạn có thể thêm các phương thức
  vào {\tt Tagger} đồng thời cũng có thể thay thế đè lên {\tt steer} và
  \verb"__init__", nhưng bạn không được sửa đổi hoặc thay đè vào {\tt step}, {\tt
    wobble} hay {\tt move}.  Ngoài ra, {\tt steer} được phép thay đổi 
  phương hướng của Turtle nhưng không được thay đổi vị trí.

Hãy chỉnh sửa luật chơi và phương thức {\tt steer} để trò chơi hấp dẫn hơn;
chẳng hạn, có thể làm cho những Turtle bắt được
Turtle sau quá trình đuổi lâu dài.

\end{enumerate}

Bạn có thể tham khảo lời giải của tôi tại \url{thinkpython.com/code/Tagger.py}.
\end{ex}



\chapter{Nghiên cứu cụ thể: Tkinter}

\section{GUI}

Phần lớn chương trình ta đã gặp đều hoạt động trên nền chữ, nhưng
cũng có nhiều chương trình dùng {\bf giao diện đồ họa người dùng}, cũng
được gọi là {\bf GUI}.

\index{GUI}
\index{giao diện đồ họa người dùng}
\index{Tkinter}

Python cung cấp một số cách để viết chương trình GUI:
dùng wxPython, Tkinter, và Qt. Mỗi cách đều có ưu và nhược điểm,
đó cũng là lí do mà Python chưa có quy chuẩn cụ thể về mặt này.

Công cụ mà tôi trình bày trong chương này là Tkinter vì tôi nghĩ rằng
đó là thứ dễ nhất mà chúng ta bắt đầu học. Đa số các khái niệm
trong chương này cũng dùng được với các module GUI khác.

Có một số cuốn sách và trang web về Tkinter. Một trong những
nguồn trực tuyến tốt nhất là {\em An Introduction to Tkinter}
viết bởi Fredrik Lundh.

\index{Gui (module)}
\index{module!Gui}
\index{Swampy}

Tôi đã viết một module có tên {\tt Gui.py} đi kèm theo
Swampy.  Nó cung cáp một giao diện được đơn giản hóa với các hàm
và lớp trong Tkinter.  Những ví dụ trong chương này đều
dựa theo module đó.

Sau đây là một ví dụ đơn giản nhằm tạo ra và hiển thị một Gui:

Để tạo ra một GUI, bạn cần nhập vào {\tt Gui} rồi cá thể hóa
một đối tượng Gui:

\beforeverb
\begin{verbatim}
from Gui import *

g = Gui()
g.title('Gui')
g.mainloop()
\end{verbatim}
\afterverb
%
Khi bạn chạy đoạn mã này, một cửa sổ sẽ xuất hiện với một hình vuông 
màu xám và tiêu đề chữ {\sf Gui}.  {\tt mainloop} chạy {\bf vòng lặp
  sự kiện}, để đợi người dùng thực hiện một thao tác và phản hồi một cách
tương ứng. Đó là một vòng lặp vô hạn; nó tiếp tục chạy đến khi người dùng đóng
cửa sổ, hoặc ấn Control-C, hoặc thực hiện thao tác khiến cho chương trình
kết thúc.

\index{sự kiện, vòng lặp}
\index{vòng lặp!sự kiện}
\index{vô hạn, vòng lặp}
\index{vòng lặp!vô hạn}

Đối tượng Gui này chẳng có gì đáng kể vì nó không chứa một
{\bf widget} nào.  Widget là thành phần tạo nên 
GUI; chúng bao gồm:

\index{widget}

\begin{description}

\item[Nút (Button):] Một widget, có chứa chữ hoặc hình, để thực hiện một việc
khi được nhấn.

\item[Nền (Canvas):] Một vùng trên đó có thể hiển thị đường nét, hình chữ nhật,
hình tròn và các hình khác.

\item[Ô chữ (Entry):] Một vùng mà người dùng có thể gõ chữ vào đó.

\item[Thanh trượt (Slider):] Một widget có khả năng điều chỉnh phần hiển thị
của một widget khác.

\item[Khung (Frame):] Một widget để chứa, thường luôn hiển thị, và đựng các
widget khác ở trong.

\end{description}

Hình vuông màu xám mà bạn nhìn thấy khi tạo ra Gui là
một Frame.  Khi bạn tạo ra một widget mới, nó sẽ được thêm vào Frame này.



\section{Nút và những điểm gọi lại}

\index{Button (widget)}
\index{widget!Button}

Phương thức {\tt bu} sau đây tạo ra một widget kiểu Button (nút):

\beforeverb
\begin{verbatim}
button = g.bu(text='Press me.')
\end{verbatim}
\afterverb
%
Giá trị trả về từ {\tt bu} là một đối tượng Button.  Hình nút 
hiện ra trong Frame là hình biểu diễn của đối tượng này;
bạn có thể điều khiển nút bằng cách gọi các phương thức của nó.

\index{tuỳ chọn}

{\tt bu} nhận đến 32 tham biến có ảnh hưởng đến hình dáng
và tính năng của nút. Các tham biến này được gọi là những
{\bf tuỳ chọn}. Thay vì cấp giá trị  cho cả 32 tuỳ chọn này,
bạn có thể dùng đối số từ khoá, như \verb"text='Press me.'",
để chỉ định những tuỳ chọn nào bạn cần và số còn lại thì dùng
các giá trị mặc định.

\index{từ khoá, đối số}
\index{đối số!từ khoá}

Khi bạn thêm một widget vào trong Frame, nó sẽ bị ``co hẹp;''
nghĩa là, Frame sẽ co lại cho bằng kích thước của Button.  Nếu bạn
thêm nhiều widget nữa, Frame sẽ nở ra để có đủ chỗ.

\index{Label (widget)}
\index{widget!Label}

Phương thức {\tt la} sau đây sẽ tạo ra một widget kiểu Label:

\beforeverb
\begin{verbatim}
label = g.la(text='Press the button.')
\end{verbatim}
\afterverb
%
Tkinter mặc nhiên chồng chất các  widget theo chiều đứng và 
căn chúng vào giữa. Ta sẽ xét cách thay thế đè lên biểu hiện đó.

Nếu ấn nút, bạn sẽ thấy không ăn thua. Đó là vì bạn chưa
``tiếp điện'' cho nó; nghĩa là bạn chưa ra lệnh cho nó làm gì!

Tuỳ chọn để điều khiển động thái của nút là {\tt command}.
Giá trị của {\tt command} là một hàm vốn sẽ được thực hiện khi nút 
được nhấn. Chẳng hạn, sau đây là một hàm để tạo mới một Label:

\beforeverb
\begin{verbatim}
def make_label():
    g.la(text='Thank you.')
\end{verbatim}
\afterverb
%
Bây giờ khi bạn tạo ra nút với hàm này đưa vào làm command của nó:

\beforeverb
\begin{verbatim}
button2 = g.bu(text='No, press me!', command=make_label)
\end{verbatim}
\afterverb
%
Khi bạn ấn nút này, nó sẽ thực hiện \verb"make_label"
và một dòng chữ mới sẽ xuất hiện.

\index{điểm gọi lại}

Giá trị của tuỳ chọn {\tt command} là một
đối tượng hàm, và cũng được gọi là một {\bf điểm gọi lại} vì sau khi 
bạn gọi {\tt bu} để tạo ra nút, luồng thực hiện sẽ
``gọi lại'' khi người dùng nhấn nút.

\index{lập trình hướng sự kiện}

Kiểu luồng thực hiện này là đặc trưng cho {\bf lập trình hướng sự kiện}.
Các hành động của người dùng, như ấn nút và gõ phím, được gọi là {\bf
sự kiện}. Trong lập trình hướng sự kiện, luồng thực hiện được
quyết định bởi người dùng thay vì người lập trình.

Thử thách đối với lập trình hướng sự kiện là việc thiết lập một tập hợp
các widget và điểm gọi lại sao cho chúng hoạt động đúng (hoặc ít nhất
phải phát sinh những thông báo lỗi hợp lý) cho bất kì chuỗi hành động
nào từ phía người dùng.

\begin{ex}

Hãy viết một chương trình để tạo ra GUI chỉ có một nút.  Khi nút được nhấn,
một nút thứ hai sẽ được tạo ra. Khi nút thứ hai này được nhấn, cần tạo ra
một dòng chữ viết, ``Nice job!''.

Điều gì sẽ xảy ra khi bạn ấn các nút nhiều lần?
Bạn có thể tham khảo lời giải của tôi tại \url{thinkpython.com/code/button_demo.py}

\end{ex}


\section{Các widget kiểu Canvas}

\index{Canvas (widget)}
\index{widget!Canvas}

Một trong những widget năng động nhất là Canvas, có tác dụng tạo ra
một vùng để vẽ các đường thẳng, hình tròn và những hình khác. Nếu
đã làm Bài tập~\ref{canvas}, bạn đã quen với kiểu widget nền này.

Phương thức {\tt ca} sau đây sẽ tạo ra Canvas mới:

\beforeverb
\begin{verbatim}
canvas = g.ca(width=500, height=500)
\end{verbatim}
\afterverb
%
{\tt width} và {\tt height} là các kích thước của nền tính theo
pixel.

\index{config (phương thức)}
\index{phương thức!config}

Sau khi tạo ra một widget, bạn vẫn có thể thay đổi các giá trị
của tuỳ chọn bằng phương thức {\tt config}. Chẳng hạn, 
tuỳ chọn {\tt bg} thay đổi màu nền:

\beforeverb
\begin{verbatim}
canvas.config(bg='white')
\end{verbatim}
\afterverb
%
Giá trị của {\tt bg} là một chuỗi chứa tên của một màu.
Tập hợp những tên màu hợp lệ lại khác nhau với từng phiên bản
Python dành cho các loại máy, nhưng tất cả phiên bản đều có
ít nhất là các màu sau:

\beforeverb
\begin{verbatim}
white   black
red     green    blue   
cyan    yellow   magenta
\end{verbatim}
\afterverb
%
Các hình trên một Canvas được gọi là {\bf item}.  Chẳng hạn,
phương thức của Canvas có tên {\tt circle} vẽ một hình tròn:

\index{Canvas, item}
\index{item!Canvas}

\beforeverb
\begin{verbatim}
item = canvas.circle([0,0], 100, fill='red')
\end{verbatim}
\afterverb
%
Đối số thứ nhất là cặp toạ độ của tâm hình tròn; đối số thứ hai
là bán kính.

\index{Canvas, toạ độ}
\index{toạ độ!Canvas}

{\tt Gui.py} có một hệ toạ độ Đề-các tiêu chuẩn với
điểm gốc tại tâm của Canvas và trục $y$ 
hướng lên. Nó khác với một số hệ thống đồ thị khác trong đó
điểm gốc lại ở góc bên trái phía trên và trục $y$ hướng xuống.

Tuỳ chọn {\tt fill} chỉ định rằng hình tròn cần được tô màu đỏ.

Giá trị trả về từ {\tt circle} là một đối tượng Item nhằm cung cấp
những phương thức để sửa đổi các item trên nền.  Chẳng hạn,
bạn có thể dùng {\tt config} để thay đổi bất kì tuỳ chọn nào
của hình tròn:

\beforeverb
\begin{verbatim}
item.config(fill='yellow', outline='orange', width=10)
\end{verbatim}
\afterverb
%
{\tt width} là độ dày của viền tính theo pixel;
{\tt outline} là màu của viền.

\begin{ex}
\label{circle}
Hãy viết một chương trình để tạo ra một Canvas và một Button.  
Khi người dùng ấn Button, cần phải vẽ ra một hình tròn trên nền.
\end{ex}


\section{Dãy các toạ độ}

\index{toạ độ, dãy}
\index{dãy!toạ độ}

Phương thức {\tt rectangle} nhận vào một dãy hai toạ độ để
định vị hai góc đối diện của hình chữ nhật.  Ví dụ này vẽ một
hình chữ nhật màu xanh lá cây với góc trái phía dưới ở gốc tạo độ
và góc phải phía trên ở $(200, 100)$:

\beforeverb
\begin{verbatim}
canvas.rectangle([[0, 0], [200, 100]], 
                 fill='blue', outline='orange', width=10)
\end{verbatim}
\afterverb
%
Cách làm chỉ định các góc nói trên cũng được gọi là chỉ định 
{\bf hình bao} vì hai điểm góc đó giới hạn hình chữ nhật.

\index{hình bao}

{\tt oval} nhận vào một hình bao và vẽ một hình trái xoan
bên trong hình chữ nhật bao đó:

\beforeverb
\begin{verbatim}
canvas.oval([[0, 0], [200, 100]], outline='orange', width=10)
\end{verbatim}
\afterverb
%
{\tt line} nhận vào một dãy các toạ độ và vẽ đoạn thẳng nối
các điểm đó. Ví dụ sau vẽ hai cạnh bên của một hình tam giác:

\beforeverb
\begin{verbatim}
canvas.line([[0, 100], [100, 200], [200, 100]], width=10)
\end{verbatim}
\afterverb
%
{\tt polygon} nhận vào cũng các đối số như trên, nhưng nó còn
vẽ thêm một đoạn thẳng nối hai điểm đầu cuối của đa giác
(nếu cần) và tô màu nó:

\beforeverb
\begin{verbatim}
canvas.polygon([[0, 100], [100, 200], [200, 100]],
               fill='red', outline='orange', width=10)
\end{verbatim}
\afterverb
%


\section{Các widget khác}

\index{Text (widget)}
\index{widget!Text}

Tkinter có hai loại widget cho phép người dùng gõ chữ vào: 
Entry, chứa một dòng chữ, và Text, chứa nhều dòng.

\index{Entry (widget)}
\index{widget!Entry}

{\tt en} tạo ra một Entry mới:

\beforeverb
\begin{verbatim}
entry = g.en(text='Default text.')
\end{verbatim}
\afterverb
%
Tuỳ chọn {\tt text} cho phép bạn đưa chữ vào Entry một khi nó
được tạo ra. Phương thức {\tt get} trả về nội dung của
Entry (mà người dùng thay đổi được):

\beforeverb
\begin{verbatim}
>>> entry.get()
'Default text.'
\end{verbatim}
\afterverb
%
{\tt te} tạo ra một widget kiểu Text:

\beforeverb
\begin{verbatim}
text = g.te(width=100, height=5)
\end{verbatim}
\afterverb
%
{\tt width} và {\tt height} là các kích thước của
tính theo số kí tự bề rộng và số dòng.

{\tt insert} đặt đoạn chữ vào trong widget kiểu Text:

\beforeverb
\begin{verbatim}
text.insert(END, 'A line of text.')
\end{verbatim}
\afterverb
%
{\tt END} là một chỉ số đặc biệt để biểu thị kí tự cuối trong widget kiểu
Text.

Bạn cũng có thể chỉ định một kí tự bằng cách dùng chỉ số dấu chấm, như {\tt 1.1},
trong đó số dòng đi trước dấu chấm còn số cột đi sau.
Ví dụ sau thêm chữ vào sau kí tự thứ nhất của dòng đầu tiên.

\beforeverb
\begin{verbatim}
>>> text.insert(1.1, 'nother')
\end{verbatim}
\afterverb
%
Phương thức {\tt get} đọc những chữ có trong widget; nó nhận các đối số
gồm có chỉ số đầu và cuối. Ví dụ sau trả về toàn bộ chữ trong widget, kể cả
kí tự xuống dòng:

\beforeverb
\begin{verbatim}
>>> text.get(0.0, END)
'Another line of text.\n'
\end{verbatim}
\afterverb
%
Phương thức {\tt delete} xoá chữ trong widget;
ví dụ sau xoá toàn bộ, chỉ để lại hai kí tự đầu tiên:

\beforeverb
\begin{verbatim}
>>> text.delete(1.2, END)
>>> text.get(0.0, END)
'An\n'
\end{verbatim}
\afterverb
%

\begin{ex}
\label{circle2}

Hãy sửa lại lời giải của bạn cho Bài tập~\ref{circle} bằng cách thêm vào
một widget kiểu Entry và một nút thứ hai. Khi người dùng nhấn nút thứ hai,
chương trình sẽ đọc một tên màu từ Entry và dùng nó để đổi cho
màu tô hình tròn. Hãy dùng {\tt config}
để sửa đổi hình tròn đã có; đừng tạo ra hình mới.

Chương trình của bạn cần giải quyết được các trường hợp khi người dùng thử
thay đổi màu của một hình tròn khi nó chưa được tạo ra, và trường hợp khi
tên màu không hợp lệ.

Bạn có thể xem lời giải của tôi tại \url{thinkpython.com/code/circle_demo.py}.

\end{ex}


\section{Xếp các widget}

Đến đây ta đã xếp các widget theo một cột thẳng đứng, nhưng trong hầu hết
các GUI, sự sắp xếp còn phức tạp hơn nhiều. Chẳng hạn, sau đây là một
phiên bản được rút gojn chút ít từ TurtleWorld (xem
Chương~\ref{turtlechap}).

\beforefig
\centerline{
\includegraphics[width=1.0\textwidth]{figs/TurtleWorld.eps}
}
\afterfig

Mục này trình bày đoạn mã dùng để tạo ra GUI này, chia nhỏ thành
một loạt các bước. Bạn có thể tải về ví dụ trọn vẹn 
từ \url{thinkpython.com/code/SimpleTurtleWorld.py}.

Ở cấp cao nhất, GUI này chứa hai widget---một Canvas và một Frame
---được xếp theo hàng ngang. Vì vậy bước thứ nhất là tạo ra hàng đó.

\index{SimpleTurtleWorld (lớp)}
\index{lớp!SimpleTurtleWorld}

\beforeverb
\begin{verbatim}
class SimpleTurtleWorld(TurtleWorld):
    """This class is identical to TurtleWorld, but the code that
    lays out the GUI is simplified for explanatory purposes."""

    def setup(self):
        self.row()
        ...
\end{verbatim}
\afterverb
%
{\tt setup} là hàm dùng để tạo ra và sắp xếp các widget.
Việc sắp đặt các widget trong GUI còn được gọi là {\bf xếp}.

\index{xếp widget}
\index{widget, xếp}
\index{Frame (widget)}
\index{widget!Frame}

{\tt row} tạo ra một Frame hàng và làm nó trở nên ``Frame hiện hành.''
Cho đến tận khi Frame này được đóng lại hoặc một Frame khác được tạo ra, tất cả
các widget tiếp theo đều được xếp trên một hàng.

Sau đây là đoạn mã dùng để tạo Canvas và Frame cột để 
chứa những widget khác:

\beforeverb
\begin{verbatim}
        self.canvas = self.ca(width=400, height=400, bg='white')
        self.col()
\end{verbatim}
\afterverb
%
Widget thứ nhất trong cột là một Frame lưới, trong đó lại chứa
bốn nút được xếp theo hai hàng và hai cột:

\beforeverb
\begin{verbatim}
        self.gr(cols=2)
        self.bu(text='Print canvas', command=self.canvas.dump)
        self.bu(text='Quit', command=self.quit)
        self.bu(text='Make Turtle', command=self.make_turtle)
        self.bu(text='Clear', command=self.clear)
        self.endgr()
\end{verbatim}
\afterverb
%
{\tt gr} tạo ra lưới; đối số ở đây là số cột.
Các widget trong lưới
được đặt lần lượt từ trái sang phải, từ trên xuống dưới.

\index{điểm gọi lại}
\index{hạn hẹp, phương thức}
\index{phương thức!hạn hẹp}
\index{chủ thể}

Nút thứ nhất sử dụng {\tt self.canvas.dump} làm điểm gọi lại; còn nút
thứ hai dùng {\tt self.quit}.  Đó là những {\bf phương thức hạn hẹp}, theo nghĩa
là chúng được gắn với những đối tượng cụ thể. Khi được kích hoạt, chúng
được gọi với các đối tượng đó.

Widget tiếp theo trong cột là một Frame hàng có chứa một
Button và một Entry:

\beforeverb
\begin{verbatim}
        self.row([0,1], pady=30)
        self.bu(text='Run file', command=self.run_file)
        self.en_file = self.en(text='snowflake.py', width=5)
        self.endrow()
\end{verbatim}
\afterverb
%
Đối số thứ nhất cho {\tt row} là một danh sách các trọng số
dùng để xác định xem có bao nhiêu khoảng trống phụ thêm được đặt
giữa các widget.
Danh sách {\tt [0,1]} nghĩa là toàn bộ khoảng trống thêm vào được
dành cho widget thứ hai, tức là Entry.  Nếu chạy chương trình và
thay đổi kích cỡ cửa sổ, bạn sẽ thấy rằng Entry sẽ được phóng to
hoặc thu nhỏ, còn Button thì không.

Tùy chọn {\tt pady} ``chèn'' hàng này theo phương $y$,
bằng cách thêm vào 30 pixel khoảng trống cả phía trên lẫn dưới.

{\tt endrow} kết thúc hàng widget này, vì vậy các widget tiếp theo 
được xếp trong Frame cột. {\tt Gui.py} lưu giữ một chồng các Frame:

\begin{itemize}

\item Khi bạn dùng {\tt row}, {\tt col} hoặc {\tt gr} để tạo ra Frame,
nó sẽ được xếp lên đỉnh của chồng và trở nên Frame hiện hành.

\item Khi bạn dùng {\tt endrow}, {\tt endcol} hoặc {\tt endgr} để đóng
một Frame, nó được đẩy khỏi chồng xếp và Frame liền trước đó trên chồng
trở thành Frame hiện hành.

\end{itemize} 

Phương thức \verb"run_file" đọc vào nội dung của Entry,
dùng nó như một tên file, đọc vào nội dung
và chuyển nó đến cho \verb"run_code".  Còn {\tt self.inter} là một
đối tượng Interpreter (trình thông dịch) để nhận vào một chuỗi và
thực hiện nó như đoạn mã lệnh Python.

\beforeverb
\begin{verbatim}
    def run_file(self):
        filename = self.en_file.get()
        fp = open(filename)
        source = fp.read()
        self.inter.run_code(source, filename)
\end{verbatim}
\afterverb
%
Hai widget sau cùng gồm có một Text và một Button:

\beforeverb
\begin{verbatim}
        self.te_code = self.te(width=25, height=10)
        self.te_code.insert(END, 'world.clear()\n')
        self.te_code.insert(END, 'bob = Turtle(world)\n')

        self.bu(text='Run code', command=self.run_text)
\end{verbatim}
\afterverb
%
\verb"run_text" cũng tương tự như \verb"run_file", chỉ khác ở chỗ nó lấy
đoạn mã từ widget Text thay vì lấy từ file:

\beforeverb
\begin{verbatim}
    def run_text(self):
        source = self.te_code.get(1.0, END)
        self.inter.run_code(source, '<user-provided code>')
\end{verbatim}
\afterverb
%
Thật không may là chi tiết về cách sắp đặt widget rất khác nhau
giữa các ngôn ngữ, và giữa các module trong Python.
Riêng Tkinter cho phép ba cơ chế sắp đặt widget. Các cơ chế này
được gọi là {\bf quản lí không gian}.
Cơ chế mà tôi giới thiệu trong mục này được gọi là quản lí không gian
dạng ``lưới''; các dạng khác là ``xếp'' và ``đặt''.

\index{quản lí không gian}

May mắn là phần nhiều các khái niệm trong mục này cũng áp dụng
được cho các module lập GUI và các ngôn ngữ khác.


\section{Trình đơn và các {\em Callable}}

\index{Menubutton (widget)}
\index{widget!Menubutton}

Menubutton là một widget trông giống như một nút, nhưng khi bạn nhấn,
nó sẽ bật ra một trình đơn. Sau khi người dùng chọn một mục, trình đơn
sẽ biến mất.

Sau đây là đoạn mã nhằm tạo ra một Menubutton để chọn màu
(bạn có thể tải nó về từ \url{thinkpython.com/code/menubutton_demo.py}):

% mb_example.py

\beforeverb
\begin{verbatim}
g = Gui()
g.la('Select a color:')
colors = ['red', 'green', 'blue']
mb = g.mb(text=colors[0])
\end{verbatim}
\afterverb
%
{\tt mb} tạo ra một Menubutton.  Ban đầu, dòng chữ trên nút là tên gọi của
màu mặc định. Vòng lặp sau đây tạo ra mỗi mục trên trình đơn ứng với
một màu:

\beforeverb
\begin{verbatim}
for color in colors:
    g.mi(mb, text=color, command=Callable(set_color, color))
\end{verbatim}
\afterverb
%
Đối số thứ nhất của {\tt mi} là Menubutton mà các mục này gắn liền với.

\index{điểm gọi lại}
\index{Callable (đối tượng)}
\index{đối tượng!Callable}

Tùy chọn {\tt command} là một đối tượng Callable; đây là một khái niệm mới.
Đến giờ chúng ta đã thấy các hàm và phương thức hạn hẹp được dùng như những
điểm gọi lại, vốn sẽ hoạt động tốt nếu bạn không cần chuyển đối số nào vào
trong hàm. Với trường hợp ngược lại bạn sẽ phải lập một đối tượng Callable
có chứa một hàm, như \verb"set_color", cùng các đối số của nó,
như {\tt color}.

Đối tượng Callable lưu trữ một tham chiếu đến hàm và các đối số, tất cả
như những thuộc tính. Sau này, khi người dùng kích chuột vào một mục
trên trình đơn, điểm gọi lại sẽ gọi hàm và truyền vào các đối số được
lưu trữ.

Có thể viết \verb"set_color" như sau:

\beforeverb
\begin{verbatim}
def set_color(color):
    mb.config(text=color)
    print color
\end{verbatim}
\afterverb
%
Khi người dùng chọn một mục trên trình đơn và \verb"set_color" được gọi,
nó sẽ đặt cấu hình cho Menubutton để hiển thị màu mới được chọn.
Nó cũng in ra tên màu; nếu bạn thử ví dụ này, bạn sẽ thấy đúng là 
\verb"set_color" được gọi khi bạn chọn một mục (và {\em không}
được gọi khi bạn tạo ra đối tượng Callable).


\section{Bó buộc}

\index{bó buộc}
\index{điểm gọi lại}

{\bf Bó buộc} là việc gắn một widget, một sự kiện và một điểm gọi lại
với nhau: khi một sự kiện (như việc nhấn nút) xảy ra đối với widget, 
điểm gọi lại sẽ được kích hoạt.

Nhiều widget có những bó buộc mặc định. Chẳng hạn, khi bạn nhấn
một nút, sự bó buộc mặc định sẽ thay đổi nền của nút bấm khiến nó
trông như bị lõm xuống. Khi bạn nhả tay ra, sự bó buộc sẽ làm
phục hồi vẻ bề ngoài của nút và kích hoạt điểm gọi lại được
chỉ định ở tùy chọn {\tt command}.

Bạn có thể dùng phương thức {\tt bind} để thay thế đè lên những
bó buộc mặc định này, hoặc tạo ra những bó buộc mới. Chẳng hạn,
đoạn mã này tạo ra một bó buộc cho nền (bạn có thể tải về các
đoạn mã ở mục này từ địa chỉ \url{thinkpython.com/code/draggable_demo.py}):

\beforeverb
\begin{verbatim}
ca.bind('<ButtonPress-1>', make_circle)
\end{verbatim}
\afterverb
%
Đối số thứ nhất là một chuỗi chứa sự kiện; sự kiện này được
bật lên khi người dùng ấn nút chuột bên trái. Các sự kiện khác
liên quan đến thao tác chuột gồm có {\tt ButtonMotion}, {\tt ButtonRelease} và
{\tt Double-Button}.

\index{chuỗi chứa sự kiện}
\index{chuôi nắm sự kiện}

Đối số thứ hai là chuôi nắm sự kiện. Một chuôi nắm sự kiện là một
hàm hoặc phương thức hạn hẹp, giống như một điểm gọi lại, nhưng có một
khác biệt quan trọng là chuôi nắm sự kiện nhận đối tượng Event làm
tham biến. Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
def make_circle(event):
    pos = ca.canvas_coords([event.x, event.y])
    item = ca.circle(pos, 5, fill='red')
\end{verbatim}
\afterverb
%
Đối tượng Event bao gồm thông tin về kiểu sự kiện và các chi tiết như
tọa độ của con trỏ chuột. Ở ví dụ này thông tin mà ta cần là
vị trí của con trỏ khi kích chuột. Các giá trị này được đo bằng
``tọa độ pixel,'' vốn được định nghĩa bởi 
hệ thống đồ họa bên trong. Phương thức \verb"canvas_coords"
viết tắt từ ``Canvas coordinates,'' cũng tương thích với các 
phương thức của Canvas như {\tt circle}.

\index{Event (đối tượng)}
\index{đối tượng!Event}

Với các widget Entry, cách thông thường là buộc chúng với sự kiện \verb"<Return>",
vốn được bật ra khi người dùng gõ phím {\sf Return} hay
{\sf Enter}. Chẳng hạn, đoạn mã sau tạo ra một Button
và một Entry.

\beforeverb
\begin{verbatim}
bu = g.bu('Make text item:', make_text)
en = g.en()
en.bind('<Return>', make_text)
\end{verbatim}
\afterverb
%
\verb"make_text" được gọi khi Button được ấn hoặc khi 
người dùng gõ phím {\sf Return} khi đang gõ trong Entry.  Để làm
được điều này, ta cần một hàm có thể gọi được như một lệnh 
(không có đối số) hoặc một chuôi nắm sự kiện (với một Event
làm đối số):

\beforeverb
\begin{verbatim}
def make_text(event=None):
    text = en.get()
    item = ca.text([0,0], text)
\end{verbatim}
\afterverb
%
\verb"make_text" nhận vào nội dung của Entry và hiển thị
nó dưới dạng một item kiểu Text bên trong Canvas.

Cũng có thể tạo ra những bó buộc cho các item trong Canvas.
Sau đây là một lời định nghĩa lớp cho {\tt Draggable},
vốn là một lớp con của {\tt Item} để cung cấp những bó buộc
giúp thực hiện thao tác kéo-và-thả.

\index{kéo-và-thả}

\beforeverb
\begin{verbatim}
class Draggable(Item):

    def __init__(self, item):
        self.canvas = item.canvas
        self.tag = item.tag
        self.bind('<Button-3>', self.select)
        self.bind('<B3-Motion>', self.drag)
        self.bind('<Release-3>', self.drop)
\end{verbatim}
\afterverb
%
Phương thức init nhận một Item làm tham biến. Nó sao chép lại
các thuộc tính của Item rồi tạo những bó buộc cho ba sự kiện:
nhấn nút, nút được nhấn khi di chuyển, và nhả nút.

Một chuôi nắm sự kiện, {\tt select}, lưu trữ các tọa độ của
sự kiện hiện hành và màu ban đầu của đối tượng, sau đó
đổi màu sang vàng:

\beforeverb
\begin{verbatim}
    def select(self, event):
        self.dragx = event.x
        self.dragy = event.y

        self.fill = self.cget('fill')
        self.config(fill='yellow')
\end{verbatim}
\afterverb
%
{\tt cget} viết tắt cho ``get configuration;'' nó nhận vào tên của
một tùy chọn dưới dạng chuỗi và trả lại màu hiện thời của tùy chọn đó.

{\tt drag} tính xem đối tượng phải di chuyển bao xa so với
điểm khởi đầu, cập nhật các tọa độ được lưu lại, và sau đó di chuyển
đối tượng.

\index{cập nhật!tọa độ}

\beforeverb
\begin{verbatim}
    def drag(self, event):
        dx = event.x - self.dragx
        dy = event.y - self.dragy

        self.dragx = event.x
        self.dragy = event.y

        self.move(dx, dy)
\end{verbatim}
\afterverb
%
Việc tính toán này được thực hiện trên các tọa độ pixel; ta không cần
phải chuyển về tọa độ của Canvas.

\index{Canvas, tọa độ}
\index{tọa độ!Canvas}
\index{pixel, tọa độ}
\index{tọa độ!pixel}

Sau cùng, {\tt drop} khôi phục lại màu ban đầu của đối tượng:

\beforeverb
\begin{verbatim}
    def drop(self, event):
        self.config(fill=self.fill)
\end{verbatim}
\afterverb
%
Bạn có thể dùng lớp {\tt Draggable} để thêm vào tính năng kéo-và-thả
cho một đối tượng có sẵn. Chẳng hạn, sau đây là một phiên bản được
sửa lại của \verb"make_circle" trong đó dùng {\tt circle} để tạo ra
một Item và {\tt Draggable} để khiến nó kéo được:

\beforeverb
\begin{verbatim}
def make_circle(event):
    pos = ca.canvas_coords([event.x, event.y])
    item = ca.circle(pos, 5, fill='red')
    item = Draggable(item)
\end{verbatim}
\afterverb
%
Ví dụ này cho thấy một trong những lợi ích của việc thừa kế: bạn có thể
sửa lại tính năng của một lớp cha mẹ mà không cần sửa đổi định nghĩa
của nó. Điều này đặc biệt có ích nếu bạn muốn thay đổi biểu hiện
được định nghĩa trong một module mà bạn không viết ra.


\section{Gỡ lỗi}
\index{gỡ lỗi}

Một trong những khó khăn khi lập trình GUI là phải theo dõi
những việc nào xảy ra trong khi xây dựng GUI và những việc nào
sẽ xảy ra để phản hồi lại sự kiện từ phía người dùng.

\index{điểm gọi lại}

Chẳng hạn, khi bạn thiết lập một điểm gọi lại, một lỗi thông thường là
gọi hàm thay vì chuyển một tham chiếu chỉ đến nó:

\beforeverb
\begin{verbatim}
def the_callback():
    print 'Called.'

g.bu(text='This is wrong!', command=the_callback())
\end{verbatim}
\afterverb
%
Nếu chạy đoạn mã này, bạn sẽ thấy rằng nó gọi \verb"the_callback"
lập tức, và {\em sau đó} mới tạo ra nút. Khi bạn ấn nút, chương trình
sẽ không làm gì vì bạn giá trị được trả về từ
\verb"the_callback" là {\tt None}.
Thường thì bạn sẽ không muốn kích hoạt một điểm gọi lại khi đang 
xây dựng GUI; nó cần được kích hoạt sau này, để phản hồi lại sự kiện
từ phía người dùng.

\index{luồng thực hiện}
\index{lập trình hướng sự kiện}

Một khó khăn khác của lập trình GUI là bạn không có quyền kiểm soát
luồng thực hiện của chương trình. Phần nào của chương trình được chạy
và thứ tự thực hiện đều được quyết định bởi những thao tác của người dùng.
Điều đó có nghĩa là bạn phải thiết kế chương trình để hoạt động đúng
với một dãy sự kiện bất kì có thể xảy ra.

Chẳng hạn, GUI trong Bài tập~\ref{circle2} có hai widget:
một cái để tạo ra một Circle và cái kia để đổi màu
Circle.  Nếu người dùng tạo ra hình tròn rồi mới đổi màu của nó 
thì không sao. Nhưng điều gì sẽ xảy ra nếu người dùng đổi màu của
một hình tròn thậm chí chưa tồn tại? Hay tạo ra nhiều hình tròn?

Càng có nhiều widget, sẽ càng khó hình dung 
tất cả những dãy sự kiện có thể xảy ra. Một cách kiểm soát
sự phức tạp này là bằng cách gói trạng thái của hệ thống vào một
đối tượng rồi xem xét:

\begin{itemize}

\item Các trạng thái có thể là gì? Ở ví dụ với Circle, ta
có thể xét hai trạng thái: trước và sau khi người dùng tạo ra
hình tròn thứ nhất.

\item Với mỗi trạng thai, những sự kiện nào có thể xảy ra? Ở ví dụ trên,
người dùng có thể ấn một trong hai nút, hoặt kết thúc chương trình.

\item Với mỗi cặp trạng thái-sự kiện, đâu là kết quả mong muốn?
Vì có hai trạng thái và hai nút, nên sẽ có bốn cặp trạng thái-sự kiện
cần xét đến.

\item Điều gì có thể gây ra một sự chuyển đổi từ trạng thái này sang
trạng thái khác? Trong trường hợp này, có một sự chuyển đổi khi người dùng
tạo ra hình tròn thứ nhất.

\end{itemize}

Bạn cũng có thể thấy cần định nghĩa, và kiểm tra, những bất biến cần
thỏa mãn bất kể dãy các sự kiện như thế nào.

\index{bất biến}

Phương pháp lập trình GUI này có thể giúp bạn viết mã lệnh đúng
mà không mất thời gian thử từng dãy sự kiện có thể từ phía người dùng!


\section{Thuật ngữ}

\begin{description}

\item[GUI:] Giao diện đồ họa người dùng.
\index{GUI}

\item[widget:] Một trong các yếu tố để tạo nên GUI, bao gồm
nút, trình đơn, ô chữ, v.v.
\index{widget}

\item[tùy chọn:] Giá trị chi phối bề ngoài hoặc tính năng của
một widget.
\index{tùy chọn}

\item[đối số từ khóa:] Đối số để chỉ định tên của tham biến
như một phần của lời gọi hàm.
\index{đối số từ khóa}

\item[điểm gọi lại:] Hàm gắn liền với một widget và sẽ được gọi
khi người dùng thực hiện thao tác.
\index{điểm gọi lại}

\item[phương thức hạn hẹp:] Phương thức gắn với một cá thể riêng.
\index{phương thức hạn hẹp}

\item[lập trình hướng sự kiện:] Phong cách lập trình trong đó
luồng thực hiện được quyết định bởi thao tác từ phía người dùng.
\index{lập trình hướng sự kiện}

\item[sự kiện:] Thao tác từ phía người dùng, như kích chuột, gõ phím
để GUI phản hồi lại.
\index{sự kiện}

\item[vòng lặp sự kiện:] Vòng lặp vô hạn để đợi thao tác từ phía người dùng
và phản hồi.
\index{vòng lặp sự kiện}

\item[item:] Một yếu tố đồ họa trên widget kiểu Canvas.
\index{item!Canvas}

\item[hình bao:] Hình chữ nhật bao chứa một nhóm các item,
thường được chỉ định bởi hai góc đối diện.
\index{hình bao}

\item[xếp:] Sắp xếp và hiển thị các yếu tố của GUI.
\index{xếp widget}

\item[quản lí không gian:] Hệ thống giúp xếp các widget.
\index{quản lí không gian}

\item[bó buộc:] Hình thức gắn kết giữa một widget, một sự kiện, và
một chuôi nắm sự kiện. Chuôi nắm sẽ được gọi khi sự kiện xảy ra
đối với widget.
\index{binding}

\end{description}


\section{Bài tập}

\begin{ex}
\index{trình xem ảnh}

Trong bài tập này, bạn sẽ viết một trình xem ảnh. Sau đây
là một ví dụ đơn giản:

\beforeverb
\begin{verbatim}
g = Gui()
canvas = g.ca(width=300)
photo = PhotoImage(file='danger.gif')
canvas.image([0,0], image=photo)
g.mainloop()
\end{verbatim}
\afterverb
%
{\tt PhotoImage} đọc vào một file  và trả lại một đối tượng {\tt PhotoImage} 
mà Tkinter có thể hiển thị. {\tt Canvas.image} đặt hình ảnh lên nền,
căn giữa theo các tọa độ cho trước. Bạn cũng có thể đặt các hình lên
nhãn, nút, và một số widget khác:

\beforeverb
\begin{verbatim}
g.la(image=photo)
g.bu(image=photo)
\end{verbatim}
\afterverb
%
PhotoImage chỉ có thể xử lí một số ít định dạng ảnh, như GIF and PPM,
nhưng ta có thể dùng Python Imaging Library (PIL) để đọc các dạng file khác.

\index{Python Imaging Library (PIL)}
\index{PIL (Python Imaging Library)}
\index{Image (module)}
\index{module!Image}

Tên của module trong PIL là {\tt Image}, nhưng Tkinter đã định nghĩa một 
đối tượng cùng tên. Để tránh sự xung khắc này, bạn có thể dùng {\tt
  import...as} như sau:

\beforeverb
\begin{verbatim}
import Image as PIL
import ImageTk
\end{verbatim}
\afterverb
%
Dòng đầu tiên nhập vào {\tt Image} và
đặt cho nó tên địa phương là {\tt PIL}.  Dòng thứ hai
nhập vào {\tt ImageTk}, vốn có thể chuyển một hình PIL
thành dạng PhotoImage của Tkinter. Sau đây là một ví dụ:

\beforeverb
\begin{verbatim}
image = PIL.open('allen.png')
photo2 = ImageTk.PhotoImage(image)
g.la(image=photo2)
\end{verbatim}
\afterverb
%

\begin{enumerate}

\item Hãy tải về \verb"image_demo.py", \verb"danger.gif" và \verb"allen.png"
từ \url{thinkpython.com/code}.  Chạy \verb"image_demo.py".  Bạn
có thể phải cài đặt {\tt PIL} và {\tt ImageTk}.  
Chúng có thể đã sẵn có trong kho phần mềm của máy bạn, nhưng
nếu chưa thì có thể tải được về từ \url{pythonware.com/products/pil/}.

\item Trong \verb"image_demo.py", hãy đổi tên của
PhotoImage thứ hai từ {\tt photo2} thành {\tt photo} và chạy lại chương trình.
Bạn cần thấy được PhotoImage thứ hai chứ không phải tấm thứ nhất.

Vấn đề là khi bạn gán lại {\tt photo} nó ghi đè lên
tham chiếu đến PhotoImage thứ nhất, mà bản thân sau đó sẽ mất đi. Điều 
tương tự cũng xảy ra khi bạn gán một PhotoImage cho một biến
địa phương; nó biến mất khi hàm kết thúc.

Để tránh điều này, bạn phải lưu một tham chiếu cho mỗi
PhotoImage mà bạn muốn giữ lại. Bạn có thể dùng một biến toàn cục,
hoặc lưu lại các PhotoImage trong một cấu trúc dữ liệu hoặc dưới dạng
thuộc tính của một đối tượng.

Biểu hiện này có thể rất khó chịu, chính vì vậy mà tôi báo cho bạn biết
(và hình dùng cho thí nghiệm này có chữ ``Danger!'').

\index{lỗi!khó nhất}

\item Bắt đầu từ ví dụ này, hãy viết một chương trình để nhận vào tên
của một thư mục và lặp qua tất cả các file, hiển thị 
những file mà PIL coi là hình ảnh. Bạn có thể dùng lệnh {\tt try}
để bắt những file mà PIL không nhận là ảnh.

Khi người dùng kích chuột vào ảnh, chương trình cần phải hiển thị tấm tiếp theo.

\item PIL có nhiều phương thức xử lí ảnh. Bạn có thể tham khảo toàn bộ
tại \url{pythonware.com/library/pil/handbook}.
Hãy chọn ra một số phương thức, đố bạn lập một GUI để áp dụng những
phương thức đó lên tấm ảnh?

\end{enumerate}

Bạn có thể tải về một lời giải đơn giản từ
\url{thinkpython.com/code/ImageBrowser.py}.

\end{ex}


\begin{ex}

\index{đồ hoạ véc-tơ}
\index{SVG}

Một trình đồ họa véc-tơ là một chương trình cho phép người dùng vẽ
và chỉnh sửa những hình trên màn hình và tạo ra các file kết quả
dưới dạng đồ họa véc-tơ như Postscript và SVG\footnote{Xem
  \url{wikipedia.org/wiki/Vector_graphics_editor}.}.

Hãy viết một chương trình xử lí đồ họa véc-tơ bằng Tkinter.
Ít nhất nó phải cho phép người dùng vẽ đường thẳng, hình tròn,
hình chữ nhật, và phải dùng {\tt Canvas.dump} để 
phát sinh bản mô tả Postscript cho nội dung trên
Canvas.

Đố bạn lập trình cho phép người dùng chọn và thay đổi kích cỡ
của các item trên Canvas.

\end{ex}


\begin{ex}

Dùng Tkinter để viết một trình duyệt web đơn giản. Nó phải
có một widget kiểu Text cho phép người dùng nhập vào một URL
và một Canvas để hiển thị nội dung của trang web.

\index{urllib (module)}
\index{module!urllib}
\index{URL}
\index{HTMLParser (module)}
\index{module!HTMLParser}

Bạn có thể dùng module {\tt urllib} để tải về các file
(xem Exercise~\ref{urllib}) và
module {\tt HTMLParser} để tách các thẻ HTML
(xem \url{docs.python.org/lib/module-HTMLParser.html}).

\index{văn bản chữ thuần túy}
\index{link}

Ít nhất là trình duyệt mà bạn viết phải xử lí được văn bản chữ thuần túy
và các liên kết (đường link). Đố bạn lập trình xử lí màu nền, các
thẻ định dạng và hình ảnh.

\end{ex}



\appendix

\chapter{Gỡ lỗi}
\index{gỡ lỗi}

Những kiểu lỗi khác nhau có thể xảy ra trong chương trình,
và việc phân biệt chúng rất có ích để giúp tìm được lỗi nhanh hơn:

\begin{itemize}

\item Các lỗi cú pháp thường được Python báo khi nó dịch từ 
  mã lệnh sang mã byte. Các lỗi loại này thường để chỉ rằng có 
  điều gì đó không ổn trong cú pháp của chương trình. Chẳng hạn: Quên mất
  dấu hai chấm ở cuối dòng lệnh {\tt def} sẽ cho ra một thông báo lỗi
  có phần dư thừa {\tt SyntaxError: invalid syntax}.

\item Các lỗi thực thi được trình thông dịch báo nếu có điều không ổn
  khi chương trình đang chạy. Hầu hết các thông báo lỗi thực thi đều
  kèm theo thông tin về vị trí lỗi xảy ra và những hàm nào đã được
  thực hiện. Ví dụ: Một phép đệ quy vô hạn cuối cùng sẽ 
  gây ra lỗi thực thi ``maximum recursion depth exceeded.''

\item Các lỗi ngữ nghĩa là những vấn đề với chương trình được chạy mà 
  không phát sinh thông báo lỗi nhưng không làm đúng công việc như đã định. Chẳng hạn:
  Một biểu thức không được tính theo thứ tự mà bạn trông đợi và cho kết quả
  không chính xác.

\end{itemize}

\index{cú pháp, lỗi}
\index{thực thi, lỗi}
\index{ngữ nghĩa, lỗi}
\index{lỗi!khi biên dịch}
\index{lỗi!cú pháp}
\index{lỗi!thực thi}
\index{lỗi!ngữ nghĩa}
\index{biệt lệ}

Bước đầu trong quá trình gỡ lỗi là hình dung ra loại lỗi nào mà bạn 
cần giải quyết. Mặc dù các mục tiếp sau đây được tổ chức theo
loại lỗi, song những kĩ thuật có thể được dùng để giải quyết 
nhiều trường hợp.


\section{Lỗi cú pháp}

\index{thông báo lỗi}

Các lỗi cú pháp thường dễ sửa một khi bạn đã hình dung ra chúng.
Không may là những thông báo lỗi thường không giúp ích nhiều.
Những dòn thông báo thường gặp nhất là {\tt SyntaxError: invalid syntax} và
{\tt SyntaxError: invalid token}, cả hai đều không cung cấp nhiều thông tin.

Tuy nhiên dòng thông báo cũng cho bạn biết rắc rối xảy ra ở đâu trong
chương trình. Thực ra, nó cho bán biết nơi mà Python phát hiện ra vấn đề,
vốn không nhất thiết chính là nơi lỗi xảy ra.
Đôi khi lỗi xuất hiện trước vị trí của thông báo lỗi, thường là
ngay ở dòng trước.

\index{tăng dần, phát triển}
\index{kế hoạch phát triển!tăng dần}

Nếu bạn xây dựng chương trình dần từng bước, bạn hẳn đã 
phán đoán hợp lí vị trí xảy ra lỗi. Nó sẽ ở dòng lệnh bạn vừa thêm vào.

Nếu bạn sao chép mã lệnh từ một quyển sách, hãy bắt đầu
bằng việc so sánh cẩn thận mã lệnh của bạn với mã lệnh trong cuốn sách.
Kiểm tra từng kí tự một. Đồng thời nhớ rằng sách cũng có thể sai,
vì vậy nếu bạn thấy có chỗ giống như lỗi, thì hoàn toàn có thể vậy.

Sau đây là một số cách tránh các lỗi cú pháp thông dụng nhất:

\index{cú pháp}

\begin{enumerate}

\item Hãy chắc rằng bạn không dùng một từ khoá Python làm tên biến.

\index{từ khoá}

\item Kiểm tra xem bạn có kèm theo dấu hai chấm ở lệnh đầu các lệnh phức hợp
chưa, bao gồm các lệnh {\tt for}, {\tt while},
{\tt if}, và {\tt def}.

\index{lệnh đầu}
\index{dấu hai chấm}

\item Hãy chắc rằng các chuỗi trong mã lệnh đều có đủ cặp nháy kép.

\index{dấu nháy kép}

\item Nếu bạn có chuỗi rải trên nhiều dòng với cặp ba dấu nháy (nháy đơn hoặc nháy kép), 
hãy chắc rằng bạn có kết thúc chuỗi một cách đúng đắn. Một chuỗi
bỏ lửng có thể gây ra lỗi {\tt invalid token} ở điểm cuối chương trình,
hoặc coi phần còn lại của chương trình như một chuỗi đến khi nó bắt gặp
chuỗi tiếp theo. Trong trường hợp thứ hai, nó thậm chí còn không báo lỗi gì!

\index{chuỗi!nhiều dòng}

\item Một toán tử mở ngoặc---\verb+(+, \verb+{+, hay
  \verb+[+---mà quên được đóng sẽ làm cho Python chạy tiếp lấy dòng bên dưới
  làm một phần của câu lệnh hiện hành. Thường thì lỗi sẽ xuất hiện 
  ngay ở dòng kế tiếp.

\item Kiểm tra lỗi kinh điển xảy ra khi dùng {\tt =} thay vì {\tt ==} trong
câu lệnh điều kiện.

\index{lệnh điều kiện}

\item Kiểm tra sự thụt đầu dòng để đảm bảo tính đúng đắn. 
Python có thể xử lí các dấu cách và dấu tab, nhưng nếu bạn dùng 
lẫn cả hai loại có thể sẽ có vấn đề. Cách tốt nhất để tránh điều này
là dùng một trình soạn văn bản chữ có thể nhận ra ngôn ngữ Python và
tự căn lề một cách thống nhất.

\index{thụt đầu dòng}
\index{dấu trắng}

\end{enumerate}

Nếu các biện pháp trên đều không có tác dụng, hãy đọc mục tiếp theo...


\subsection{Tôi vẫn tiếp tục sửa đổi mà chẳng thấy gì khác.}

Nếu trình thông dịch báo rằng có lỗi và bạn không nhìn ra thì có thể 
vì bạn và trình thông dịch không nhìn vào cùng một đoạn mã. Hãy
kiểm tra lại môi trường lập trình của bạn để chắc rằng chương trình
mà bạn đang soạn thảo cũng chính được chạy bởi Python.

Nếu bạn không chắc chắn, hãy thử cố ý đưa vào một lỗi cú pháp hiển nhiên
vào ngay đầu chương trình. Bây giờ chạy lại chương trình. Nếu trình
thông dịch không tìm thấy lỗi mới thì rõ ràng là bạn không chạy 
đoạn mã lệnh mới.

Sau đây là một số trường hợp sai lầm dễ gặp:

\begin{itemize}

\item Bạn đã soạn thảo file mà lại quên lưu vào trước khi
chạy lại. Một số môi trường lập trinh giúp bạn làm điều này,
nhưng số khác thì không.

\item Bạn đổi tên file, nhưng vẫn chạy chương trình có tên cũ.

\item Một chi tiết trong môi trường phát triển bị thiết lập sai.

\item Nếu bạn đang viết một module và dùng lệnh {\tt import},
hãy chắc rằng bạn không đặt tên module giống như một trong những
module tiêu chuẩn của Python.

\index{module!reload}
\index{tải lại, hàm}
\index{hàm!reload}

\item Nếu bạn đang dùng {\tt import} để đọc một module, hãy nhớ rằng
bạn phải khởi động lại trình thông dịch hoặc dùng {\tt reload}
để đọc một file đã bị chỉnh sửa. Còn nếu bạn nhập lại module thì 
máy sẽ chẳng làm gì.

\end{itemize}

Nếu bạn bị bí và không thể hình dung được chuyện gì đang xảy ra, 
một cách là bắt đầu lại từ đầu với một chương trình kiểu như ``Hello, World!,''
và chắc rằng bạn biết cách chạy một chương trình có sẵn. Sau đó 
dần thêm từng phần của chương trình cần chạy vào chương trình mới này.


\section{Lỗi thực thi}

Một khi chương trình của bạn đã đúng về mặt cú pháp,
Python có thể biên dịch nó và ít nhất là bắt đầu chạy nó.
Điều gì có thể trục trặc nữa?


\subsection{Chương trình của tôi hoàn toàn không làm gì.}

Vấn đề này thường gặp nhất khi file của bạn có chứa các hàm và
lớp nhưng không thực sự kích hoạt gì để bắt đầu thực hiện tính toán.
Có thể điều này được định sẵn nếu bạn chỉ nhập module này để
cung cấp các lớp và hàm.

Nhưng nếu không phải vì lí do đinh sẵn, thì hãy chắc rằng bạn 
đã gọi một hàm để thực hiện tính toán, hoặc thực thi nó từ
dấu nhắc lệnh. Ngoài ra, cũng xem thêm mục ``Luồng thực hiện'' 
tiếp theo.


\subsection{Chương trình bị treo.}
\index{vòng lặp vô hạn}
\index{đệ quy vô hạn}
\index{treo}

Nếu một chương trình dừng lại và hình như không làm gì, nó đã bị ``treo.''
Thường thì điều này nghĩa là nó mắc phải một vòng lặp vô hạn hoặc
đệ quy vô hạn.

\begin{itemize}

\item Nếu có một vòng lặp cụ thể mà bạn nghi ngờ có vấn đề,
hãy thêm một lệnh {\tt print} ngay trước vòng lặp, để in ra
``tien vao vong lap'' và một lệnh khác ngay sau vòng lặp, in ra
``thoat khoi vong lap''.

Chạy chương trình. Nếu bạn thấy được thông điệp thứ nhất mà không thấy
cái thứ hai thì đã có một vòng lặp vô hạn. Xem tiếp mục ``Vòng lặp vô hạn''
dưới đây.

\item Ở hầu hết trường hợp, đệ quy vô hạn sẽ làm cho chương trình
chạy một lúc và sau đo hiện ra lỗi ``RuntimeError: Maximum
recursion depth exceeded''.  Nếu điều này xảy ra, hãy xem tiếp mục
``Đệ quy vô hạn'' sau đây.

Nếu bạn không gặp phải lỗi này nhưng nghi ngờ rằng có vấn đề xảy ra
với một phương thức hoặc hàm đệ quy, bạn vẫn có thể sử dụng các kĩ thuật
trong mục ``Đệ quy vô hạn''.

\item Nếu không cách nào trong số trên có tác dụng, hãy thử những
hàm và phương thức khác có chứa vòng lặp hoặc đệ quy.

\item Nếu cách này cũng không có tác dụng thì có thể là bạn chưa hiểu
luồng thực hiện của chương trình.
Hãy đọc tiếp mục ``Flow of Execution'' bên dưới.

\end{itemize}


\subsubsection{Vòng lặp vô hạn}
\index{vô hạn, vòng lặp}
\index{vòng lặp!vô hạn}
\index{điều kiện}
\index{vòng lặp!điều kiện}

Nếu bạn nghĩ rằng bạn có một vòng lặp vô hạn và cho rằng mình đã biết
được vòng lặp nào gây ra vấn đề, thì hãy thêm một lệnh {\tt print} tại
điểm cuối vòng lặp và in ra giá trị các biến trong điều kiện cùng với
giá trị của điều kiện.

Chẳng hạn:

\beforeverb
\begin{verbatim}
while x > 0 and y < 0 :
    # thao tac voi x
    # thao tac voi y

    print  "x: ", x
    print  "y: ", y
    print  "dieu kien: ", (x > 0 and y < 0)
\end{verbatim}
\afterverb
%
Bây giờ khi chạy chương trình, bạn sẽ thấy ba dòng kết quả
với mỗi lần chạy qua vòng lặp. Lần cuối cùng chạy qua vòng lặp
điều kiện sẽ phải là {\tt false}.  Nếu vòng lặp tiếp tục chạy,
bạn sẽ nhìn được các giá trị của {\tt x} và {\tt y},
và có thể hình dung được tại sao chúng không được cập nhật đúng.


\subsubsection{Đệ quy vô hạn}
\index{vô hạn, đệ quy}
\index{đệ quy!vô hạn}

Trong nhiều trường hợp, một vòng lặp đệ quy sẽ khiến chương trình 
chạy một lúc và sau đó báo lỗi {\tt Maximum recursion depth exceeded}.

Nếu bạn nghi ngờ rằng một hàm hoặc phương thức nào đó gây ra đệ quy
vô hạn, hãy bắt đàu kiểm tra để chắc rằng có một trường hợp cơ sở.
Nói cách khác, cần phải có điều kiện nào đó để khiến cho hàm hoặc
phương thức trả về mà không gọi đệ quy nữa. Nếu không, bạn cần phải
nghĩ lại thuật toán và tìm ra một trường hợp cơ sở.

Nếu có một trường hợp cơ sở nhưng chương trình dường như không đạt
đến đó, thì hãy thêm câu lệnh {\tt print} vào điểm đầu của hàm hoặc phương thức
để in ra các tham biến. Bây giờ khi chạy chương trình, bạn sẽ thấy
một ít dòng kết quả mỗi lần hàm hoặc phương thức được gọi đến, và 
sẽ thấy ccasc tham biến. Nếu tham biến không thay đổi với xu hướng về
trường hợp cơ sở, bạn sẽ có được nhận định về nguyên nhân tại sao.


\subsubsection{Luồng thực hiện}
\index{luồng thực hiện}

Nếu bạn không chắc chắn về luồng thực hiện trong chương trình, 
hãy thêm các câu lệnh {\tt print} vào điểm đầu của mỗi
hàm với thông báo kiểu như ``bat dau ham {\tt foo},'' trong đó
{\tt foo} là tên hàm.

Bây giờ khi chạy chương trình, nó sẽ in ra một dấu vết của mỗi
hàm khi được gọi đến.


\subsection{Khi chạy chương trình tôi nhận được một biệt lệ.}
\index{biệt lệ}
\index{lỗi thực thi}

Nếu trong quá trình chạy có trục trặc xảy ra, Python 
sẽ in một thông báo trong đó có tên của biệt lệ,
dòng lệnh có vấn đề, và một dò ngược.

\index{dò ngược}

Thông báo dò ngược nhằm chỉ định hàm đang được chạy, và hàm gọi nó,
rồi hàm gọi hàm đó, và cứ như vậy. Nói cách khác, nó dò theo một
dãy các lời gọi hàm để đến nơi có trục trặc. Nó cũng có chứa số
thứ tự dòng trong file nơi mà những lời gọi hàm này diễn ra.

Bước đầu tiên là kiểm tra vị trí trong chương trình nơi mà
lỗi xuất hiện đòng thời thử hình dung điều gì đã xảy ra.
Sau đây là một số lỗi thực thi thường gặp nhất:

\begin{description}

\item[NameError:] Bạn đang cố gắng dùng một biến không tồn tại trong
môi trường hiện hành. Hãy nhớ rằng các biến địa phương chỉ có ý nghĩa
cục bộ. Bạn không thể nhắc đến chúng từ bên ngoài hàm mà chúng được
định nghĩa.

\index{NameError}
\index{TypeError}
\index{biệt lệ!NameError}
\index{biệt lệ!TypeError}

\item[TypeError:] Sau đây là một số lí do khả dĩ:

\begin{itemize}

\item  Bạn đang cố thử dùng một giá trị không đúng cách.  Chẳng hạn: 
lấy chỉ số của một chuỗi, danh sách, hoặc bộ mà dùng kiểu số liệu
không phải số nguyên.

\index{chỉ số}

\item Có sự bất đồng giữa các mục bên trong một chuỗi định dạng và
các mục được truyền vào để chuyển đổi. Điều này có thể xảy ra khi
số các mục không bằng nhau, hoặc thao tác chuyển đổi không hợp lệ.

\index{định dạng, toán tử}
\index{toán tử!định dạng}

\item Bạn đang truyền một số lượng không đúng các đối số vào trong hàm
hoặc phương thức. Với phương thức, hãy xem định nghĩa cảu nó
và kiểm tra rằng tham biến đầu tiên phải là {\tt self}.  Sau đó nhìn vào
lời gọi phương thức; hãy chắc rằng bạn gọi phuonwg thức với đối tượng
có kiểu phù hợp và đã cung cấp các đối số khác một cách đúng đắn.

\end{itemize}

\item[KeyError:] Bạn đang cố gắng truy cập một phần tử của từ điển bằng một
khóa mà từ điển đó không có.

\index{KeyError}
\index{biệt lệ!KeyError}
\index{từ điển}

\item[AttributeError:] Bạn đang cố gắng truy cập một thuộc tính hoặc 
phương thức mà chúng không tồn tại. Hãy kiểm tra tên chữ! Bạn có thể dùng
{\tt dir} để liệt kê những thuộc tính hiện có.

Nếu một AttributeError nói rằng đối tượng có kiểu {\tt NoneType},
điều đó nghĩa là nó là {\tt None}.  Một nguyên nhân thông thường là quên
không trả về giá trị từ một hàm; nếu bạn đã đến điểm cuối của hàm
mà không gặp phải câu lệnh {\tt return}, nó sẽ trả về
{\tt None}. Một lí do thường gặp khác là việc dùng kết quả từ
một phương thức với danh sách, như {\tt sort}, vốn trả về {\tt None}.

\index{AttributeError}
\index{biệt lệ!AttributeError}

\item[IndexError:] Chỉ số mà bạn đang dùng để 
truy cập một danh sách, chuỗi, hoặc bộ lại lớn hơn chiều dài của nó
trừ đi một. Ngay trước điểm gây ra lỗi, hãy thêm vào 
câu lệnh {\tt print} để hiển thị giá trị của chỉ số
cùng với chiều dài của dãy.
Liệu dãy này có kích thước đúng chưa? Chỉ số có đúng không?

\index{IndexError}
\index{biệt lệ!IndexError}

\end{description}

\index{bộ gỡ lỗi (pdb)}
\index{Python debugger (pdb)}
\index{pdb (Python debugger)}

Bộ gỡ lỗi ({\tt pdb}) của Python sẽ giúp ích cho việc dò ra
các biệt lệ vì chúng cho phép bạn kiểm tra trạng thái của
chương trình ngay trước khi có lỗi. Bạn có thể đọc thêm về
{\tt pdb} ở  \url{docs.python.org/lib/module-pdb.html}.


\subsection{Tôi thêm vào quá nhiều lệnh {\tt print} đến nỗi bây giờ
tràn ngập kết quả đầu ra.}

\index{print, lệnh}
\index{lệnh!print}

Một trong những vấn đề khi dùng lệnh {\tt print} để gỡ lỗi là
việc bạn có thể bị chìm trong kết quả ra. Có hai cách tiếp tục:
đơn giản hóa đầu ra hoặc đơn giản hóa chương trình.

Để giản hóa đầu ra, bạn cần xóa bỏ hoặc đưa vào chú thích những dòng lệnh {\tt print}
vốn không có tác dụng, hoặc kết hợp chúng lại, hoặc sửa định dạng
đầu ra để dễ hiểu hơn.

Để giản hóa chương trình, có vài cách làm được. Trước hết, 
hãy giảm quy mô của bài toán xuống. Chẳng hạn, nếu bạn cần tìm kiếm
trong danh sách, hãy làm với danh sách {\em nhỏ}. Nếu chương trình
nhận đầu vào từ phía người dùng, hãy cho những dữ liệu vào đơn giản
mà gây ra lỗi.

\index{mã lệnh chết}

Thứ hai là dọn dẹp chương trình. Hãy bỏ những đoạn mã chết và tổ chức lại
chương trình để nó càng dễ đọc càng tốt. Chẳng hạn, nếu bạn nghi rằng
vấn đề nằm ở một đoạn nằm sâu trong chương trình, hãy thử viết lại nó 
với cấu trúc đơn giản hơn. Nếu bạn nghi ngờ rằng có một
hàm lớn, hãy thử chẻ nhỏ thành những hàm con và kiểm tra lần lượt.

\index{chạy thử!trường hợp đơn giản nhất}
\index{trường hợp thử, đơn giản nhất}

Thông thường quá trình tìm ra trường hợp thử đơn giản nhất sẽ dẫn bạn
đến điểm gây lỗi. Nếu bạn thấy được chương trình chạy được trong một
trường hợp nhưng không được trong trường hợp khác, điều đó sẽ là 
dấu vết cho thấy điều gì đang diễn ra.

Tương tự như vậy, việc viết lại một đoạn mã có thể giúp bạn phát hiện
những lỗi nhỏ. Nếu bạn thực hiện sửa đổi mà nghĩ rằng nó không ảnh
hưởng gì đến chương trình, và lúc có ảnh hưởng thì đó sẽ là bài học cho bạn.


\section{Lỗi ngữ nghĩa}
\index{ngữ nghĩa, lỗi}
\index{lỗi!ngữ nghĩa}

Theo khía cạnh nhất định, lỗi ngữ nghĩa là thứ khó gỡ nhất,
vì trình thông dịch không cung cấp thông tin gì về sự trục trặc.
Chỉ có bạn mới biết rằng chương trinh cần phải thực hiện điều gì.

Bước đầu tiên là tạo lập một kết nối giữa nội dung chương trình và 
biểu hiện mà bạn quan sát được. Bạn cần giả thiết về điều thật sự
mà chương trình đang thực hiện. Một trong những yếu tố làm việc này
trở nên khó khăn là máy tính chạy quá nhanh.

Bạn sẽ thường muốn làm chậm chương trình lại ngang bằng tốc độ 
của người, và dùng một số bộ gỡ lỗi nếu có thể. Nhưng thời gian 
càn thiết để chèn thêm một vài lệnh {\tt print} đúng chỗ thường 
ngắn hơn so với việc thiết lập bộ gỡ lỗi, chèn thêm và gỡ bỏ các
điểm dừng, và ``lần bước'' tới điểm xảy ra lỗi trong chương trình.

\subsection{Chương trình tôi viết không hoạt động đúng.}

Bạn cần tự hỏi mình những điều sau:

\begin{itemize}

\item Có điều gì mà chương trình cần phải làm nhưng dường như nó
không làm hay không? Hãy tìm ra đoạn mã lệnh thực hiện tính năng đó
và chắc rằng nó được thực thi khi bạn nghĩ rằng lẽ ra nó phải chạy.

\item Có điều gì đang diễn ra mà lẽ ra không nên có nó? Hãy tìm đoạn
mã trong chương trình mà thực hiện tính năng đó rồi xem liệu nó có
được thực khi trong khi đáng lẽ thì không.

\item Có đoạn mã nào tạo ra một hiệu ứng mà không như bạn mong đợi không?
Hãy chắc rằng bạn hiểu được đoạn mã nghi vấn, đặc biệt khi nó liên quan đến
lời gọi các hàm hoặc phương thức trong module Python khác. Hãy đọc các
tài liệu về hàm mà bạn đã gọi. Thử dùng chúng bằng cách viết các trường hợp
kiểm tra đơn giản và xem xét kết quả.

\end{itemize}

Để lập trình, bạn phải có một mô hình tưởng tượng về cách thức hoạt động
của chương trình. Nếu bạn viết một chương trình mà không thực hiện đúng
việc bạn mong đợi, thì thường là vấn đề không nằm ở chương trình; nó 
nằm ở mô hình tưởng tượng của bạn.

\index{tưởng tượng, mô hình}
\index{mô hình!tưởng tượng}

Cách tốt nhất để sửa mô hình tưởng tượng cho đúng là chia chương trình
thành những bộ phận (thường là các hàm và phương thức) rồi kiểm tra
chạy thử từng bộ phận một cách độc lập. Một khi bạn thấy sự khác biệt
giữa mô hình và thực tế, bạn sẽ có thể giải quyết vấn đề.

Tất nhiên, bạn cần phải xây dựng và chạy thử các bộ phận song song
với việc phát triển chương trình. Nếu bạn gặp vướng mắc,
hẳn chỉ có một phần rất nhỏ những mã lệnh mới đưa vào mà bạn
không chắc rằng nó đúng.


\subsection{Tôi có một biểu thức lớn và gai góc mà chẳng hoạt động
theo sự mong đợi.}

\index{biểu thức!lớn và gai góc}

Việc viết những biểu thức phức tạp cũng tốt miễn là chúng dễ đọc,
nhưng chúng có thể làm việc gỡ lỗi gặp khó khăn. Thông thường
nên chẻ nhỏ một biểu thức thành một loạt các lệnh gán cho
những biến tạm thời.

Chẳng hạn:

\beforeverb
\begin{verbatim}
self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())
\end{verbatim}
\afterverb
%
Đoạn này có thể được viết lại thành:

\beforeverb
\begin{verbatim}
neighbor = self.findNeighbor(i)
pickedCard = self.hands[neighbor].popCard()
self.hands[i].addCard(pickedCard)
\end{verbatim}
\afterverb
%
Dạng mã lệnh chi tiết thì dễ đọc hơn vì tên biến cho ta 
bản thân đã giúp giải thích rõ thêm, và cũng dễ gỡ lỗi hơn vì
bạn có thể kiểm tra kiểu của những biến trung gian cùng việc
hiển thị giá trị của chúng.

\index{tạm thời, biến}
\index{biến!tạm}
\index{thứ tự thực hiện phép tính}
\index{phép ưu tiên}

Một vấn đề khác có thể xảy ra với những biểu thức lớn là
thứ tự thực hiện phép tính có thể không như bạn mong muốn.
Chẳng hạn, nếu bạn dịch biểu thức 
$\frac{x}{2 \pi}$ sang ngôn ngữ Python, có thể bạn đã viết:

\beforeverb
\begin{verbatim}
y = x / 2 * math.pi
\end{verbatim}
\afterverb
%
Điều này không đúng vì các phép nhân và chia có cùng thứ tự
ưu tiên và được lượng giá từ trái sang phải. Vì vậy biểu thức
này sẽ tính $x \pi / 2$.

Một cách hay để gỡ lỗi biểu thức là thêm vào những cặp ngoặc đơn
để giúp cho thứ tự lượng giá được rõ ràng: 
A good way to debug expressions is to add parentheses to make
the order of evaluation explicit:

\beforeverb
\begin{verbatim}
 y = x / (2 * math.pi)
\end{verbatim}
\afterverb
%
Mỗi khi bạn không nắm vững thứ tự ước lượng, hãy dùng 
cặp ngoặc đơn. Chúng không chỉ giúp chương trình đúng đắn hơn
(theo nghĩa thực hiện công việc bạn mong đợi), mà còn giúp
người khác dễ đọc hơn mà không phải ghi nhớ quy luật 
thứ tự ưu tiên.


\subsection{Tôi có một hàm hoặc phương thức không trả về giá trị
được mong đợi.} 
\index{return, câu lệnh}
\index{câu lệnh!return}

Với lệnh {\tt return} kèm theo một biểu thức phức tạp,
bạn không có cơ hội in ra giá trị trước khi được rả về.
Một lần nữa, hãy dùng biến tạm thời. Chẳng hạn, thay vì:

\beforeverb
\begin{verbatim}
return self.hands[i].removeMatches()
\end{verbatim}
\afterverb
%
bạn có thể viết:

\beforeverb
\begin{verbatim}
count = self.hands[i].removeMatches()
return count
\end{verbatim}
\afterverb
%
Bây giờ bạn đã có cơ hội hiển thị giá trị của 
{\tt count} trước khi trả về.


\subsection{Thật sự tôi rất, rất vướng mắc và cần được giúp đỡ.}

Trước hết, hãy thử rời khỏi máy tính trong vài phút. 
Máy tính phát ra sóng từ gây ảnh hưởng đến não, với các triệu chứng sau:

\begin{itemize}

\item Cáu giận.

\index{cáu giận}
\index{gỡ lỗi!phản ứng cảm xúc}
\index{cảm xúc, gỡ lỗi}

\item Tin tưởng vào lực siêu nhiên (``máy tính này ghét tôi'') và
những ảo tưởng (``chương trình chỉ chạy khi tôi đội ngược mũ'').

\index{gỡ lỗi!mê tín}
\index{mê tín, gỡ lỗi}

\item Lập trình bước ngẫu nhiên (nỗ lực lập trình bằng cách viết
tất cả các trường hợp chương trình có thể có và chọn ra một 
phiên bản hoạt động đúng).

\index{lập trình bước ngẫu nhiên}
\index{kế hoạch phát triển!lập trình bước ngẫu nhiên}

\end{itemize}

Nếu bạn tự thấy mình mắc phải một trong số các triệu chứng trên,
hãy đứng dậy và đi dạo. Khi đã tĩnh tâm hẳn, hãy nghĩ lại chương trình.
Nó đang làm điều gì? Đâu là các nguyên nhân gây ra biểu hiện đó?
Lần cuối cùng chương trình cọn chạy được là lúc nào, và sau đó
bạn thực hiện những điều gì?

Đôi khi phát hiện lỗi chỉ là vấn đề thời gian. Tôi thường tìm thấy lỗi
trong lúc rời xa khỏi máy tính và để trí óc khuây khỏa. Một số nơi
tốt nhất để thoát khỏi máy gồm có trên tàu, khi đi tắm, và
trước khi đi ngủ.


\subsection{Không, tôi thật sự muốn giúp đỡ.}

Điều đó xảy ra. Ngay cả những lập trình viên giỏi nhất đôi lúc
cũng bị bí. Đôi khi bạn làm một chương trình lâu quá đến nỗi
không thể phát hiện ra lỗi. Tìm một người có góc nhìn khác
chính là điều cần thiết.

Trước khi yêu cầu giúp đỡ, bạn hãy chuẩn bị kĩ. Chương trình
phải càng đơn giản càng tốt, và hãy phân tích trên dữ liệu
đầu vào nhỏ nhất có thể gây lỗi. Bạn cần có các lệnh {\tt print} 
ở những vị trí thích hợp (và kết quả đầu ra phải dễ hiểu).
Bạn cần hiểu rõ vấn đề để có thể diễn đạt nó một cách ngắn gọn.

Khi đưa người đến giúp, hãy chắc chắn rằng bạn cung cấp
đủ thông tin mà họ cần:

\begin{itemize}

\item Nếu có thông báo lỗi, thông báo đó là gì và nó
chỉ định phần nào trong chương trình?

\item Việc cuối cùng mà bạn thao tác trước khi lỗi này xảy ra là gì?
Những dòng lệnh nào bạn vừa mới viết gần đây nhất, hay trường hợp
chạy thử gần đây nhất mới bị thất bại là gì?

\item Bạn đã thử những biện pháp gì rồi, và thu hoạch được gì?

\end{itemize}

Khi bạn tìm thấy lỗi, hãy nghĩ trong giây lát xem bằng cách nào
có thể giúp bạn tìm ra nó nhanh hơn không. Lần tiếp theo khi bạn
thấy điều tương tự, có thể bạn sẽ chóng phát hiện ra lỗi hơn.

Nhớ rằng mục tiêu không chỉ có làm cho chương trình chạy được.
Mục tiêu là học cách làm cho chương trình chạy được.


\printindex

\clearemptydoublepage
%\blankpage
%\blankpage
%\blankpage


\end{document}
